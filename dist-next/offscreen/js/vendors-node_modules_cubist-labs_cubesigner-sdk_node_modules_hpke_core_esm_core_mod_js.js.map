{"version":3,"file":"js/vendors-node_modules_cubist-labs_cubesigner-sdk_node_modules_hpke_core_esm_core_mod_js.js","sources":["webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/_dnt.shims.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/core/mod.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/core/src/native.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/aeads/aesGcm.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/aeads/exportOnly.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/algorithm.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/cipherSuiteNative.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/encryptionContext.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/exporterContext.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/aeadEncryptionContext.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/dhkemPrimitives.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/kemInterface.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kdfs/hkdf.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkem.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkemNative.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkemPrimitives/ec.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/recipientContext.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/senderContext.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/bignum.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/emitNotSupported.js","webpack://@core/offscreen/../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/misc.js"],"sourcesContent":["const dntGlobals = {};\nexport const dntGlobalThis = createMergeProxy(globalThis, dntGlobals);\nfunction createMergeProxy(baseObj, extObj) {\n    return new Proxy(baseObj, {\n        get(_target, prop, _receiver) {\n            if (prop in extObj) {\n                return extObj[prop];\n            }\n            else {\n                return baseObj[prop];\n            }\n        },\n        set(_target, prop, value) {\n            if (prop in extObj) {\n                delete extObj[prop];\n            }\n            baseObj[prop] = value;\n            return true;\n        },\n        deleteProperty(_target, prop) {\n            let success = false;\n            if (prop in extObj) {\n                delete extObj[prop];\n                success = true;\n            }\n            if (prop in baseObj) {\n                delete baseObj[prop];\n                success = true;\n            }\n            return success;\n        },\n        ownKeys(_target) {\n            const baseKeys = Reflect.ownKeys(baseObj);\n            const extKeys = Reflect.ownKeys(extObj);\n            const extKeysSet = new Set(extKeys);\n            return [...baseKeys.filter((k) => !extKeysSet.has(k)), ...extKeys];\n        },\n        defineProperty(_target, prop, desc) {\n            if (prop in extObj) {\n                delete extObj[prop];\n            }\n            Reflect.defineProperty(baseObj, prop, desc);\n            return true;\n        },\n        getOwnPropertyDescriptor(_target, prop) {\n            if (prop in extObj) {\n                return Reflect.getOwnPropertyDescriptor(extObj, prop);\n            }\n            else {\n                return Reflect.getOwnPropertyDescriptor(baseObj, prop);\n            }\n        },\n        has(_target, prop) {\n            return prop in extObj || prop in baseObj;\n        },\n    });\n}\n","export { Aes128Gcm, Aes256Gcm } from \"../src/aeads/aesGcm.js\";\nexport { ExportOnly } from \"../src/aeads/exportOnly.js\";\nexport * from \"../src/errors.js\";\nexport { AeadId, KdfId, KemId } from \"../src/identifiers.js\";\nexport { CipherSuite, DhkemP256HkdfSha256, DhkemP384HkdfSha384, DhkemP521HkdfSha512, HkdfSha256, HkdfSha384, HkdfSha512, } from \"./src/native.js\";\n","import { CipherSuiteNative } from \"../../src/cipherSuiteNative.js\";\nimport { HkdfSha256Native, HkdfSha384Native, HkdfSha512Native, } from \"../../src/kdfs/hkdf.js\";\nimport { DhkemP256HkdfSha256Native, DhkemP384HkdfSha384Native, DhkemP521HkdfSha512Native, } from \"../../src/kems/dhkemNative.js\";\n/**\n * The Hybrid Public Key Encryption (HPKE) ciphersuite,\n * which is implemented using only\n * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.\n *\n * This class is the same as\n * {@link https://deno.land/x/hpke/mod.ts?s=CipherSuiteNative | @hpke/core#CipherSuiteNative },\n * which supports only the ciphersuites that can be implemented on the native\n * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.\n * Therefore, the following cryptographic algorithms are not supported for now:\n * - `DHKEM(X25519, HKDF-SHA256)`\n * - `DHKEM(X448, HKDF-SHA512)`\n * - `ChaCha20Poly1305`\n *\n * In addtion, the HKDF functions contained in this `CipherSuiteNative`\n * class can only derive keys of the same length as the `hashSize`.\n *\n * If you want to use the unsupported cryptographic algorithms\n * above or derive keys longer than the `hashSize`,\n * please use {@link https://deno.land/x/hpke/mod.ts?s=CipherSuite | hpke-js#CipherSuite}.\n *\n * This class provides following functions:\n *\n * - Creates encryption contexts both for senders and recipients.\n *     - {@link createSenderContext}\n *     - {@link createRecipientContext}\n * - Provides single-shot encryption API.\n *     - {@link seal}\n *     - {@link open}\n *\n * The calling of the constructor of this class is the starting\n * point for HPKE operations for both senders and recipients.\n *\n * @example Use only ciphersuites supported by Web Cryptography API.\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n *   CipherSuite,\n * } from \"http://deno.land/x/hpke/core/mod.ts\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n *\n * @example Use a ciphersuite which is currently not supported by Web Cryptography API.\n *\n * ```ts\n * import { Aes128Gcm, HkdfSha256, CipherSuite } from \"http://deno.land/x/hpke/core/mod.ts\";\n * import { DhkemX25519HkdfSha256 } from \"https://deno.land/x/hpke/x/dhkem-x25519/mod.ts\";\n * const suite = new CipherSuite({\n *   kem: new DhkemX25519HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class CipherSuite extends CipherSuiteNative {\n}\n/**\n * The DHKEM(P-256, HKDF-SHA256) for HPKE KEM implementing {@link KemInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP256HkdfSha256`\n * as follows:\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n * } from \"http://deno.land/x/hpke/core/mod.ts\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class DhkemP256HkdfSha256 extends DhkemP256HkdfSha256Native {\n}\n/**\n * The DHKEM(P-384, HKDF-SHA384) for HPKE KEM implementing {@link KemInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP384HkdfSha384`\n * as follows:\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP384HkdfSha384,\n *   HkdfSha384,\n * } from \"http://deno.land/x/hpke/core/mod.ts\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP384HkdfSha384(),\n *   kdf: new HkdfSha384(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class DhkemP384HkdfSha384 extends DhkemP384HkdfSha384Native {\n}\n/**\n * The DHKEM(P-521, HKDF-SHA512) for HPKE KEM implementing {@link KemInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP521HkdfSha512`\n * as follows:\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes256Gcm,\n *   CipherSuite,\n *   DhkemP521HkdfSha512,\n *   HkdfSha512,\n * } from \"http://deno.land/x/hpke/core/mod.ts\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP521HkdfSha512(),\n *   kdf: new HkdfSha512(),\n *   aead: new Aes256Gcm(),\n * });\n * ```\n */\nexport class DhkemP521HkdfSha512 extends DhkemP521HkdfSha512Native {\n}\n/**\n * The HKDF-SHA256 for HPKE KDF implementing {@link KdfInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha256`.\n *\n * The KDF class can only derive keys of the same length as the `hashSize`.\n * If you want to derive keys longer than the `hashSize`,\n * please use {@link https://deno.land/x/hpke/mod.ts?s=CipherSuite | hpke-js#CipherSuite}.\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n * } from \"http://deno.land/x/hpke/core/mod.ts\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class HkdfSha256 extends HkdfSha256Native {\n}\n/**\n * The HKDF-SHA384 for HPKE KDF implementing {@link KdfInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha384`.\n *\n * The KDF class can only derive keys of the same length as the `hashSize`.\n * If you want to derive keys longer than the `hashSize`,\n * please use {@link https://deno.land/x/hpke/mod.ts?s=CipherSuite | hpke-js#CipherSuite}.\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP384HkdfSha384,\n *   HkdfSha384,\n * } from \"http://deno.land/x/hpke/core/mod.ts\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP384HkdfSha384(),\n *   kdf: new HkdfSha384(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class HkdfSha384 extends HkdfSha384Native {\n}\n/**\n * The HKDF-SHA512 for HPKE KDF implementing {@link KdfInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha512`.\n *\n * The KDF class can only derive keys of the same length as the `hashSize`.\n * If you want to derive keys longer than the `hashSize`,\n * please use {@link https://deno.land/x/hpke/mod.ts?s=CipherSuite | hpke-js#CipherSuite}.\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes256Gcm,\n *   CipherSuite,\n *   DhkemP521HkdfSha512,\n *   HkdfSha512,\n * } from \"http://deno.land/x/hpke/core/mod.ts\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP521HkdfSha512(),\n *   kdf: new HkdfSha512(),\n *   aead: new Aes256Gcm(),\n * });\n * ```\n */\nexport class HkdfSha512 extends HkdfSha512Native {\n}\n","import { NativeAlgorithm } from \"../algorithm.js\";\nimport { AeadId } from \"../identifiers.js\";\nimport { AEAD_USAGES } from \"../interfaces/aeadEncryptionContext.js\";\nexport class AesGcmContext extends NativeAlgorithm {\n    constructor(key) {\n        super();\n        Object.defineProperty(this, \"_rawKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_key\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n        this._rawKey = key;\n    }\n    async seal(iv, data, aad) {\n        await this._setupKey();\n        const alg = {\n            name: \"AES-GCM\",\n            iv: iv,\n            additionalData: aad,\n        };\n        const ct = await this._api.encrypt(alg, this._key, data);\n        return ct;\n    }\n    async open(iv, data, aad) {\n        await this._setupKey();\n        const alg = {\n            name: \"AES-GCM\",\n            iv: iv,\n            additionalData: aad,\n        };\n        const pt = await this._api.decrypt(alg, this._key, data);\n        return pt;\n    }\n    async _setupKey() {\n        if (this._key !== undefined) {\n            return;\n        }\n        await this._setup();\n        const key = await this._importKey(this._rawKey);\n        (new Uint8Array(this._rawKey)).fill(0);\n        this._key = key;\n        return;\n    }\n    async _importKey(key) {\n        return await this._api.importKey(\"raw\", key, { name: \"AES-GCM\" }, true, AEAD_USAGES);\n    }\n}\n/**\n * The AES-128-GCM for HPKE AEAD implementing {@link AeadInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `aead` parameter of {@link CipherSuiteParams} instead of `AeadId.Aes128Gcm`.\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n * } from \"http://deno.land/x/hpke/core/mod.ts\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class Aes128Gcm {\n    constructor() {\n        /** AeadId.Aes128Gcm (0x0001) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: AeadId.Aes128Gcm\n        });\n        /** 16 */\n        Object.defineProperty(this, \"keySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 16\n        });\n        /** 12 */\n        Object.defineProperty(this, \"nonceSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 12\n        });\n        /** 16 */\n        Object.defineProperty(this, \"tagSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 16\n        });\n    }\n    createEncryptionContext(key) {\n        return new AesGcmContext(key);\n    }\n}\n/**\n * The AES-256-GCM for HPKE AEAD implementing {@link AeadInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `aead` parameter of {@link CipherSuiteParams} instead of `AeadId.Aes256Gcm`\n * as follows:\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes256Gcm,\n *   CipherSuite,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n * } from \"http://deno.land/x/hpke/core/mod.ts\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes256Gcm(),\n * });\n * ```\n */\nexport class Aes256Gcm extends Aes128Gcm {\n    constructor() {\n        super(...arguments);\n        /** AeadId.Aes256Gcm (0x0002) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: AeadId.Aes256Gcm\n        });\n        /** 32 */\n        Object.defineProperty(this, \"keySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 32\n        });\n        /** 12 */\n        Object.defineProperty(this, \"nonceSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 12\n        });\n        /** 16 */\n        Object.defineProperty(this, \"tagSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 16\n        });\n    }\n}\n","import { AeadId } from \"../identifiers.js\";\nimport { NotSupportedError } from \"../errors.js\";\n/**\n * The ExportOnly mode for HPKE AEAD implementing {@link AeadInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `aead` parameter of {@link CipherSuiteParams} instead of `AeadId.ExportOnly`\n * as follows:\n *\n * @example\n *\n * ```ts\n * import {\n *   CipherSuite,\n *   DhkemP256HkdfSha256,\n *   ExportOnly,\n *   HkdfSha256,\n * } from \"http://deno.land/x/hpke/core/mod.ts\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new ExportOnly(),\n * });\n * ```\n */\nexport class ExportOnly {\n    constructor() {\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: AeadId.ExportOnly\n        });\n        Object.defineProperty(this, \"keySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"nonceSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"tagSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n    }\n    createEncryptionContext(_key) {\n        throw new NotSupportedError(\"Export only\");\n    }\n}\n","import * as dntShim from \"../_dnt.shims.js\";\nimport { NotSupportedError } from \"./errors.js\";\nasync function loadSubtleCrypto() {\n    if (dntShim.dntGlobalThis !== undefined && globalThis.crypto !== undefined) {\n        // Browsers, Node.js >= v19, Cloudflare Workers, Bun, etc.\n        return globalThis.crypto.subtle;\n    }\n    // Node.js <= v18\n    try {\n        // @ts-ignore: to ignore \"crypto\"\n        const { webcrypto } = await import(\"crypto\"); // node:crypto\n        return webcrypto.subtle;\n    }\n    catch (e) {\n        throw new NotSupportedError(e);\n    }\n}\nexport class NativeAlgorithm {\n    constructor() {\n        Object.defineProperty(this, \"_api\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n    }\n    async _setup() {\n        if (this._api !== undefined) {\n            return;\n        }\n        this._api = await loadSubtleCrypto();\n    }\n}\n","import { NativeAlgorithm } from \"./algorithm.js\";\nimport { EMPTY, INPUT_LENGTH_LIMIT, MINIMUM_PSK_LENGTH } from \"./consts.js\";\nimport { InvalidParamError } from \"./errors.js\";\nimport { RecipientExporterContextImpl, SenderExporterContextImpl, } from \"./exporterContext.js\";\nimport { AeadId, Mode } from \"./identifiers.js\";\nimport { RecipientContextImpl } from \"./recipientContext.js\";\nimport { SenderContextImpl } from \"./senderContext.js\";\nimport { i2Osp } from \"./utils/misc.js\";\n// b\"base_nonce\"\n// deno-fmt-ignore\nconst LABEL_BASE_NONCE = new Uint8Array([\n    98, 97, 115, 101, 95, 110, 111, 110, 99, 101,\n]);\n// b\"exp\"\nconst LABEL_EXP = new Uint8Array([101, 120, 112]);\n// b\"info_hash\"\n// deno-fmt-ignore\nconst LABEL_INFO_HASH = new Uint8Array([\n    105, 110, 102, 111, 95, 104, 97, 115, 104,\n]);\n// b\"key\"\nconst LABEL_KEY = new Uint8Array([107, 101, 121]);\n// b\"psk_id_hash\"\n// deno-fmt-ignore\nconst LABEL_PSK_ID_HASH = new Uint8Array([\n    112, 115, 107, 95, 105, 100, 95, 104, 97, 115, 104,\n]);\n// b\"secret\"\nconst LABEL_SECRET = new Uint8Array([115, 101, 99, 114, 101, 116]);\n// b\"HPKE\"\n// deno-fmt-ignore\nconst SUITE_ID_HEADER_HPKE = new Uint8Array([\n    72, 80, 75, 69, 0, 0, 0, 0, 0, 0,\n]);\n/**\n * The Hybrid Public Key Encryption (HPKE) ciphersuite,\n * which is implemented using only\n * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.\n *\n * This is the super class of {@link CipherSuite} and the same as\n * {@link https://deno.land/x/hpke/core/mod.ts?s=CipherSuite | @hpke/core#CipherSuite },\n * which supports only the ciphersuites that can be implemented on the native\n * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.\n * Therefore, the following cryptographic algorithms are not supported for now:\n *   - DHKEM(X25519, HKDF-SHA256)\n *   - DHKEM(X448, HKDF-SHA512)\n *   - ChaCha20Poly1305\n *\n * In addtion, the HKDF functions contained in this class can only derive\n * keys of the same length as the `hashSize`.\n *\n * If you want to use the unsupported cryptographic algorithms\n * above or derive keys longer than the `hashSize`,\n * please use {@link CipherSuite}.\n *\n * This class provides following functions:\n *\n * - Creates encryption contexts both for senders and recipients.\n *   - {@link createSenderContext}\n *   - {@link createRecipientContext}\n * - Provides single-shot encryption API.\n *   - {@link seal}\n *   - {@link open}\n *\n * The calling of the constructor of this class is the starting\n * point for HPKE operations for both senders and recipients.\n *\n * @example Use only ciphersuites supported by Web Cryptography API.\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n *   CipherSuite,\n * } from \"http://deno.land/x/hpke/mod.ts\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n *\n * @example Use a ciphersuite which is currently not supported by Web Cryptography API.\n *\n * ```ts\n * import { Aes128Gcm, HkdfSha256, CipherSuite } from \"http://deno.land/x/hpke/mod.ts\";\n * // Use an extension module.\n * import { DhkemX25519HkdfSha256 } from \"https://deno.land/x/hpke/x/dhkem-x25519/mod.ts\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemX25519HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class CipherSuiteNative extends NativeAlgorithm {\n    /**\n     * @param params A set of parameters for building a cipher suite.\n     *\n     * If the error occurred, throws {@link InvalidParamError}.\n     *\n     * @throws {@link InvalidParamError}\n     */\n    constructor(params) {\n        super();\n        Object.defineProperty(this, \"_kem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_kdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_aead\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_suiteId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // KEM\n        if (typeof params.kem === \"number\") {\n            throw new InvalidParamError(\"KemId cannot be used\");\n        }\n        this._kem = params.kem;\n        // KDF\n        if (typeof params.kdf === \"number\") {\n            throw new InvalidParamError(\"KdfId cannot be used\");\n        }\n        this._kdf = params.kdf;\n        // AEAD\n        if (typeof params.aead === \"number\") {\n            throw new InvalidParamError(\"AeadId cannot be used\");\n        }\n        this._aead = params.aead;\n        this._suiteId = new Uint8Array(SUITE_ID_HEADER_HPKE);\n        this._suiteId.set(i2Osp(this._kem.id, 2), 4);\n        this._suiteId.set(i2Osp(this._kdf.id, 2), 6);\n        this._suiteId.set(i2Osp(this._aead.id, 2), 8);\n        this._kdf.init(this._suiteId);\n    }\n    /**\n     * Gets the KEM context of the ciphersuite.\n     */\n    get kem() {\n        return this._kem;\n    }\n    /**\n     * Gets the KDF context of the ciphersuite.\n     */\n    get kdf() {\n        return this._kdf;\n    }\n    /**\n     * Gets the AEAD context of the ciphersuite.\n     */\n    get aead() {\n        return this._aead;\n    }\n    /**\n     * Creates an encryption context for a sender.\n     *\n     * If the error occurred, throws {@link DecapError} | {@link ValidationError}.\n     *\n     * @param params A set of parameters for the sender encryption context.\n     * @returns A sender encryption context.\n     * @throws {@link EncapError}, {@link ValidationError}\n     */\n    async createSenderContext(params) {\n        this._validateInputLength(params);\n        await this._setup();\n        const dh = await this._kem.encap(params);\n        let mode;\n        if (params.psk !== undefined) {\n            mode = params.senderKey !== undefined ? Mode.AuthPsk : Mode.Psk;\n        }\n        else {\n            mode = params.senderKey !== undefined ? Mode.Auth : Mode.Base;\n        }\n        return await this._keyScheduleS(mode, dh.sharedSecret, dh.enc, params);\n    }\n    /**\n     * Creates an encryption context for a recipient.\n     *\n     * If the error occurred, throws {@link DecapError}\n     * | {@link DeserializeError} | {@link ValidationError}.\n     *\n     * @param params A set of parameters for the recipient encryption context.\n     * @returns A recipient encryption context.\n     * @throws {@link DecapError}, {@link DeserializeError}, {@link ValidationError}\n     */\n    async createRecipientContext(params) {\n        this._validateInputLength(params);\n        await this._setup();\n        const sharedSecret = await this._kem.decap(params);\n        let mode;\n        if (params.psk !== undefined) {\n            mode = params.senderPublicKey !== undefined ? Mode.AuthPsk : Mode.Psk;\n        }\n        else {\n            mode = params.senderPublicKey !== undefined ? Mode.Auth : Mode.Base;\n        }\n        return await this._keyScheduleR(mode, sharedSecret, params);\n    }\n    /**\n     * Encrypts a message to a recipient.\n     *\n     * If the error occurred, throws `EncapError` | `MessageLimitReachedError` | `SealError` | `ValidationError`.\n     *\n     * @param params A set of parameters for building a sender encryption context.\n     * @param pt A plain text as bytes to be encrypted.\n     * @param aad Additional authenticated data as bytes fed by an application.\n     * @returns A cipher text and an encapsulated key as bytes.\n     * @throws {@link EncapError}, {@link MessageLimitReachedError}, {@link SealError}, {@link ValidationError}\n     */\n    async seal(params, pt, aad = EMPTY) {\n        const ctx = await this.createSenderContext(params);\n        return {\n            ct: await ctx.seal(pt, aad),\n            enc: ctx.enc,\n        };\n    }\n    /**\n     * Decrypts a message from a sender.\n     *\n     * If the error occurred, throws `DecapError` | `DeserializeError` | `OpenError` | `ValidationError`.\n     *\n     * @param params A set of parameters for building a recipient encryption context.\n     * @param ct An encrypted text as bytes to be decrypted.\n     * @param aad Additional authenticated data as bytes fed by an application.\n     * @returns A decrypted plain text as bytes.\n     * @throws {@link DecapError}, {@link DeserializeError}, {@link OpenError}, {@link ValidationError}\n     */\n    async open(params, ct, aad = EMPTY) {\n        const ctx = await this.createRecipientContext(params);\n        return await ctx.open(ct, aad);\n    }\n    // private verifyPskInputs(mode: Mode, params: KeyScheduleParams) {\n    //   const gotPsk = (params.psk !== undefined);\n    //   const gotPskId = (params.psk !== undefined && params.psk.id.byteLength > 0);\n    //   if (gotPsk !== gotPskId) {\n    //     throw new Error('Inconsistent PSK inputs');\n    //   }\n    //   if (gotPsk && (mode === Mode.Base || mode === Mode.Auth)) {\n    //     throw new Error('PSK input provided when not needed');\n    //   }\n    //   if (!gotPsk && (mode === Mode.Psk || mode === Mode.AuthPsk)) {\n    //     throw new Error('Missing required PSK input');\n    //   }\n    //   return;\n    // }\n    async _keySchedule(mode, sharedSecret, params) {\n        // Currently, there is no point in executing this function\n        // because this hpke library does not allow users to explicitly specify the mode.\n        //\n        // this.verifyPskInputs(mode, params);\n        const pskId = params.psk === undefined\n            ? EMPTY\n            : new Uint8Array(params.psk.id);\n        const pskIdHash = await this._kdf.labeledExtract(EMPTY, LABEL_PSK_ID_HASH, pskId);\n        const info = params.info === undefined\n            ? EMPTY\n            : new Uint8Array(params.info);\n        const infoHash = await this._kdf.labeledExtract(EMPTY, LABEL_INFO_HASH, info);\n        const keyScheduleContext = new Uint8Array(1 + pskIdHash.byteLength + infoHash.byteLength);\n        keyScheduleContext.set(new Uint8Array([mode]), 0);\n        keyScheduleContext.set(new Uint8Array(pskIdHash), 1);\n        keyScheduleContext.set(new Uint8Array(infoHash), 1 + pskIdHash.byteLength);\n        const psk = params.psk === undefined\n            ? EMPTY\n            : new Uint8Array(params.psk.key);\n        const ikm = this._kdf.buildLabeledIkm(LABEL_SECRET, psk);\n        const exporterSecretInfo = this._kdf.buildLabeledInfo(LABEL_EXP, keyScheduleContext, this._kdf.hashSize);\n        const exporterSecret = await this._kdf.extractAndExpand(sharedSecret, ikm, exporterSecretInfo, this._kdf.hashSize);\n        if (this._aead.id === AeadId.ExportOnly) {\n            return { aead: this._aead, exporterSecret: exporterSecret };\n        }\n        const keyInfo = this._kdf.buildLabeledInfo(LABEL_KEY, keyScheduleContext, this._aead.keySize);\n        const key = await this._kdf.extractAndExpand(sharedSecret, ikm, keyInfo, this._aead.keySize);\n        const baseNonceInfo = this._kdf.buildLabeledInfo(LABEL_BASE_NONCE, keyScheduleContext, this._aead.nonceSize);\n        const baseNonce = await this._kdf.extractAndExpand(sharedSecret, ikm, baseNonceInfo, this._aead.nonceSize);\n        return {\n            aead: this._aead,\n            exporterSecret: exporterSecret,\n            key: key,\n            baseNonce: new Uint8Array(baseNonce),\n            seq: 0,\n        };\n    }\n    async _keyScheduleS(mode, sharedSecret, enc, params) {\n        const res = await this._keySchedule(mode, sharedSecret, params);\n        if (res.key === undefined) {\n            return new SenderExporterContextImpl(this._api, this._kdf, res.exporterSecret, enc);\n        }\n        return new SenderContextImpl(this._api, this._kdf, res, enc);\n    }\n    async _keyScheduleR(mode, sharedSecret, params) {\n        const res = await this._keySchedule(mode, sharedSecret, params);\n        if (res.key === undefined) {\n            return new RecipientExporterContextImpl(this._api, this._kdf, res.exporterSecret);\n        }\n        return new RecipientContextImpl(this._api, this._kdf, res);\n    }\n    _validateInputLength(params) {\n        if (params.info !== undefined &&\n            params.info.byteLength > INPUT_LENGTH_LIMIT) {\n            throw new InvalidParamError(\"Too long info\");\n        }\n        if (params.psk !== undefined) {\n            if (params.psk.key.byteLength < MINIMUM_PSK_LENGTH) {\n                throw new InvalidParamError(`PSK must have at least ${MINIMUM_PSK_LENGTH} bytes`);\n            }\n            if (params.psk.key.byteLength > INPUT_LENGTH_LIMIT) {\n                throw new InvalidParamError(\"Too long psk.key\");\n            }\n            if (params.psk.id.byteLength > INPUT_LENGTH_LIMIT) {\n                throw new InvalidParamError(\"Too long psk.id\");\n            }\n        }\n        return;\n    }\n}\n","// The input length limit (psk, psk_id, info, exporter_context, ikm).\nexport const INPUT_LENGTH_LIMIT = 8192;\n// The minimum length of a PSK.\nexport const MINIMUM_PSK_LENGTH = 32;\n// b\"\"\nexport const EMPTY = new Uint8Array(0);\n","import { MessageLimitReachedError } from \"./errors.js\";\nimport { ExporterContextImpl } from \"./exporterContext.js\";\nimport { i2Osp } from \"./utils/misc.js\";\nexport function xor(a, b) {\n    if (a.byteLength !== b.byteLength) {\n        throw new Error(\"xor: different length inputs\");\n    }\n    const buf = new Uint8Array(a.byteLength);\n    for (let i = 0; i < a.byteLength; i++) {\n        buf[i] = a[i] ^ b[i];\n    }\n    return buf;\n}\nexport class EncryptionContextImpl extends ExporterContextImpl {\n    constructor(api, kdf, params) {\n        super(api, kdf, params.exporterSecret);\n        // AEAD id.\n        Object.defineProperty(this, \"_aead\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The length in bytes of a key for the algorithm.\n        Object.defineProperty(this, \"_nK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The length in bytes of a nonce for the algorithm.\n        Object.defineProperty(this, \"_nN\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The length in bytes of an authentication tag for the algorithm.\n        Object.defineProperty(this, \"_nT\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The end-to-end encryption key information.\n        Object.defineProperty(this, \"_ctx\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (params.key === undefined || params.baseNonce === undefined ||\n            params.seq === undefined) {\n            throw new Error(\"Required parameters are missing\");\n        }\n        this._aead = params.aead;\n        this._nK = this._aead.keySize;\n        this._nN = this._aead.nonceSize;\n        this._nT = this._aead.tagSize;\n        const key = this._aead.createEncryptionContext(params.key);\n        this._ctx = {\n            key: key,\n            baseNonce: params.baseNonce,\n            seq: params.seq,\n        };\n    }\n    computeNonce(k) {\n        const seqBytes = i2Osp(k.seq, k.baseNonce.byteLength);\n        return xor(k.baseNonce, seqBytes);\n    }\n    incrementSeq(k) {\n        // if (this.seq >= (1 << (8 * this.baseNonce.byteLength)) - 1) {\n        if (k.seq > Number.MAX_SAFE_INTEGER) {\n            throw new MessageLimitReachedError(\"Message limit reached\");\n        }\n        k.seq += 1;\n        return;\n    }\n}\n","/**\n * The base error class of hpke-js.\n */\nexport class BaseError extends Error {\n    constructor(e) {\n        let message;\n        if (e instanceof Error) {\n            message = e.message;\n        }\n        else if (typeof e === \"string\") {\n            message = e;\n        }\n        else {\n            message = \"\";\n        }\n        super(message);\n        this.name = this.constructor.name;\n    }\n}\n/**\n * The base error class of hpke-js.\n */\nexport class HpkeError extends BaseError {\n}\n/**\n * Invalid parameter.\n */\nexport class InvalidParamError extends HpkeError {\n}\n/**\n * KEM input or output validation failure.\n */\nexport class ValidationError extends HpkeError {\n}\n/**\n * Public or private key serialization failure.\n */\nexport class SerializeError extends HpkeError {\n}\n/**\n * Public or private key deserialization failure.\n */\nexport class DeserializeError extends HpkeError {\n}\n/**\n * encap() failure.\n */\nexport class EncapError extends HpkeError {\n}\n/**\n * decap() failure.\n */\nexport class DecapError extends HpkeError {\n}\n/**\n * Secret export failure.\n */\nexport class ExportError extends HpkeError {\n}\n/**\n * seal() failure.\n */\nexport class SealError extends HpkeError {\n}\n/**\n * open() failure.\n */\nexport class OpenError extends HpkeError {\n}\n/**\n * Sequence number overflow on the encryption context.\n */\nexport class MessageLimitReachedError extends HpkeError {\n}\n/**\n * Key pair derivation failure.\n */\nexport class DeriveKeyPairError extends HpkeError {\n}\n/**\n * Not supported failure.\n */\nexport class NotSupportedError extends HpkeError {\n}\n","import { INPUT_LENGTH_LIMIT } from \"./consts.js\";\nimport { ExportError, InvalidParamError } from \"./errors.js\";\nimport { emitNotSupported } from \"./utils/emitNotSupported.js\";\n// b\"sec\"\nconst LABEL_SEC = new Uint8Array([115, 101, 99]);\nexport class ExporterContextImpl {\n    constructor(api, kdf, exporterSecret) {\n        Object.defineProperty(this, \"_api\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"exporterSecret\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_kdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._api = api;\n        this._kdf = kdf;\n        this.exporterSecret = exporterSecret;\n    }\n    async seal(_data, _aad) {\n        return await emitNotSupported();\n    }\n    async open(_data, _aad) {\n        return await emitNotSupported();\n    }\n    async export(exporterContext, len) {\n        if (exporterContext.byteLength > INPUT_LENGTH_LIMIT) {\n            throw new InvalidParamError(\"Too long exporter context\");\n        }\n        try {\n            return await this._kdf.labeledExpand(this.exporterSecret, LABEL_SEC, new Uint8Array(exporterContext), len);\n        }\n        catch (e) {\n            throw new ExportError(e);\n        }\n    }\n}\nexport class RecipientExporterContextImpl extends ExporterContextImpl {\n}\nexport class SenderExporterContextImpl extends ExporterContextImpl {\n    constructor(api, kdf, exporterSecret, enc) {\n        super(api, kdf, exporterSecret);\n        Object.defineProperty(this, \"enc\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.enc = enc;\n        return;\n    }\n}\n","/**\n * The supported HPKE modes.\n */\nexport const Mode = {\n    Base: 0x00,\n    Psk: 0x01,\n    Auth: 0x02,\n    AuthPsk: 0x03,\n};\n/**\n * The supported Key Encapsulation Mechanism (KEM) identifiers.\n *\n * @deprecated Use {@link KdfId} instead.\n */\nexport const Kem = {\n    NotAssigned: 0x0000,\n    DhkemP256HkdfSha256: 0x0010,\n    DhkemP384HkdfSha384: 0x0011,\n    DhkemP521HkdfSha512: 0x0012,\n    DhkemSecp256k1HkdfSha256: 0x0013,\n    DhkemX25519HkdfSha256: 0x0020,\n    DhkemX448HkdfSha512: 0x0021,\n    HybridkemX25519Kyber768: 0x0030,\n};\n/**\n * The supported Key Encapsulation Mechanism (KEM) identifiers.\n */\nexport const KemId = Kem;\n/**\n * The supported Key Derivation Function (KDF) identifiers.\n *\n * @deprecated Use {@link KdfId} instead.\n */\nexport const Kdf = {\n    HkdfSha256: 0x0001,\n    HkdfSha384: 0x0002,\n    HkdfSha512: 0x0003,\n};\n/**\n * The supported Key Derivation Function (KDF) identifiers.\n */\nexport const KdfId = Kdf;\n/**\n * The supported Authenticated Encryption with Associated Data (AEAD) identifiers.\n *\n * @deprecated Use {@link AeadId} instead.\n */\nexport const Aead = {\n    Aes128Gcm: 0x0001,\n    Aes256Gcm: 0x0002,\n    Chacha20Poly1305: 0x0003,\n    ExportOnly: 0xFFFF,\n};\n/**\n * The supported Authenticated Encryption with Associated Data (AEAD) identifiers.\n */\nexport const AeadId = Aead;\n","// The key usages for AEAD.\nexport const AEAD_USAGES = [\"encrypt\", \"decrypt\"];\n","// The key usages for KEM.\nexport const KEM_USAGES = [\"deriveBits\"];\n// b\"dkp_prk\"\nexport const LABEL_DKP_PRK = new Uint8Array([100, 107, 112, 95, 112, 114, 107]);\n// b\"sk\"\nexport const LABEL_SK = new Uint8Array([115, 107]);\n","// b\"KEM\"\nexport const SUITE_ID_HEADER_KEM = new Uint8Array([75, 69, 77, 0, 0]);\n","import { NativeAlgorithm } from \"../algorithm.js\";\nimport { EMPTY } from \"../consts.js\";\nimport { InvalidParamError } from \"../errors.js\";\nimport { KdfId } from \"../identifiers.js\";\n// b\"HPKE-v1\"\nconst HPKE_VERSION = new Uint8Array([72, 80, 75, 69, 45, 118, 49]);\nexport class HkdfNative extends NativeAlgorithm {\n    constructor() {\n        super();\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KdfId.HkdfSha256\n        });\n        Object.defineProperty(this, \"hashSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"_suiteId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: EMPTY\n        });\n        Object.defineProperty(this, \"algHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                name: \"HMAC\",\n                hash: \"SHA-256\",\n                length: 256,\n            }\n        });\n    }\n    init(suiteId) {\n        this._suiteId = suiteId;\n    }\n    buildLabeledIkm(label, ikm) {\n        this._checkInit();\n        const ret = new Uint8Array(7 + this._suiteId.byteLength + label.byteLength + ikm.byteLength);\n        ret.set(HPKE_VERSION, 0);\n        ret.set(this._suiteId, 7);\n        ret.set(label, 7 + this._suiteId.byteLength);\n        ret.set(ikm, 7 + this._suiteId.byteLength + label.byteLength);\n        return ret;\n    }\n    buildLabeledInfo(label, info, len) {\n        this._checkInit();\n        const ret = new Uint8Array(9 + this._suiteId.byteLength + label.byteLength + info.byteLength);\n        ret.set(new Uint8Array([0, len]), 0);\n        ret.set(HPKE_VERSION, 2);\n        ret.set(this._suiteId, 9);\n        ret.set(label, 9 + this._suiteId.byteLength);\n        ret.set(info, 9 + this._suiteId.byteLength + label.byteLength);\n        return ret;\n    }\n    async extract(salt, ikm) {\n        await this._setup();\n        if (salt.byteLength === 0) {\n            salt = new ArrayBuffer(this.hashSize);\n        }\n        if (salt.byteLength !== this.hashSize) {\n            throw new InvalidParamError(\"The salt length must be the same as the hashSize\");\n        }\n        const key = await this._api.importKey(\"raw\", salt, this.algHash, false, [\n            \"sign\",\n        ]);\n        return await this._api.sign(\"HMAC\", key, ikm);\n    }\n    async expand(prk, info, len) {\n        await this._setup();\n        const key = await this._api.importKey(\"raw\", prk, this.algHash, false, [\n            \"sign\",\n        ]);\n        const okm = new ArrayBuffer(len);\n        const p = new Uint8Array(okm);\n        let prev = EMPTY;\n        const mid = new Uint8Array(info);\n        const tail = new Uint8Array(1);\n        if (len > 255 * this.hashSize) {\n            throw new Error(\"Entropy limit reached\");\n        }\n        const tmp = new Uint8Array(this.hashSize + mid.length + 1);\n        for (let i = 1, cur = 0; cur < p.length; i++) {\n            tail[0] = i;\n            tmp.set(prev, 0);\n            tmp.set(mid, prev.length);\n            tmp.set(tail, prev.length + mid.length);\n            prev = new Uint8Array(await this._api.sign(\"HMAC\", key, tmp.slice(0, prev.length + mid.length + 1)));\n            if (p.length - cur >= prev.length) {\n                p.set(prev, cur);\n                cur += prev.length;\n            }\n            else {\n                p.set(prev.slice(0, p.length - cur), cur);\n                cur += p.length - cur;\n            }\n        }\n        return okm;\n    }\n    async extractAndExpand(salt, ikm, info, len) {\n        await this._setup();\n        const baseKey = await this._api.importKey(\"raw\", ikm, \"HKDF\", false, [\"deriveBits\"]);\n        return await this._api.deriveBits({\n            name: \"HKDF\",\n            hash: this.algHash.hash,\n            salt: salt,\n            info: info,\n        }, baseKey, len * 8);\n    }\n    async labeledExtract(salt, label, ikm) {\n        return await this.extract(salt, this.buildLabeledIkm(label, ikm));\n    }\n    async labeledExpand(prk, label, info, len) {\n        return await this.expand(prk, this.buildLabeledInfo(label, info, len), len);\n    }\n    _checkInit() {\n        if (this._suiteId === EMPTY) {\n            throw new Error(\"Not initialized. Call init()\");\n        }\n    }\n}\nexport class HkdfSha256Native extends HkdfNative {\n    constructor() {\n        super(...arguments);\n        /** KdfId.HkdfSha256 (0x0001) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KdfId.HkdfSha256\n        });\n        /** 32 */\n        Object.defineProperty(this, \"hashSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 32\n        });\n        /** The parameters for Web Cryptography API */\n        Object.defineProperty(this, \"algHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                name: \"HMAC\",\n                hash: \"SHA-256\",\n                length: 256,\n            }\n        });\n    }\n}\nexport class HkdfSha384Native extends HkdfNative {\n    constructor() {\n        super(...arguments);\n        /** KdfId.HkdfSha384 (0x0002) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KdfId.HkdfSha384\n        });\n        /** 48 */\n        Object.defineProperty(this, \"hashSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 48\n        });\n        /** The parameters for Web Cryptography API */\n        Object.defineProperty(this, \"algHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                name: \"HMAC\",\n                hash: \"SHA-384\",\n                length: 384,\n            }\n        });\n    }\n}\nexport class HkdfSha512Native extends HkdfNative {\n    constructor() {\n        super(...arguments);\n        /** KdfId.HkdfSha512 (0x0003) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KdfId.HkdfSha512\n        });\n        /** 64 */\n        Object.defineProperty(this, \"hashSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 64\n        });\n        /** The parameters for Web Cryptography API */\n        Object.defineProperty(this, \"algHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                name: \"HMAC\",\n                hash: \"SHA-512\",\n                length: 512,\n            }\n        });\n    }\n}\n","import { EMPTY, INPUT_LENGTH_LIMIT } from \"../consts.js\";\nimport { DecapError, EncapError, InvalidParamError } from \"../errors.js\";\nimport { SUITE_ID_HEADER_KEM } from \"../interfaces/kemInterface.js\";\nimport { concat, i2Osp, isCryptoKeyPair } from \"../utils/misc.js\";\n// b\"eae_prk\"\nconst LABEL_EAE_PRK = new Uint8Array([101, 97, 101, 95, 112, 114, 107]);\n// b\"shared_secret\"\n// deno-fmt-ignore\nconst LABEL_SHARED_SECRET = new Uint8Array([\n    115, 104, 97, 114, 101, 100, 95, 115, 101, 99,\n    114, 101, 116,\n]);\nfunction concat3(a, b, c) {\n    const ret = new Uint8Array(a.length + b.length + c.length);\n    ret.set(a, 0);\n    ret.set(b, a.length);\n    ret.set(c, a.length + b.length);\n    return ret;\n}\nexport class Dhkem {\n    constructor(id, prim, kdf) {\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"secretSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"encSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"publicKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"privateKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"_prim\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_kdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.id = id;\n        this._prim = prim;\n        this._kdf = kdf;\n        const suiteId = new Uint8Array(SUITE_ID_HEADER_KEM);\n        suiteId.set(i2Osp(this.id, 2), 3);\n        this._kdf.init(suiteId);\n    }\n    async serializePublicKey(key) {\n        return await this._prim.serializePublicKey(key);\n    }\n    async deserializePublicKey(key) {\n        return await this._prim.deserializePublicKey(key);\n    }\n    async serializePrivateKey(key) {\n        return await this._prim.serializePrivateKey(key);\n    }\n    async deserializePrivateKey(key) {\n        return await this._prim.deserializePrivateKey(key);\n    }\n    async importKey(format, key, isPublic = true) {\n        return await this._prim.importKey(format, key, isPublic);\n    }\n    async generateKeyPair() {\n        return await this._prim.generateKeyPair();\n    }\n    async deriveKeyPair(ikm) {\n        if (ikm.byteLength > INPUT_LENGTH_LIMIT) {\n            throw new InvalidParamError(\"Too long ikm\");\n        }\n        return await this._prim.deriveKeyPair(ikm);\n    }\n    async encap(params) {\n        let ke;\n        if (params.ekm === undefined) {\n            ke = await this.generateKeyPair();\n        }\n        else if (isCryptoKeyPair(params.ekm)) {\n            // params.ekm is only used for testing.\n            ke = params.ekm;\n        }\n        else {\n            // params.ekm is only used for testing.\n            ke = await this.deriveKeyPair(params.ekm);\n        }\n        const enc = await this._prim.serializePublicKey(ke.publicKey);\n        const pkrm = await this._prim.serializePublicKey(params.recipientPublicKey);\n        try {\n            let dh;\n            if (params.senderKey === undefined) {\n                dh = new Uint8Array(await this._prim.dh(ke.privateKey, params.recipientPublicKey));\n            }\n            else {\n                const sks = isCryptoKeyPair(params.senderKey)\n                    ? params.senderKey.privateKey\n                    : params.senderKey;\n                const dh1 = new Uint8Array(await this._prim.dh(ke.privateKey, params.recipientPublicKey));\n                const dh2 = new Uint8Array(await this._prim.dh(sks, params.recipientPublicKey));\n                dh = concat(dh1, dh2);\n            }\n            let kemContext;\n            if (params.senderKey === undefined) {\n                kemContext = concat(new Uint8Array(enc), new Uint8Array(pkrm));\n            }\n            else {\n                const pks = isCryptoKeyPair(params.senderKey)\n                    ? params.senderKey.publicKey\n                    : await this._prim.derivePublicKey(params.senderKey);\n                const pksm = await this._prim.serializePublicKey(pks);\n                kemContext = concat3(new Uint8Array(enc), new Uint8Array(pkrm), new Uint8Array(pksm));\n            }\n            const sharedSecret = await this._generateSharedSecret(dh, kemContext);\n            return {\n                enc: enc,\n                sharedSecret: sharedSecret,\n            };\n        }\n        catch (e) {\n            throw new EncapError(e);\n        }\n    }\n    async decap(params) {\n        const pke = await this._prim.deserializePublicKey(params.enc);\n        const skr = isCryptoKeyPair(params.recipientKey)\n            ? params.recipientKey.privateKey\n            : params.recipientKey;\n        const pkr = isCryptoKeyPair(params.recipientKey)\n            ? params.recipientKey.publicKey\n            : await this._prim.derivePublicKey(params.recipientKey);\n        const pkrm = await this._prim.serializePublicKey(pkr);\n        try {\n            let dh;\n            if (params.senderPublicKey === undefined) {\n                dh = new Uint8Array(await this._prim.dh(skr, pke));\n            }\n            else {\n                const dh1 = new Uint8Array(await this._prim.dh(skr, pke));\n                const dh2 = new Uint8Array(await this._prim.dh(skr, params.senderPublicKey));\n                dh = concat(dh1, dh2);\n            }\n            let kemContext;\n            if (params.senderPublicKey === undefined) {\n                kemContext = concat(new Uint8Array(params.enc), new Uint8Array(pkrm));\n            }\n            else {\n                const pksm = await this._prim.serializePublicKey(params.senderPublicKey);\n                kemContext = new Uint8Array(params.enc.byteLength + pkrm.byteLength + pksm.byteLength);\n                kemContext.set(new Uint8Array(params.enc), 0);\n                kemContext.set(new Uint8Array(pkrm), params.enc.byteLength);\n                kemContext.set(new Uint8Array(pksm), params.enc.byteLength + pkrm.byteLength);\n            }\n            return await this._generateSharedSecret(dh, kemContext);\n        }\n        catch (e) {\n            throw new DecapError(e);\n        }\n    }\n    async _generateSharedSecret(dh, kemContext) {\n        const labeledIkm = this._kdf.buildLabeledIkm(LABEL_EAE_PRK, dh);\n        const labeledInfo = this._kdf.buildLabeledInfo(LABEL_SHARED_SECRET, kemContext, this.secretSize);\n        return await this._kdf.extractAndExpand(EMPTY, labeledIkm, labeledInfo, this.secretSize);\n    }\n}\n","import { KemId } from \"../identifiers.js\";\nimport { HkdfSha256Native, HkdfSha384Native, HkdfSha512Native, } from \"../kdfs/hkdf.js\";\nimport { Dhkem } from \"./dhkem.js\";\nimport { Ec } from \"./dhkemPrimitives/ec.js\";\nexport class DhkemP256HkdfSha256Native extends Dhkem {\n    constructor() {\n        const kdf = new HkdfSha256Native();\n        const prim = new Ec(KemId.DhkemP256HkdfSha256, kdf);\n        super(KemId.DhkemP256HkdfSha256, prim, kdf);\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KemId.DhkemP256HkdfSha256\n        });\n        Object.defineProperty(this, \"secretSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 32\n        });\n        Object.defineProperty(this, \"encSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 65\n        });\n        Object.defineProperty(this, \"publicKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 65\n        });\n        Object.defineProperty(this, \"privateKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 32\n        });\n    }\n}\nexport class DhkemP384HkdfSha384Native extends Dhkem {\n    constructor() {\n        const kdf = new HkdfSha384Native();\n        const prim = new Ec(KemId.DhkemP384HkdfSha384, kdf);\n        super(KemId.DhkemP384HkdfSha384, prim, kdf);\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KemId.DhkemP384HkdfSha384\n        });\n        Object.defineProperty(this, \"secretSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 48\n        });\n        Object.defineProperty(this, \"encSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 97\n        });\n        Object.defineProperty(this, \"publicKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 97\n        });\n        Object.defineProperty(this, \"privateKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 48\n        });\n    }\n}\nexport class DhkemP521HkdfSha512Native extends Dhkem {\n    constructor() {\n        const kdf = new HkdfSha512Native();\n        const prim = new Ec(KemId.DhkemP521HkdfSha512, kdf);\n        super(KemId.DhkemP521HkdfSha512, prim, kdf);\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KemId.DhkemP521HkdfSha512\n        });\n        Object.defineProperty(this, \"secretSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 64\n        });\n        Object.defineProperty(this, \"encSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 133\n        });\n        Object.defineProperty(this, \"publicKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 133\n        });\n        Object.defineProperty(this, \"privateKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 64\n        });\n    }\n}\n","import { NativeAlgorithm } from \"../../algorithm.js\";\nimport { EMPTY } from \"../../consts.js\";\nimport { DeriveKeyPairError, DeserializeError, NotSupportedError, SerializeError, } from \"../../errors.js\";\nimport { KemId } from \"../../identifiers.js\";\nimport { KEM_USAGES, LABEL_DKP_PRK } from \"../../interfaces/dhkemPrimitives.js\";\nimport { Bignum } from \"../../utils/bignum.js\";\nimport { base64UrlToBytes, i2Osp } from \"../../utils/misc.js\";\n// b\"candidate\"\n// deno-fmt-ignore\nconst LABEL_CANDIDATE = new Uint8Array([\n    99, 97, 110, 100, 105, 100, 97, 116, 101,\n]);\n// the order of the curve being used.\n// deno-fmt-ignore\nconst ORDER_P_256 = new Uint8Array([\n    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84,\n    0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51,\n]);\n// deno-fmt-ignore\nconst ORDER_P_384 = new Uint8Array([\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,\n    0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a,\n    0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73,\n]);\n// deno-fmt-ignore\nconst ORDER_P_521 = new Uint8Array([\n    0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xfa, 0x51, 0x86, 0x87, 0x83, 0xbf, 0x2f,\n    0x96, 0x6b, 0x7f, 0xcc, 0x01, 0x48, 0xf7, 0x09,\n    0xa5, 0xd0, 0x3b, 0xb5, 0xc9, 0xb8, 0x89, 0x9c,\n    0x47, 0xae, 0xbb, 0x6f, 0xb7, 0x1e, 0x91, 0x38,\n    0x64, 0x09,\n]);\n// deno-fmt-ignore\nconst PKCS8_ALG_ID_P_256 = new Uint8Array([\n    48, 65, 2, 1, 0, 48, 19, 6, 7, 42,\n    134, 72, 206, 61, 2, 1, 6, 8, 42, 134,\n    72, 206, 61, 3, 1, 7, 4, 39, 48, 37,\n    2, 1, 1, 4, 32,\n]);\n// deno-fmt-ignore\nconst PKCS8_ALG_ID_P_384 = new Uint8Array([\n    48, 78, 2, 1, 0, 48, 16, 6, 7, 42,\n    134, 72, 206, 61, 2, 1, 6, 5, 43, 129,\n    4, 0, 34, 4, 55, 48, 53, 2, 1, 1,\n    4, 48,\n]);\n// deno-fmt-ignore\nconst PKCS8_ALG_ID_P_521 = new Uint8Array([\n    48, 96, 2, 1, 0, 48, 16, 6, 7, 42,\n    134, 72, 206, 61, 2, 1, 6, 5, 43, 129,\n    4, 0, 35, 4, 73, 48, 71, 2, 1, 1,\n    4, 66,\n]);\nexport class Ec extends NativeAlgorithm {\n    constructor(kem, hkdf) {\n        super();\n        Object.defineProperty(this, \"_hkdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_alg\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nPk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nSk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nDh\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // EC specific arguments for deriving key pair.\n        Object.defineProperty(this, \"_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_bitmask\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pkcs8AlgId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._hkdf = hkdf;\n        switch (kem) {\n            case KemId.DhkemP256HkdfSha256:\n                this._alg = { name: \"ECDH\", namedCurve: \"P-256\" };\n                this._nPk = 65;\n                this._nSk = 32;\n                this._nDh = 32;\n                this._order = ORDER_P_256;\n                this._bitmask = 0xFF;\n                this._pkcs8AlgId = PKCS8_ALG_ID_P_256;\n                break;\n            case KemId.DhkemP384HkdfSha384:\n                this._alg = { name: \"ECDH\", namedCurve: \"P-384\" };\n                this._nPk = 97;\n                this._nSk = 48;\n                this._nDh = 48;\n                this._order = ORDER_P_384;\n                this._bitmask = 0xFF;\n                this._pkcs8AlgId = PKCS8_ALG_ID_P_384;\n                break;\n            default:\n                // case KemId.DhkemP521HkdfSha512:\n                this._alg = { name: \"ECDH\", namedCurve: \"P-521\" };\n                this._nPk = 133;\n                this._nSk = 66;\n                this._nDh = 66;\n                this._order = ORDER_P_521;\n                this._bitmask = 0x01;\n                this._pkcs8AlgId = PKCS8_ALG_ID_P_521;\n                break;\n        }\n    }\n    async serializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._api.exportKey(\"raw\", key);\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, true);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async serializePrivateKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            if (!(\"d\" in jwk)) {\n                throw new Error(\"Not private key\");\n            }\n            return base64UrlToBytes(jwk[\"d\"]);\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePrivateKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, false);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async importKey(format, key, isPublic) {\n        await this._setup();\n        try {\n            if (format === \"raw\") {\n                return await this._importRawKey(key, isPublic);\n            }\n            // jwk\n            if (key instanceof ArrayBuffer) {\n                throw new Error(\"Invalid jwk key format\");\n            }\n            return await this._importJWK(key, isPublic);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async generateKeyPair() {\n        await this._setup();\n        try {\n            return await this._api.generateKey(this._alg, true, KEM_USAGES);\n        }\n        catch (e) {\n            throw new NotSupportedError(e);\n        }\n    }\n    async deriveKeyPair(ikm) {\n        await this._setup();\n        try {\n            const dkpPrk = await this._hkdf.labeledExtract(EMPTY, LABEL_DKP_PRK, new Uint8Array(ikm));\n            const bn = new Bignum(this._nSk);\n            for (let counter = 0; bn.isZero() || !bn.lessThan(this._order); counter++) {\n                if (counter > 255) {\n                    throw new Error(\"Faild to derive a key pair\");\n                }\n                const bytes = new Uint8Array(await this._hkdf.labeledExpand(dkpPrk, LABEL_CANDIDATE, i2Osp(counter, 1), this._nSk));\n                bytes[0] = bytes[0] & this._bitmask;\n                bn.set(bytes);\n            }\n            const sk = await this._deserializePkcs8Key(bn.val());\n            bn.reset();\n            return {\n                privateKey: sk,\n                publicKey: await this.derivePublicKey(sk),\n            };\n        }\n        catch (e) {\n            throw new DeriveKeyPairError(e);\n        }\n    }\n    async derivePublicKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            delete jwk[\"d\"];\n            delete jwk[\"key_ops\"];\n            return await this._api.importKey(\"jwk\", jwk, this._alg, true, []);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async dh(sk, pk) {\n        try {\n            await this._setup();\n            const bits = await this._api.deriveBits({\n                name: \"ECDH\",\n                public: pk,\n            }, sk, this._nDh * 8);\n            return bits;\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async _importRawKey(key, isPublic) {\n        if (isPublic && key.byteLength !== this._nPk) {\n            throw new Error(\"Invalid public key for the ciphersuite\");\n        }\n        if (!isPublic && key.byteLength !== this._nSk) {\n            throw new Error(\"Invalid private key for the ciphersuite\");\n        }\n        if (isPublic) {\n            return await this._api.importKey(\"raw\", key, this._alg, true, []);\n        }\n        return await this._deserializePkcs8Key(new Uint8Array(key));\n    }\n    async _importJWK(key, isPublic) {\n        if (typeof key.crv === \"undefined\" || key.crv !== this._alg.namedCurve) {\n            throw new Error(`Invalid crv: ${key.crv}`);\n        }\n        if (isPublic) {\n            if (typeof key.d !== \"undefined\") {\n                throw new Error(\"Invalid key: `d` should not be set\");\n            }\n            return await this._api.importKey(\"jwk\", key, this._alg, true, []);\n        }\n        if (typeof key.d === \"undefined\") {\n            throw new Error(\"Invalid key: `d` not found\");\n        }\n        return await this._api.importKey(\"jwk\", key, this._alg, true, KEM_USAGES);\n    }\n    async _deserializePkcs8Key(k) {\n        const pkcs8Key = new Uint8Array(this._pkcs8AlgId.length + k.length);\n        pkcs8Key.set(this._pkcs8AlgId, 0);\n        pkcs8Key.set(k, this._pkcs8AlgId.length);\n        return await this._api.importKey(\"pkcs8\", pkcs8Key, this._alg, true, KEM_USAGES);\n    }\n}\n","import { EMPTY } from \"./consts.js\";\nimport { OpenError } from \"./errors.js\";\nimport { EncryptionContextImpl } from \"./encryptionContext.js\";\nexport class RecipientContextImpl extends EncryptionContextImpl {\n    async open(data, aad = EMPTY) {\n        let pt;\n        try {\n            pt = await this._ctx.key.open(this.computeNonce(this._ctx), data, aad);\n        }\n        catch (e) {\n            throw new OpenError(e);\n        }\n        this.incrementSeq(this._ctx);\n        return pt;\n    }\n}\n","import { EMPTY } from \"./consts.js\";\nimport { SealError } from \"./errors.js\";\nimport { EncryptionContextImpl } from \"./encryptionContext.js\";\nexport class SenderContextImpl extends EncryptionContextImpl {\n    constructor(api, kdf, params, enc) {\n        super(api, kdf, params);\n        Object.defineProperty(this, \"enc\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.enc = enc;\n    }\n    async seal(data, aad = EMPTY) {\n        let ct;\n        try {\n            ct = await this._ctx.key.seal(this.computeNonce(this._ctx), data, aad);\n        }\n        catch (e) {\n            throw new SealError(e);\n        }\n        this.incrementSeq(this._ctx);\n        return ct;\n    }\n}\n","/**\n * The minimum inplementation of bignum to derive an EC key pair.\n */\nexport class Bignum {\n    constructor(size) {\n        Object.defineProperty(this, \"_num\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._num = new Uint8Array(size);\n    }\n    val() {\n        return this._num;\n    }\n    reset() {\n        this._num.fill(0);\n    }\n    set(src) {\n        if (src.length !== this._num.length) {\n            throw new Error(\"Bignum.set: invalid argument\");\n        }\n        this._num.set(src);\n    }\n    isZero() {\n        for (let i = 0; i < this._num.length; i++) {\n            if (this._num[i] !== 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    lessThan(v) {\n        if (v.length !== this._num.length) {\n            throw new Error(\"Bignum.lessThan: invalid argument\");\n        }\n        for (let i = 0; i < this._num.length; i++) {\n            if (this._num[i] < v[i]) {\n                return true;\n            }\n            if (this._num[i] > v[i]) {\n                return false;\n            }\n        }\n        return false;\n    }\n}\n","import { NotSupportedError } from \"../errors.js\";\nexport function emitNotSupported() {\n    return new Promise((_resolve, reject) => {\n        reject(new NotSupportedError(\"Not supported\"));\n    });\n}\n","/**\n * Checks whether the execution env is Deno or not.\n */\nexport const isDeno = () => typeof Deno !== \"undefined\";\n/**\n * Checks whetehr the type of input is CryptoKeyPair or not.\n */\nexport const isCryptoKeyPair = (x) => typeof x === \"object\" &&\n    x !== null &&\n    typeof x.privateKey === \"object\" &&\n    typeof x.publicKey === \"object\";\n/**\n * Converts integer to octet string. I2OSP implementation.\n */\nexport function i2Osp(n, w) {\n    if (w <= 0) {\n        throw new Error(\"i2Osp: too small size\");\n    }\n    if (n >= 256 ** w) {\n        throw new Error(\"i2Osp: too large integer\");\n    }\n    const ret = new Uint8Array(w);\n    for (let i = 0; i < w && n; i++) {\n        ret[w - (i + 1)] = n % 256;\n        n = n >> 8;\n    }\n    return ret;\n}\n/**\n * Concatenates two Uint8Arrays.\n */\nexport function concat(a, b) {\n    const ret = new Uint8Array(a.length + b.length);\n    ret.set(a, 0);\n    ret.set(b, a.length);\n    return ret;\n}\n/**\n * Decodes Base64Url-encoded data.\n */\nexport function base64UrlToBytes(v) {\n    const base64 = v.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const byteString = atob(base64);\n    const ret = new Uint8Array(byteString.length);\n    for (let i = 0; i < byteString.length; i++) {\n        ret[i] = byteString.charCodeAt(i);\n    }\n    return ret;\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7UA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxDA;AACA;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACLA;AACA;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}