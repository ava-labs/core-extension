{"version":3,"file":"js/offscreen.js","sources":["webpack://@core/offscreen/../common/src/constants.ts","webpack://@core/offscreen/../common/src/feature-flags.ts","webpack://@core/offscreen/../common/src/index.ts","webpack://@core/offscreen/../common/src/initI18n.ts","webpack://@core/offscreen/../common/src/monitoring/index.ts","webpack://@core/offscreen/../common/src/monitoring/sentryCaptureException.ts","webpack://@core/offscreen/../common/src/monitoring/sharedSentryConfig.ts","webpack://@core/offscreen/../common/src/script-names.ts","webpack://@core/offscreen/../common/src/utils/account.ts","webpack://@core/offscreen/../common/src/utils/accounts/accountTypeGuards.ts","webpack://@core/offscreen/../common/src/utils/accounts/index.ts","webpack://@core/offscreen/../common/src/utils/actions/getUpdatedActionData.ts","webpack://@core/offscreen/../common/src/utils/address.ts","webpack://@core/offscreen/../common/src/utils/approveSeedlessRegistration.ts","webpack://@core/offscreen/../common/src/utils/array.ts","webpack://@core/offscreen/../common/src/utils/assertions.ts","webpack://@core/offscreen/../common/src/utils/balance/getPriceChangeValues.ts","webpack://@core/offscreen/../common/src/utils/balance/getTokenValue.ts","webpack://@core/offscreen/../common/src/utils/balance/groupTokensByType.ts","webpack://@core/offscreen/../common/src/utils/balance/index.ts","webpack://@core/offscreen/../common/src/utils/balance/isTokenWithBalanceAVM.ts","webpack://@core/offscreen/../common/src/utils/balance/isTokenWithBalancePVM.ts","webpack://@core/offscreen/../common/src/utils/bigintToBig.ts","webpack://@core/offscreen/../common/src/utils/bridge/blockchainConversion.ts","webpack://@core/offscreen/../common/src/utils/bridge/bridgeEventFilters.ts","webpack://@core/offscreen/../common/src/utils/bridge/filterBridgeStateToNetwork.ts","webpack://@core/offscreen/../common/src/utils/bridge/findMatchingBridgeAsset.ts","webpack://@core/offscreen/../common/src/utils/bridge/getBridgedAssetSymbol.ts","webpack://@core/offscreen/../common/src/utils/bridge/getNativeTokenSymbol.ts","webpack://@core/offscreen/../common/src/utils/bridge/index.ts","webpack://@core/offscreen/../common/src/utils/bridge/isAddressBlockedError.ts","webpack://@core/offscreen/../common/src/utils/bridge/isUnifiedBridgeTransfer.ts","webpack://@core/offscreen/../common/src/utils/bridgeTransactionUtils.ts","webpack://@core/offscreen/../common/src/utils/caipConversion.ts","webpack://@core/offscreen/../common/src/utils/calculateGasAndFees.ts","webpack://@core/offscreen/../common/src/utils/calculateTotalBalance.ts","webpack://@core/offscreen/../common/src/utils/canSkipApproval.ts","webpack://@core/offscreen/../common/src/utils/constants.ts","webpack://@core/offscreen/../common/src/utils/createMnemonicPhrase.ts","webpack://@core/offscreen/../common/src/utils/distributiveomit.ts","webpack://@core/offscreen/../common/src/utils/encoding.ts","webpack://@core/offscreen/../common/src/utils/environment.ts","webpack://@core/offscreen/../common/src/utils/errors/errorHelpers.ts","webpack://@core/offscreen/../common/src/utils/errors/index.ts","webpack://@core/offscreen/../common/src/utils/exponentialBackoff.ts","webpack://@core/offscreen/../common/src/utils/extensionUtils.ts","webpack://@core/offscreen/../common/src/utils/fetchAndVerify.ts","webpack://@core/offscreen/../common/src/utils/filterFalsyValues.ts","webpack://@core/offscreen/../common/src/utils/findTokenForAsset.ts","webpack://@core/offscreen/../common/src/utils/fireblocks/getFireblocksBtcAccessErrorCode.ts","webpack://@core/offscreen/../common/src/utils/fireblocks/isFireblocksApiSupported.ts","webpack://@core/offscreen/../common/src/utils/getAccountKey.ts","webpack://@core/offscreen/../common/src/utils/getAddressForChain.ts","webpack://@core/offscreen/../common/src/utils/getCoreWebUrl.ts","webpack://@core/offscreen/../common/src/utils/getDefaultChainIds.ts","webpack://@core/offscreen/../common/src/utils/getEnabledBridgeTypes.ts","webpack://@core/offscreen/../common/src/utils/getExplorerAddress.ts","webpack://@core/offscreen/../common/src/utils/getHexStringToBytes.ts","webpack://@core/offscreen/../common/src/utils/getNftMetadata.ts","webpack://@core/offscreen/../common/src/utils/getSyncDomain.ts","webpack://@core/offscreen/../common/src/utils/handleTxOutcome.ts","webpack://@core/offscreen/../common/src/utils/hasAccountBalances.ts","webpack://@core/offscreen/../common/src/utils/hasUnconfirmedBalance.ts","webpack://@core/offscreen/../common/src/utils/history/getAvaxAssetId.ts","webpack://@core/offscreen/../common/src/utils/history/index.ts","webpack://@core/offscreen/../common/src/utils/history/isTxHistoryItem.ts","webpack://@core/offscreen/../common/src/utils/incrementalPromiseResolve.ts","webpack://@core/offscreen/../common/src/utils/index.ts","webpack://@core/offscreen/../common/src/utils/ipsfResolverWithFallback.ts","webpack://@core/offscreen/../common/src/utils/isActiveTab.ts","webpack://@core/offscreen/../common/src/utils/isAddressValid.ts","webpack://@core/offscreen/../common/src/utils/isBitcoin.ts","webpack://@core/offscreen/../common/src/utils/isBtcAddressInNetwork.ts","webpack://@core/offscreen/../common/src/utils/isContactValid.ts","webpack://@core/offscreen/../common/src/utils/isFailedToFetchError.ts","webpack://@core/offscreen/../common/src/utils/isLedgerVersionCompatible.ts","webpack://@core/offscreen/../common/src/utils/isLockStateChangedEvent.ts","webpack://@core/offscreen/../common/src/utils/isPrimarySubnet.ts","webpack://@core/offscreen/../common/src/utils/isSupportedBrowser.ts","webpack://@core/offscreen/../common/src/utils/isSwimmerNetwork.ts","webpack://@core/offscreen/../common/src/utils/isTokenMalicious.ts","webpack://@core/offscreen/../common/src/utils/isWalletStateUpdateEvent.ts","webpack://@core/offscreen/../common/src/utils/jsonRpcEngine.ts","webpack://@core/offscreen/../common/src/utils/keystore/cryptoHelpers.ts","webpack://@core/offscreen/../common/src/utils/keystore/index.ts","webpack://@core/offscreen/../common/src/utils/keystore/keystore-fixtures/index.ts","webpack://@core/offscreen/../common/src/utils/keystore/keystore.ts","webpack://@core/offscreen/../common/src/utils/logging.ts","webpack://@core/offscreen/../common/src/utils/lowerCaseKeys.ts","webpack://@core/offscreen/../common/src/utils/makeBNLike.ts","webpack://@core/offscreen/../common/src/utils/measureDuration.ts","webpack://@core/offscreen/../common/src/utils/network/addGlacierAPIKeyIfNeeded.ts","webpack://@core/offscreen/../common/src/utils/network/buildGlacierAuthHeaders.ts","webpack://@core/offscreen/../common/src/utils/network/getProviderForNetwork.ts","webpack://@core/offscreen/../common/src/utils/network/isAvalancheNetwork.ts","webpack://@core/offscreen/../common/src/utils/network/isAvalanchePchainNetwork.ts","webpack://@core/offscreen/../common/src/utils/network/isAvalancheXchainNetwork.ts","webpack://@core/offscreen/../common/src/utils/network/isBitcoinNetwork.ts","webpack://@core/offscreen/../common/src/utils/network/isEthereumNetwork.ts","webpack://@core/offscreen/../common/src/utils/network/isSolanaNetwork.ts","webpack://@core/offscreen/../common/src/utils/network/isValidHttpHeader.ts","webpack://@core/offscreen/../common/src/utils/newsletter.ts","webpack://@core/offscreen/../common/src/utils/nfts/getSmallImageForNFT.ts","webpack://@core/offscreen/../common/src/utils/nfts/isNFT.ts","webpack://@core/offscreen/../common/src/utils/nfts/metadataParser.ts","webpack://@core/offscreen/../common/src/utils/nfts/nftTypesUtils.ts","webpack://@core/offscreen/../common/src/utils/noop.ts","webpack://@core/offscreen/../common/src/utils/normalizeBalance.ts","webpack://@core/offscreen/../common/src/utils/number.ts","webpack://@core/offscreen/../common/src/utils/object.ts","webpack://@core/offscreen/../common/src/utils/onPageActivated.ts","webpack://@core/offscreen/../common/src/utils/openFullscreenTab.ts","webpack://@core/offscreen/../common/src/utils/promiseResolver.ts","webpack://@core/offscreen/../common/src/utils/seedPhraseValidation.ts","webpack://@core/offscreen/../common/src/utils/seedless/authenticateWithApple.ts","webpack://@core/offscreen/../common/src/utils/seedless/authenticateWithGoogle.ts","webpack://@core/offscreen/../common/src/utils/seedless/fido/convertRequest.ts","webpack://@core/offscreen/../common/src/utils/seedless/fido/convertResult.ts","webpack://@core/offscreen/../common/src/utils/seedless/fido/index.ts","webpack://@core/offscreen/../common/src/utils/seedless/fido/launchFidoFlow.ts","webpack://@core/offscreen/../common/src/utils/seedless/fido/seedless-utils.ts","webpack://@core/offscreen/../common/src/utils/seedless/fido/validateResponse.ts","webpack://@core/offscreen/../common/src/utils/seedless/getCubeSigner.ts","webpack://@core/offscreen/../common/src/utils/seedless/getOidcTokenProvider.ts","webpack://@core/offscreen/../common/src/utils/seedless/getSignerToken.ts","webpack://@core/offscreen/../common/src/utils/seedless/launchWebAuthFlow.ts","webpack://@core/offscreen/../common/src/utils/seedless/seedlessEventFilters.ts","webpack://@core/offscreen/../common/src/utils/send/btcSendUtils.ts","webpack://@core/offscreen/../common/src/utils/shouldUseWalletConnectApproval.ts","webpack://@core/offscreen/../common/src/utils/stringToBigint.ts","webpack://@core/offscreen/../common/src/utils/stripAddressPrefix.ts","webpack://@core/offscreen/../common/src/utils/sumByProperty.ts","webpack://@core/offscreen/../common/src/utils/truncateAddress.ts","webpack://@core/offscreen/../common/src/utils/typeUtils.ts","webpack://@core/offscreen/../common/src/utils/updateIfDifferent.ts","webpack://@core/offscreen/../common/src/utils/walletConnectEventFilters.ts","webpack://@core/offscreen/./src/offscreen.ts","webpack://@core/offscreen/../types/src/account.ts","webpack://@core/offscreen/../types/src/actions.ts","webpack://@core/offscreen/../types/src/analytics.ts","webpack://@core/offscreen/../types/src/app-check.ts","webpack://@core/offscreen/../types/src/approvals.ts","webpack://@core/offscreen/../types/src/balance.ts","webpack://@core/offscreen/../types/src/bridge.ts","webpack://@core/offscreen/../types/src/contacts.ts","webpack://@core/offscreen/../types/src/currency.ts","webpack://@core/offscreen/../types/src/dapp-connection.ts","webpack://@core/offscreen/../types/src/debank.ts","webpack://@core/offscreen/../types/src/defi.ts","webpack://@core/offscreen/../types/src/domain-metadata.ts","webpack://@core/offscreen/../types/src/error.ts","webpack://@core/offscreen/../types/src/feature-flags.ts","webpack://@core/offscreen/../types/src/firebase.ts","webpack://@core/offscreen/../types/src/fireblocks.ts","webpack://@core/offscreen/../types/src/gasless.ts","webpack://@core/offscreen/../types/src/history.ts","webpack://@core/offscreen/../types/src/index.ts","webpack://@core/offscreen/../types/src/keystone.ts","webpack://@core/offscreen/../types/src/keystore.ts","webpack://@core/offscreen/../types/src/ledger.ts","webpack://@core/offscreen/../types/src/lock.ts","webpack://@core/offscreen/../types/src/messages.ts","webpack://@core/offscreen/../types/src/navigation-history.ts","webpack://@core/offscreen/../types/src/network-fee.ts","webpack://@core/offscreen/../types/src/network.ts","webpack://@core/offscreen/../types/src/notifications.ts","webpack://@core/offscreen/../types/src/onboarding.ts","webpack://@core/offscreen/../types/src/permissions.ts","webpack://@core/offscreen/../types/src/secrets.ts","webpack://@core/offscreen/../types/src/seedless.ts","webpack://@core/offscreen/../types/src/send.ts","webpack://@core/offscreen/../types/src/settings.ts","webpack://@core/offscreen/../types/src/storage.ts","webpack://@core/offscreen/../types/src/tokens.ts","webpack://@core/offscreen/../types/src/transaction.ts","webpack://@core/offscreen/../types/src/ui-connection.ts","webpack://@core/offscreen/../types/src/ui.ts","webpack://@core/offscreen/../types/src/unified-bridge.ts","webpack://@core/offscreen/../types/src/util-types.ts","webpack://@core/offscreen/../types/src/wallet-connect.ts","webpack://@core/offscreen/../types/src/wallet.ts","webpack://@core/offscreen/../types/src/web3.ts"],"sourcesContent":["import { isDevelopment, isProductionBuild } from './utils/environment';\nimport browser from 'webextension-polyfill';\n\nconst CORE_WEB_DOMAIN = 'core.app' as const;\nconst CORE_WEB_TESTNET_DOMAIN = 'test.core.app' as const;\nconst CORE_WEB_STAGING_DOMAIN = 'core-web.pages.dev' as const;\nconst DAPP_DEV_DOMAINS = [\n  'localhost',\n  '127.0.0.1',\n  'redesign-aa3.pages.dev',\n] as const;\n\nconst SYNCED_DOMAINS_PRODUCTION_BUILD = [CORE_WEB_DOMAIN] as const;\nconst SYNCED_DOMAINS_DEVELOPMENT_BUILD = [\n  CORE_WEB_DOMAIN,\n  CORE_WEB_TESTNET_DOMAIN,\n  CORE_WEB_STAGING_DOMAIN,\n  ...DAPP_DEV_DOMAINS,\n] as const;\n\nexport const KNOWN_CORE_DOMAINS = [\n  CORE_WEB_DOMAIN,\n  CORE_WEB_TESTNET_DOMAIN,\n  CORE_WEB_STAGING_DOMAIN,\n  ...DAPP_DEV_DOMAINS,\n] as const;\n\nexport const SYNCED_DOMAINS = isProductionBuild()\n  ? SYNCED_DOMAINS_PRODUCTION_BUILD\n  : SYNCED_DOMAINS_DEVELOPMENT_BUILD;\n\nexport const WALLET_CONNECT_APP_METADATA = {\n  name: browser.i18n.getMessage('appName'),\n  // When connecting to Core Mobile, it will allow us to send avalanche_*\n  // requests, as long as it recognizes us as part of the Core product.\n  //\n  // In local development, the extension ID may change from one machine\n  // to another, so we use localhost to make it work.\n  //\n  // For production & blue builds, Core Mobile is able to recognize their\n  // extension IDs, since they are permanent.\n  url: isDevelopment() ? 'https://localhost' : location.origin,\n  description: browser.i18n.getMessage('appDesc'),\n  icons: ['https://extension.core.app/apple-touch-icon.png'],\n};\n","import { FeatureFlags, FeatureGates } from '@core/types';\n\n// Posthog API does not return disabled flags on their `/decide` api endpoint\n// Define disabled state values for the flags\nexport const DISABLED_FLAG_VALUES: FeatureFlags = {\n  [FeatureGates.EVERYTHING]: false,\n  [FeatureGates.EVENTS]: false,\n  [FeatureGates.SWAP]: false,\n  [FeatureGates.SWAP_C_CHAIN]: false,\n  [FeatureGates.SWAP_ETHEREUM]: false,\n  [FeatureGates.SWAP_SOLANA]: false,\n  [FeatureGates.SWAP_FEES]: false,\n  [FeatureGates.SWAP_FEES_JUPITER]: false,\n  [FeatureGates.BRIDGE]: false,\n  [FeatureGates.BRIDGE_ETH]: false,\n  [FeatureGates.BRIDGE_BTC]: false,\n  [FeatureGates.SEND]: false,\n  [FeatureGates.SEND_P_CHAIN]: false,\n  [FeatureGates.SEND_X_CHAIN]: false,\n  [FeatureGates.SENDTRANSACTION_CHAIN_ID_SUPPORT]: false,\n  [FeatureGates.BUY]: false,\n  [FeatureGates.BUY_MOONPAY]: false,\n  [FeatureGates.BUY_COINBASE]: false,\n  [FeatureGates.KEYSTONE]: false,\n  [FeatureGates.NFT_MARKETPLACE]: false,\n  [FeatureGates.BOTTOM_NAVIGATION]: false,\n  [FeatureGates.DEFI]: false,\n  [FeatureGates.IMPORT_WALLET_CONNECT]: false,\n  [FeatureGates.IMPORT_FIREBLOCKS]: false,\n  [FeatureGates.IN_APP_SUPPORT_P_CHAIN]: false,\n  [FeatureGates.IN_APP_SUPPORT_X_CHAIN]: false,\n  [FeatureGates.SEEDLESS_ONBOARDING]: false,\n  [FeatureGates.SEEDLESS_ONBOARDING_GOOGLE]: false,\n  [FeatureGates.SEEDLESS_ONBOARDING_APPLE]: false,\n  [FeatureGates.SEEDLESS_MFA_PASSKEY]: false,\n  [FeatureGates.SEEDLESS_MFA_AUTHENTICATOR]: false,\n  [FeatureGates.SEEDLESS_MFA_YUBIKEY]: false,\n  [FeatureGates.SEEDLESS_SIGNING]: false,\n  [FeatureGates.SEEEDLESS_MFA_SETTINGS]: false,\n  [FeatureGates.SEEDLESS_OPTIONAL_MFA]: false,\n  [FeatureGates.UNIFIED_BRIDGE_CCTP]: false,\n  [FeatureGates.UNIFIED_BRIDGE_ICTT]: false,\n  [FeatureGates.UNIFIED_BRIDGE_AB_EVM]: false,\n  [FeatureGates.UNIFIED_BRIDGE_AB_AVA_TO_BTC]: false,\n  [FeatureGates.UNIFIED_BRIDGE_AB_BTC_TO_AVA]: false,\n  [FeatureGates.DEBANK_TRANSACTION_PARSING]: false,\n  [FeatureGates.DEBANK_TRANSACTION_PRE_EXECUTION]: false,\n  [FeatureGates.PRIMARY_ACCOUNT_REMOVAL]: false,\n  [FeatureGates.ADD_WALLET_WITH_SEEDPHRASE]: false,\n  [FeatureGates.ADD_WALLET_WITH_KEYSTORE_FILE]: false,\n  [FeatureGates.ADD_WALLET_WITH_LEDGER]: false,\n  [FeatureGates.BLOCKAID_DAPP_SCAN]: false,\n  [FeatureGates.BLOCKAID_DAPP_SCAN_WARNING]: false,\n  [FeatureGates.BLOCKAID_TRANSACTION_SCAN]: false,\n  [FeatureGates.BLOCKAID_JSONRPC_SCAN]: false,\n  [FeatureGates.HALLIDAY_BRIDGE_BANNER]: false,\n  [FeatureGates.FIREBASE_CLOUD_MESSAGING]: false,\n  [FeatureGates.ONE_CLICK_SWAP]: false,\n  [FeatureGates.GASLESS]: false,\n  [FeatureGates.SOLANA_SUPPORT]: false,\n  [FeatureGates.CORE_ASSISTANT]: false,\n};\n\n// Default flags are used when posthog is not available\nexport const DEFAULT_FLAGS: FeatureFlags = {\n  [FeatureGates.EVERYTHING]: true,\n  [FeatureGates.EVENTS]: true,\n  [FeatureGates.SWAP]: true,\n  [FeatureGates.SWAP_C_CHAIN]: true,\n  [FeatureGates.SWAP_ETHEREUM]: true,\n  [FeatureGates.SWAP_SOLANA]: true,\n  [FeatureGates.SWAP_FEES]: true,\n  [FeatureGates.SWAP_FEES_JUPITER]: true,\n  [FeatureGates.BRIDGE]: true,\n  [FeatureGates.BRIDGE_ETH]: true,\n  [FeatureGates.BRIDGE_BTC]: true,\n  [FeatureGates.SEND]: true,\n  [FeatureGates.SEND_P_CHAIN]: true,\n  [FeatureGates.SEND_X_CHAIN]: true,\n  [FeatureGates.SENDTRANSACTION_CHAIN_ID_SUPPORT]: true,\n  [FeatureGates.BUY]: true,\n  [FeatureGates.BUY_MOONPAY]: true,\n  [FeatureGates.BUY_COINBASE]: true,\n  [FeatureGates.KEYSTONE]: true,\n  [FeatureGates.NFT_MARKETPLACE]: true,\n  [FeatureGates.BOTTOM_NAVIGATION]: true,\n  [FeatureGates.DEFI]: true,\n  [FeatureGates.IMPORT_WALLET_CONNECT]: true,\n  [FeatureGates.IMPORT_FIREBLOCKS]: true,\n  [FeatureGates.IN_APP_SUPPORT_P_CHAIN]: true,\n  [FeatureGates.IN_APP_SUPPORT_X_CHAIN]: true,\n  [FeatureGates.SEEDLESS_ONBOARDING]: true,\n  [FeatureGates.SEEDLESS_ONBOARDING_GOOGLE]: true,\n  [FeatureGates.SEEDLESS_ONBOARDING_APPLE]: true,\n  [FeatureGates.SEEDLESS_MFA_PASSKEY]: true,\n  [FeatureGates.SEEDLESS_MFA_AUTHENTICATOR]: true,\n  [FeatureGates.SEEDLESS_MFA_YUBIKEY]: true,\n  [FeatureGates.SEEDLESS_SIGNING]: true,\n  [FeatureGates.SEEEDLESS_MFA_SETTINGS]: true,\n  [FeatureGates.SEEDLESS_OPTIONAL_MFA]: true,\n  [FeatureGates.UNIFIED_BRIDGE_CCTP]: true,\n  [FeatureGates.UNIFIED_BRIDGE_ICTT]: true,\n  [FeatureGates.UNIFIED_BRIDGE_AB_EVM]: true,\n  [FeatureGates.UNIFIED_BRIDGE_AB_AVA_TO_BTC]: true,\n  [FeatureGates.UNIFIED_BRIDGE_AB_BTC_TO_AVA]: true,\n  [FeatureGates.DEBANK_TRANSACTION_PARSING]: false,\n  [FeatureGates.DEBANK_TRANSACTION_PRE_EXECUTION]: false,\n  [FeatureGates.PRIMARY_ACCOUNT_REMOVAL]: true,\n  [FeatureGates.ADD_WALLET_WITH_SEEDPHRASE]: true,\n  [FeatureGates.ADD_WALLET_WITH_KEYSTORE_FILE]: true,\n  [FeatureGates.ADD_WALLET_WITH_LEDGER]: true,\n  [FeatureGates.BLOCKAID_DAPP_SCAN]: true,\n  [FeatureGates.BLOCKAID_DAPP_SCAN_WARNING]: true,\n  [FeatureGates.BLOCKAID_TRANSACTION_SCAN]: true,\n  [FeatureGates.BLOCKAID_JSONRPC_SCAN]: true,\n  [FeatureGates.HALLIDAY_BRIDGE_BANNER]: true,\n  [FeatureGates.FIREBASE_CLOUD_MESSAGING]: true,\n  [FeatureGates.ONE_CLICK_SWAP]: true,\n  [FeatureGates.GASLESS]: true,\n  [FeatureGates.SOLANA_SUPPORT]: true,\n  [FeatureGates.CORE_ASSISTANT]: true,\n};\n\nexport const FEATURE_FLAGS_OVERRIDES_KEY = '__feature-flag-overrides__';\n","export * from './script-names';\nexport * as Monitoring from './monitoring';\nexport * from './constants';\nexport * from './feature-flags';\nexport * from './utils';\nexport * from './initI18n';\n","import i18next from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport HttpApi from 'i18next-http-backend';\n\nexport const initI18n = () =>\n  i18next\n    .use(initReactI18next)\n    .use(HttpApi) // Registering the back-end plugin\n    .init({\n      // Remove resources from here\n      lng: 'en',\n      fallbackLng: 'en',\n      supportedLngs: [\n        'en',\n        'de-DE',\n        'hi-IN',\n        'ko-KR',\n        'ru-RU',\n        'tr-TR',\n        'zh-CN',\n        'zh-TW',\n        'es-EM',\n        'ja-JP',\n        'fr-FR',\n      ],\n      load: 'currentOnly',\n      interpolation: {\n        escapeValue: false,\n      },\n      // turn on if you want to print out to the console the whole translation object (e.g. check your key and value has been added to the json)\n      debug: false,\n    });\n\nexport { i18next };\n","import sentryCaptureException, {\n  SentryExceptionTypes,\n} from './sentryCaptureException';\nimport sharedSentryConfig from './sharedSentryConfig';\n\nexport { sentryCaptureException, sharedSentryConfig, SentryExceptionTypes };\n","import * as Sentry from '@sentry/browser';\n\nexport enum SentryExceptionTypes {\n  // dApp\n  DAPP_CONNECTION_EVENT = 'dAppConnectionEvent',\n\n  // extension\n  EXTENSION_CONNECTION_MESSAGE = 'extensionConnectionMessage',\n  EXTENSION_CONNECTION_EVENT = 'extensionConnectionEvent',\n\n  SWAP = 'swap',\n\n  AI_AGENT = 'aiAgent',\n\n  // ledger\n  LEDGER = 'ledger',\n\n  WALLETCONNECT = 'walletConnect',\n\n  SEEDLESS = 'seedless',\n\n  FIREBLOCKS = 'fireblocks',\n\n  UNIFIED_BRIDGE = 'unifiedBridge',\n\n  ANALYTICS = 'analytics',\n\n  WALLET_IMPORT = 'walletImport',\n\n  INTERNAL_ERROR = 'internalError',\n\n  BALANCES = 'balances',\n\n  VM_MODULES = 'vmModules',\n\n  ONBOARDING = 'onboarding',\n\n  FIREBASE = 'firebase',\n\n  NOTIFICATIONS = 'notifications',\n}\n\n// wrapper to make error reporting contexts unfirom accross the codebase\nconst sentryCaptureException = (error: Error, type: SentryExceptionTypes) =>\n  Sentry.captureException(error, { tags: { type } });\n\nexport default sentryCaptureException;\n","import browser from 'webextension-polyfill';\n\nconst sharedSentryConfig = {\n  dsn: process.env.SENTRY_DSN,\n  environment: process.env.RELEASE || 'dev',\n  release: `core-extension@${browser.runtime.getManifest().version}`,\n  debug: process.env.SENTRY_DEBUG === 'true',\n  tracesSampleRate: 0.003,\n  ignoreErrors: [\n    /Attempting to use a disconnected port object/, // ignore errors caused by us trying to respond to clients that already disconnected\n    /^.*The user aborted a request\\.$/, // ignore errors caused by chrome's throttling\n    /^.*could not detect network.*$/, // ignore ethers provider connection errors\n    /^.*Failed to fetch$/, // ignore network errors\n    /AbortError: Registration failed - push service error/, // ignore push service FCM registration failures\n    /^.*NotAllowedError: Registration failed - permission denied/, // ignore push service FCM registration failures\n  ],\n};\n\nexport default sharedSentryConfig;\n","export const CONTENT_SCRIPT = 'avalanche-contentscript';\nexport const EXTENSION_SCRIPT = 'avalanche-extension';\nexport const INPAGE_SCRIPT = 'avalanche-inpage';\nexport const OFFSCREEN_SCRIPT = 'avalanche-offscreen';\n","import { Account } from '@core/types';\n\nexport function getAllAddressesForAccount(acc: Partial<Account>) {\n  return [\n    acc.addressC,\n    acc.addressBTC,\n    acc.addressAVM,\n    acc.addressPVM,\n    acc.addressCoreEth,\n    acc.addressHVM,\n    acc.addressSVM,\n  ].filter((addr): addr is string => typeof addr === 'string');\n}\n\nexport function getAllAddressesForAccounts(accounts: Account[]): string[] {\n  return accounts\n    .flatMap(getAllAddressesForAccount)\n    .filter((v) => typeof v === 'string');\n}\n","import {\n  Account,\n  AccountType,\n  FireblocksAccount,\n  ImportedAccount,\n  PrimaryAccount,\n  WalletConnectAccount,\n} from '@core/types';\n\nexport const isFireblocksAccount = (\n  account?: Account,\n): account is FireblocksAccount => account?.type === AccountType.FIREBLOCKS;\n\nexport const isWalletConnectAccount = (\n  account?: Account,\n): account is WalletConnectAccount =>\n  account?.type === AccountType.WALLET_CONNECT;\n\nexport const isPrimaryAccount = (\n  account?: Pick<Account, 'type'>,\n): account is PrimaryAccount => account?.type === AccountType.PRIMARY;\n\nexport const isImportedAccount = (\n  account?: Account,\n): account is ImportedAccount => Boolean(account) && !isPrimaryAccount(account);\n","export * from './accountTypeGuards';\n","import { SigningData } from '@avalabs/vm-module-types';\n\nexport const getUpdatedSigningData = (\n  oldSigningData?: SigningData,\n  newSigningData?: SigningData,\n): SigningData | undefined => {\n  if (!oldSigningData) {\n    return newSigningData;\n  } else if (!newSigningData) {\n    return oldSigningData;\n  }\n\n  return {\n    ...oldSigningData,\n    ...newSigningData,\n  };\n};\n","import { Avalanche } from '@avalabs/core-wallets-sdk';\nimport { NetworkVMType } from '@avalabs/vm-module-types';\n\nimport { Account } from '@core/types';\nimport { omitUndefined } from './object';\n\nexport const mapVMAddresses = (addresses: Record<NetworkVMType, string>) =>\n  omitUndefined({\n    addressC: addresses[NetworkVMType.EVM],\n    addressBTC: addresses[NetworkVMType.BITCOIN] || undefined,\n    addressAVM: addresses[NetworkVMType.AVM] || undefined,\n    addressPVM: addresses[NetworkVMType.PVM] || undefined,\n    addressCoreEth: addresses[NetworkVMType.CoreEth] || undefined,\n    addressHVM: addresses[NetworkVMType.HVM] || undefined,\n    addressSVM: addresses[NetworkVMType.SVM] || undefined,\n  } as const);\n\nexport const mapAddressesToVMs = (\n  account: Partial<Account>,\n): Partial<Record<NetworkVMType, string>> =>\n  omitUndefined({\n    [NetworkVMType.EVM]: account.addressC,\n    [NetworkVMType.BITCOIN]: account.addressBTC,\n    [NetworkVMType.AVM]: account.addressAVM,\n    [NetworkVMType.PVM]: account.addressPVM,\n    [NetworkVMType.CoreEth]: account.addressCoreEth,\n    [NetworkVMType.HVM]: account.addressHVM,\n    [NetworkVMType.SVM]: account.addressSVM,\n  } as const);\n\nexport const getAddressByVMType = (account: Account, vmType: NetworkVMType) =>\n  mapAddressesToVMs(account)[vmType];\n\nexport function getAddressesInRange(\n  xpubXP: string,\n  providerXP: Avalanche.JsonRpcProvider,\n  internal = false,\n  start = 0,\n  limit = 64,\n) {\n  const addresses: string[] = [];\n\n  for (let i = start; i < start + limit; i++) {\n    addresses.push(\n      Avalanche.getAddressFromXpub(xpubXP, i, providerXP, 'P', internal).split(\n        '-',\n      )[1] as string,\n    );\n  }\n\n  return addresses;\n}\n","import { IdentityProof } from '@cubist-labs/cubesigner-sdk';\n\nexport enum SeedlessRegistartionResult {\n  ALREADY_REGISTERED = 'ALREADY_REGISTERED',\n  APPROVED = 'APPROVED',\n  ERROR = 'ERROR',\n}\n\nenum SeedlessRegistartionResponseTextStatus {\n  ALREADY_REGISTERED = 'ALREADY_REGISTERED',\n  APPROVED = 'ok',\n}\n\nexport async function approveSeedlessRegistration(\n  identityProof: IdentityProof,\n  isMfaRequired: boolean,\n): Promise<SeedlessRegistartionResult> {\n  return fetch(\n    process.env.SEEDLESS_URL +\n      `/v1/register?mfa-required=${isMfaRequired ? 'true' : 'false'}`,\n    {\n      method: 'POST',\n      body: JSON.stringify(identityProof),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    },\n  )\n    .then(async (response) => {\n      const { message }: { message: SeedlessRegistartionResponseTextStatus } =\n        await response.json();\n\n      if (\n        message === SeedlessRegistartionResponseTextStatus.ALREADY_REGISTERED\n      ) {\n        return SeedlessRegistartionResult.ALREADY_REGISTERED;\n      }\n      if (message === SeedlessRegistartionResponseTextStatus.APPROVED) {\n        return SeedlessRegistartionResult.APPROVED;\n      }\n      throw new Error(message);\n    })\n    .catch(() => {\n      return SeedlessRegistartionResult.ERROR;\n    });\n}\n","export const areArraysOverlapping = (\n  listA: unknown[],\n  listB: unknown[],\n): boolean => {\n  return listA.some((itemFromA) => listB.includes(itemFromA));\n};\n","import { ethErrors } from 'eth-rpc-errors';\nimport { CommonError, ErrorCode } from '@core/types';\n\nexport function assertPresent<T>(\n  value: T,\n  reason: ErrorCode,\n  context?: string,\n): asserts value is NonNullable<T> {\n  const isNullish = typeof value === 'undefined' || value === null;\n  const isEmptyBuffer = Buffer.isBuffer(value) && value.length === 0;\n\n  if (isNullish || isEmptyBuffer || value === '') {\n    throw ethErrors.rpc.internal({\n      data: {\n        reason: reason ?? CommonError.Unknown,\n        context,\n      },\n    });\n  }\n}\n\nexport function assertPropDefined<T, K extends keyof T>(\n  obj: T,\n  prop: K,\n  reason: ErrorCode,\n): asserts obj is T & Record<K, NonNullable<T[K]>> {\n  assertPresent(obj[prop], reason);\n}\n\ntype NonEmptyString<T> = T extends '' ? never : T;\n\nexport function assertNonEmptyString<T>(\n  value: T,\n): asserts value is NonEmptyString<T> {\n  if (typeof value !== 'string' || value === '') {\n    throw ethErrors.rpc.internal({\n      data: {\n        reason: 'Expected non-empty string',\n        value,\n      },\n    });\n  }\n}\n\nexport function assertTrue(condition: unknown): asserts condition is true {\n  if (condition !== true) {\n    throw ethErrors.rpc.internal({\n      data: {\n        reason: 'Expected condition to evaluate as true',\n        evaluationResult: condition,\n      },\n    });\n  }\n}\n\nexport function assert(\n  value: unknown,\n  reason?: ErrorCode,\n): asserts value is NonNullable<unknown> {\n  if (!value) {\n    throw ethErrors.rpc.internal({\n      data: { reason: reason ?? CommonError.Unknown },\n    });\n  }\n}\n","import { TokensPriceShortData } from '@core/types';\n\nexport function getPriceChangeValues(\n  tokenSymbol: string,\n  balanceInCurrency?: number,\n  priceChanges?: TokensPriceShortData,\n) {\n  if (!priceChanges) {\n    return {\n      percentage: undefined,\n      value: 0,\n    };\n  }\n  const symbol = tokenSymbol.toLowerCase();\n  const tokenChangePercentage = priceChanges[symbol]?.priceChangePercentage;\n  const tokenChangeValue =\n    (balanceInCurrency || 0) *\n    ((priceChanges[symbol]?.priceChangePercentage || 0) / 100);\n\n  return {\n    percentage: tokenChangePercentage,\n    value: tokenChangeValue,\n  };\n}\n","export function getTokenValue(decimals: number, amount?: number) {\n  return amount === undefined ? 0 : amount / 10 ** decimals;\n}\n","import {\n  NftTokenWithBalance,\n  TokenWithBalance,\n} from '@avalabs/vm-module-types';\nimport { isNFT } from '../nfts/isNFT';\n\nexport function groupTokensByType(\n  balances?: Record<string, Record<string, TokenWithBalance>>,\n): {\n  nfts: Record<string, Record<string, NftTokenWithBalance>>;\n  tokens: Record<string, Record<string, TokenWithBalance>>;\n} {\n  const nfts: Record<string, Record<string, NftTokenWithBalance>> = {};\n  const tokens: Record<string, Record<string, TokenWithBalance>> = {};\n  if (!balances) {\n    return { tokens, nfts };\n  }\n  for (const address in balances) {\n    const nftsForAddress = {};\n    const tokensForAddress = {};\n    for (const tokenId in balances[address]) {\n      const token = balances[address]?.[tokenId];\n      if (!token) {\n        continue;\n      }\n      if (isNFT(token)) {\n        nftsForAddress[tokenId] = token;\n      } else {\n        tokensForAddress[tokenId] = token;\n      }\n    }\n\n    nfts[address] = nftsForAddress;\n    tokens[address] = tokensForAddress;\n  }\n\n  return {\n    nfts,\n    tokens,\n  };\n}\n","export * from './getPriceChangeValues';\nexport * from './getTokenValue';\nexport * from './groupTokensByType';\nexport * from './isTokenWithBalanceAVM';\nexport * from './isTokenWithBalancePVM';\n","import {\n  TokenWithBalance,\n  TokenWithBalanceAVM,\n} from '@avalabs/vm-module-types';\n\nexport const isTokenWithBalanceAVM = (\n  balance?: TokenWithBalance,\n): balance is TokenWithBalanceAVM => {\n  if (!balance) {\n    return false;\n  }\n\n  return 'balancePerType' in balance && 'locked' in balance.balancePerType;\n};\n","import {\n  TokenWithBalance,\n  TokenWithBalancePVM,\n} from '@avalabs/vm-module-types';\n\nexport const isTokenWithBalancePVM = (\n  balance?: TokenWithBalance,\n): balance is TokenWithBalancePVM => {\n  if (!balance) {\n    return false;\n  }\n  return (\n    'balancePerType' in balance && 'lockedStaked' in balance.balancePerType\n  );\n};\n","import { bnToBig } from '@avalabs/core-utils-sdk';\nimport Big from 'big.js';\nimport { BN } from 'bn.js';\n\nexport function bigintToBig(amount: bigint, denomination: number): Big {\n  return bnToBig(new BN(amount.toString()), denomination);\n}\n","import { Blockchain, BridgeConfig } from '@avalabs/core-bridge-sdk';\nimport { Chain } from '@avalabs/bridge-unified';\nimport { ChainId } from '@avalabs/core-chains-sdk';\nimport { NetworkWithCaipId } from '@core/types';\nimport { caipToChainId } from '../caipConversion';\n\nexport const blockchainToNetwork = (\n  blockChain: Blockchain | Chain,\n  networks: NetworkWithCaipId[],\n  bridgeConfig: BridgeConfig,\n  isTestnet?: boolean,\n) => {\n  if (typeof blockChain === 'object') {\n    // We got a Chain from @avalabs/bridge-unified\n    const chain = networks.find(\n      (network) => network.chainId === caipToChainId(blockChain.chainId),\n    );\n\n    if (!chain) {\n      throw new Error('Blockchain not supported');\n    }\n\n    return chain;\n  }\n\n  switch (blockChain) {\n    case Blockchain.AVALANCHE:\n      return networks.find(\n        (network) =>\n          network.chainId ===\n          bridgeConfig.config?.critical.networks[Blockchain.AVALANCHE],\n      );\n    case Blockchain.ETHEREUM: {\n      return networks.find(\n        (network) =>\n          network.chainId ===\n          bridgeConfig.config?.critical.networks[Blockchain.ETHEREUM],\n      );\n    }\n    case Blockchain.BITCOIN:\n      return networks.find((network) => {\n        if (isTestnet === undefined) {\n          return (\n            network.chainId === ChainId.BITCOIN_TESTNET ||\n            network.chainId === ChainId.BITCOIN\n          );\n        }\n        return isTestnet\n          ? network.chainId === ChainId.BITCOIN_TESTNET\n          : network.chainId === ChainId.BITCOIN;\n      });\n    default:\n      throw new Error('Blockchain not supported');\n  }\n};\n\nexport const networkToBlockchain = (\n  network: NetworkWithCaipId | Chain | undefined,\n) => {\n  const chainId =\n    typeof network?.chainId === 'string'\n      ? caipToChainId(network.chainId)\n      : network?.chainId;\n\n  switch (chainId) {\n    case ChainId.AVALANCHE_MAINNET_ID:\n    case ChainId.AVALANCHE_LOCAL_ID:\n    case ChainId.AVALANCHE_TESTNET_ID:\n      return Blockchain.AVALANCHE;\n    case ChainId.ETHEREUM_HOMESTEAD:\n    case ChainId.ETHEREUM_TEST_RINKEBY:\n    case ChainId.ETHEREUM_TEST_GOERLY:\n    case ChainId.ETHEREUM_TEST_SEPOLIA:\n      return Blockchain.ETHEREUM;\n    case ChainId.BITCOIN:\n    case ChainId.BITCOIN_TESTNET:\n      return Blockchain.BITCOIN;\n    default:\n      return Blockchain.UNKNOWN;\n  }\n};\n","import {\n  ExtensionConnectionEvent,\n  UnifiedBridgeEvent,\n  UnifiedBridgeStateUpdateEvent,\n  UnifiedBridgeTransferStepChangeEvent,\n  BridgeEvents,\n  BridgeState,\n  TransferEvent,\n} from '@core/types';\nimport { BridgeConfig } from '@avalabs/core-bridge-sdk';\n\nexport function isBridgeStateUpdateEventListener(\n  evt: ExtensionConnectionEvent<BridgeState>,\n) {\n  return evt.name === BridgeEvents.BRIDGE_STATE_UPDATE_EVENT;\n}\n\nexport function isBridgeConfigUpdateEventListener(\n  evt: ExtensionConnectionEvent<BridgeConfig>,\n) {\n  return evt?.name === BridgeEvents.BRIDGE_CONFIG_UPDATE_EVENT;\n}\n\nexport function isBridgeTransferEventListener(\n  evt: ExtensionConnectionEvent,\n): evt is ExtensionConnectionEvent<TransferEvent> {\n  return evt?.name === BridgeEvents.BRIDGE_TRANSFER_EVENT;\n}\n\nexport const isUnifiedBridgeStateUpdate = (\n  ev: ExtensionConnectionEvent,\n): ev is UnifiedBridgeStateUpdateEvent =>\n  ev.name === UnifiedBridgeEvent.StateUpdated;\n\nexport const isUnifiedBridgeTransferStepChanged = (\n  ev: ExtensionConnectionEvent,\n): ev is UnifiedBridgeTransferStepChangeEvent =>\n  ev.name === UnifiedBridgeEvent.TransferStepChange;\n","import { Network } from '@avalabs/core-chains-sdk';\nimport { BridgeState } from '@core/types';\nimport { isBitcoinNetwork } from '../network/isBitcoinNetwork';\nimport { isAvalancheNetwork } from '../network/isAvalancheNetwork';\nimport { isEthereumNetwork } from '../network/isEthereumNetwork';\nenum BridgeNetwork {\n  AVALANCHE = 'avalanche',\n  BITCOIN = 'bitcoin',\n  ETHEREUM = 'ethereum',\n}\n\n/**\n * Remove bridgeTransactions that don't belong to the given network.\n */\nexport function filterBridgeStateToNetwork(\n  bridge: BridgeState,\n  network: Network,\n): BridgeState {\n  const networkNameToCheck = isBitcoinNetwork(network)\n    ? BridgeNetwork.BITCOIN\n    : isAvalancheNetwork(network)\n      ? BridgeNetwork.AVALANCHE\n      : isEthereumNetwork(network)\n        ? BridgeNetwork.ETHEREUM\n        : null;\n\n  const isMainnet = !network.isTestnet;\n  const bridgeTransactions = Object.values(bridge.bridgeTransactions).reduce<\n    BridgeState['bridgeTransactions']\n  >((txs, btx) => {\n    if (\n      (btx.sourceChain.valueOf() === networkNameToCheck ||\n        btx.targetChain.valueOf() === networkNameToCheck) &&\n      btx.environment === (isMainnet ? 'main' : 'test')\n    ) {\n      txs[btx.sourceTxHash] = btx;\n    }\n    return txs;\n  }, {});\n\n  return { ...bridge, bridgeTransactions };\n}\n","import {\n  BridgeAsset,\n  TokenType as BridgeTokenType,\n} from '@avalabs/bridge-unified';\n\nimport {\n  NftTokenWithBalance,\n  TokenType,\n  TokenWithBalance,\n} from '@avalabs/vm-module-types';\n\nexport const findMatchingBridgeAsset = (\n  assets: BridgeAsset[],\n  token: Exclude<TokenWithBalance, NftTokenWithBalance>,\n): BridgeAsset | undefined => {\n  return assets.find((a) => {\n    if (a.type === BridgeTokenType.NATIVE && token.type === TokenType.NATIVE) {\n      return a.symbol.toLowerCase() === token.symbol.toLowerCase();\n    }\n\n    if (a.type === BridgeTokenType.ERC20 && token.type === TokenType.ERC20) {\n      return a.address.toLowerCase() === token.address.toLowerCase();\n    }\n\n    return false;\n  });\n};\n","import { BridgeTransfer } from '@avalabs/bridge-unified';\nimport { BridgeTransaction } from '@avalabs/core-bridge-sdk';\nimport { isUnifiedBridgeTransfer } from './isUnifiedBridgeTransfer';\n\nexport const getBridgedAssetSymbol = (\n  tx: BridgeTransfer | BridgeTransaction,\n): string => {\n  if (isUnifiedBridgeTransfer(tx)) {\n    return tx.asset.symbol;\n  }\n\n  return tx.symbol;\n};\n","import { Blockchain, getNativeSymbol } from '@avalabs/core-bridge-sdk';\nimport { Chain } from '@avalabs/bridge-unified';\n\nexport const getNativeTokenSymbol = (chain: Blockchain | Chain) => {\n  if (typeof chain === 'object') {\n    return chain.networkToken.symbol;\n  }\n\n  return getNativeSymbol(chain);\n};\n","export * from './blockchainConversion';\nexport * from './findMatchingBridgeAsset';\nexport * from './getBridgedAssetSymbol';\nexport * from './isAddressBlockedError';\nexport * from './isUnifiedBridgeTransfer';\nexport * from './getNativeTokenSymbol';\nexport * from './bridgeEventFilters';\nexport * from './filterBridgeStateToNetwork';\n","import { ErrorReason } from '@avalabs/bridge-unified';\n\nexport const isAddressBlockedError = (err?: unknown) => {\n  return (\n    !!err &&\n    err instanceof Error &&\n    err.message === ErrorReason.ADDRESS_IS_BLOCKED\n  );\n};\n","import { BridgeTransaction } from '@avalabs/core-bridge-sdk';\nimport { BridgeTransfer } from '@avalabs/bridge-unified';\n\nexport const isUnifiedBridgeTransfer = (\n  transfer?: BridgeTransaction | BridgeTransfer,\n): transfer is BridgeTransfer => {\n  return transfer !== undefined && 'type' in transfer;\n};\n","import { BridgeTransaction } from '@avalabs/core-bridge-sdk';\nimport { BridgeTransfer } from '@avalabs/bridge-unified';\nimport { TxHistoryItem } from '@core/types';\n\nexport const ETHEREUM_ADDRESS = '0x0000000000000000000000000000000000000000';\n\nexport function isPendingBridgeTransaction(\n  item: TxHistoryItem | BridgeTransaction | BridgeTransfer,\n): item is BridgeTransaction | BridgeTransfer {\n  return 'addressBTC' in item || 'sourceChain' in item;\n}\n","import {\n  AvalancheCaip2ChainId,\n  BitcoinCaip2ChainId,\n  ChainId,\n} from '@avalabs/core-chains-sdk';\nimport { Avalanche } from '@avalabs/core-wallets-sdk';\nimport { NetworkVMType } from '@avalabs/vm-module-types';\nimport { EnsureDefined, PartialBy, Network } from '@core/types';\n\nexport enum CaipNamespace {\n  AVAX = 'avax',\n  BIP122 = 'bip122',\n  EIP155 = 'eip155',\n  HVM = 'hvm',\n  SOLANA = 'solana',\n}\n\nexport const BitcoinCaipId = {\n  [ChainId.BITCOIN]: BitcoinCaip2ChainId.MAINNET,\n  [ChainId.BITCOIN_TESTNET]: BitcoinCaip2ChainId.TESTNET,\n};\n\nexport const SolanaCaipId = {\n  [ChainId.SOLANA_MAINNET_ID]: `${CaipNamespace.SOLANA}:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp`,\n  [ChainId.SOLANA_DEVNET_ID]: `${CaipNamespace.SOLANA}:EtWTRABZaYq6iMfeYKouRu166VU2xqa1`,\n  [ChainId.SOLANA_TESTNET_ID]: `${CaipNamespace.SOLANA}:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z`,\n};\n\nexport const AvaxLegacyCaipId = {\n  [ChainId.AVALANCHE_P]: `${CaipNamespace.AVAX}:${Avalanche.MainnetContext.pBlockchainID}`,\n  [ChainId.AVALANCHE_X]: `${CaipNamespace.AVAX}:${Avalanche.MainnetContext.xBlockchainID}`,\n  [ChainId.AVALANCHE_TEST_P]: `${CaipNamespace.AVAX}:fuji${Avalanche.FujiContext.pBlockchainID}`,\n  [ChainId.AVALANCHE_TEST_X]: `${CaipNamespace.AVAX}:fuji${Avalanche.FujiContext.xBlockchainID}`,\n};\n\nexport const AvaxCaipId = {\n  [ChainId.AVALANCHE_P]: AvalancheCaip2ChainId.P,\n  [ChainId.AVALANCHE_X]: AvalancheCaip2ChainId.X,\n  [ChainId.AVALANCHE_TEST_P]: AvalancheCaip2ChainId.P_TESTNET,\n  [ChainId.AVALANCHE_TEST_X]: AvalancheCaip2ChainId.X_TESTNET,\n} as const;\n\nexport const getNetworkCaipId = (network: PartialBy<Network, 'caipId'>) => {\n  if (network.caipId) {\n    return network.caipId;\n  } else if (network.caip2Id) {\n    return network.caip2Id;\n  }\n  if (network.vmName === NetworkVMType.EVM) {\n    return `eip155:${network.chainId}`;\n  }\n\n  if (network.vmName === NetworkVMType.BITCOIN) {\n    return BitcoinCaipId[network.chainId];\n  }\n\n  const isXChain = network.vmName === NetworkVMType.AVM;\n  const isPChain = network.vmName === NetworkVMType.PVM;\n\n  if (isXChain || isPChain) {\n    return AvaxCaipId[network.chainId];\n  }\n\n  if (network.vmName === NetworkVMType.HVM) {\n    return `hvm:${network.chainId}`;\n  }\n\n  throw new Error('Unsupported VM type: ' + network.vmName);\n};\n\nexport const caipToChainId = (identifier: string): number => {\n  const [namespace, reference] = identifier.split(':');\n\n  if (!namespace) {\n    throw new Error('No namespace found in identifier: ' + identifier);\n  }\n\n  if (!reference) {\n    throw new Error('No reference found in identifier: ' + identifier);\n  }\n\n  if (namespace === CaipNamespace.EIP155) {\n    return Number(reference);\n  }\n\n  if (reference.length === 32 && namespace === CaipNamespace.HVM) {\n    return parseInt(reference.slice(0, 16), 16);\n  }\n  if (namespace === CaipNamespace.SOLANA) {\n    const chainId = Object.keys(SolanaCaipId).find(\n      (chainIdLookup) => SolanaCaipId[chainIdLookup] === identifier,\n    );\n\n    if (!chainId) {\n      throw new Error('No chainId match for CAIP identifier: ' + identifier);\n    }\n\n    return Number(chainId);\n  }\n  if (namespace === CaipNamespace.BIP122) {\n    const chainId = Object.keys(BitcoinCaipId).find(\n      (chainIdLookup) => BitcoinCaipId[chainIdLookup] === identifier,\n    );\n\n    if (!chainId) {\n      throw new Error('No chainId match for CAIP identifier: ' + identifier);\n    }\n\n    return Number(chainId);\n  }\n\n  if (namespace === CaipNamespace.AVAX) {\n    const chainId = Object.keys(AvaxCaipId).find(\n      (chainIdLookup) =>\n        AvaxCaipId[chainIdLookup] === identifier ||\n        AvaxLegacyCaipId[chainIdLookup] === identifier,\n    );\n\n    if (!chainId) {\n      throw new Error('No chainId match for CAIP identifier: ' + identifier);\n    }\n\n    return Number(chainId);\n  }\n\n  throw new Error('No chainId match for CAIP identifier: ' + identifier);\n};\n\nexport const chainIdToCaip = (chainId: number): string => {\n  return BitcoinCaipId[chainId] ?? AvaxCaipId[chainId] ?? `eip155:${chainId}`;\n};\n\nexport const decorateWithCaipId = (\n  network: Network,\n): EnsureDefined<Network, 'caipId'> => ({\n  ...network,\n  caipId: getNetworkCaipId(network),\n});\n\nexport const getNameSpaceFromScope = (scope?: string | null) => {\n  if (!scope) {\n    return null;\n  }\n  const [namespace] = scope.split(':');\n  return namespace;\n};\nexport const isBitcoinCaipId = (caipId: string) =>\n  (Object.values(BitcoinCaipId) as string[]).includes(caipId);\n","import { TokenUnit } from '@avalabs/core-utils-sdk';\n\ntype GasPriceArgs =\n  | {\n      gasPrice: bigint;\n      maxFeePerGas?: never;\n      maxPriorityFeePerGas?: never;\n    }\n  | {\n      gasPrice?: never;\n      maxFeePerGas: bigint;\n      maxPriorityFeePerGas?: bigint;\n    };\n\ntype Args = GasPriceArgs & {\n  tokenPrice?: number;\n  tokenDecimals?: number;\n  gasLimit?: number;\n};\n\nexport function calculateGasAndFees({\n  gasPrice,\n  maxFeePerGas,\n  maxPriorityFeePerGas,\n  tokenPrice,\n  tokenDecimals = 18,\n  gasLimit,\n}: Args) {\n  const pricePerGas = maxFeePerGas ?? gasPrice;\n\n  if (pricePerGas == null) {\n    throw new Error('Please provide gasPrice or maxFeePerGas parameters');\n  }\n\n  const bnFee = gasLimit ? pricePerGas * BigInt(gasLimit) : pricePerGas;\n  const bnTip =\n    gasLimit && maxPriorityFeePerGas\n      ? maxPriorityFeePerGas * BigInt(gasLimit)\n      : maxPriorityFeePerGas;\n\n  const fee = new TokenUnit(bnFee, tokenDecimals, '');\n  const tip = bnTip ? new TokenUnit(bnTip, tokenDecimals, '') : null;\n  const price = tokenPrice ? new TokenUnit(tokenPrice, 0, '') : null;\n\n  return {\n    maxFeePerGas: maxFeePerGas,\n    gasLimit: gasLimit || 0,\n    feeUnit: fee,\n    fee: fee.toDisplay(),\n    bnFee,\n    feeUSD: price\n      ? price.mul(fee).toDisplay({ fixedDp: 6, asNumber: true })\n      : null,\n    tipUSD:\n      price && tip\n        ? price.mul(tip).toDisplay({ fixedDp: 2, asNumber: true })\n        : null,\n  };\n}\n","import {\n  Account,\n  Balances,\n  NetworkWithCaipId,\n  TotalPriceChange,\n} from '@core/types';\nimport { hasAccountBalances } from './hasAccountBalances';\nimport { getAddressForChain } from './getAddressForChain';\n\nexport function calculateTotalBalance(\n  account?: Partial<Account>,\n  networks?: NetworkWithCaipId[],\n  balances?: Balances,\n) {\n  if (!account || !balances || !networks?.length) {\n    return {\n      sum: null,\n      priceChange: {\n        value: 0,\n        percentage: [],\n      },\n    };\n  }\n\n  const networkDict: Record<number, NetworkWithCaipId> = networks.reduce(\n    (dict, network) => ({\n      ...dict,\n      [network.chainId]: network,\n    }),\n    {},\n  );\n  const chainIdsToSum = new Set(Object.keys(networkDict).map(Number));\n\n  const hasBalances = hasAccountBalances(\n    balances,\n    account,\n    Array.from(chainIdsToSum),\n  );\n\n  if (!hasBalances) {\n    return {\n      sum: null,\n      priceChange: {\n        value: 0,\n        percentage: [],\n      },\n    };\n  }\n\n  const sum = Array.from(chainIdsToSum).reduce(\n    (\n      total: {\n        sum: number;\n        priceChange: TotalPriceChange;\n      },\n      chainId,\n    ) => {\n      const address = getAddressForChain(networkDict[chainId], account);\n\n      if (!address) {\n        return total;\n      }\n\n      const sumValues = Object.values(\n        balances?.[chainId]?.[address] ?? {},\n      )?.reduce(\n        (\n          sumTotal: {\n            sum: number;\n            priceChange: TotalPriceChange;\n          },\n          token,\n        ) => {\n          const percentage = token.priceChanges?.percentage\n            ? [\n                ...sumTotal.priceChange.percentage,\n                token.priceChanges?.percentage,\n              ]\n            : [...sumTotal.priceChange.percentage];\n\n          return {\n            sum: sumTotal.sum + (token.balanceInCurrency ?? 0),\n            priceChange: {\n              value:\n                sumTotal.priceChange.value + (token.priceChanges?.value ?? 0),\n              percentage,\n            },\n          };\n        },\n        { sum: 0, priceChange: { value: 0, percentage: [] } },\n      ) || { sum: 0, priceChange: { value: 0, percentage: [] } };\n\n      return {\n        ...total,\n        sum: total.sum + sumValues.sum,\n        priceChange: {\n          value: sumValues.priceChange.value + total.priceChange.value,\n          percentage: [\n            ...sumValues.priceChange.percentage,\n            ...total.priceChange.percentage,\n          ],\n        },\n      };\n    },\n    { sum: 0, priceChange: { value: 0, percentage: [] } },\n  );\n\n  return sum;\n}\n","import { runtime } from 'webextension-polyfill';\n\nimport { isSyncDomain } from './getSyncDomain';\nimport { isActiveTab } from './isActiveTab';\n\ntype SkipApprovalOptions = {\n  allowInactiveTabs?: boolean;\n  domainWhitelist?: string[];\n};\n\nexport const canSkipApproval = async (\n  domain: string,\n  tabId: number,\n  { allowInactiveTabs, domainWhitelist }: SkipApprovalOptions = {},\n) => {\n  if (!isSyncDomain(domain, domainWhitelist)) {\n    return false;\n  }\n\n  return (\n    allowInactiveTabs ||\n    domain === runtime.id || // chrome.tabs.get(...) does not see extension popup\n    (await isActiveTab(tabId))\n  );\n};\n","export const USDC_ADDRESS_C_CHAIN =\n  '0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e' as const;\n\nexport const USDC_ADDRESS_ETHEREUM =\n  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48' as const;\n\nexport const USDC_ADDRESS_SOLANA =\n  'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' as const;\n\nexport const USDC_ADDRESSES = [\n  USDC_ADDRESS_C_CHAIN,\n  USDC_ADDRESS_ETHEREUM,\n  USDC_ADDRESS_SOLANA,\n] as const;\n","import { Mnemonic } from 'ethers';\n\nexport function createNewMnemonic(): string {\n  const randomBytes = crypto.getRandomValues(new Uint8Array(32));\n  return Mnemonic.entropyToPhrase(randomBytes);\n}\n","// if you want to remove properties from a union ype, you can use this\n// currently working stackoverflow answer: https://stackoverflow.com/questions/57103834/typescript-omit-a-property-from-all-interfaces-in-a-union-but-keep-the-union-s/57103940#57103940\n\nexport type DistributiveOmit<T, K extends keyof any> = T extends any\n  ? Omit<T, K>\n  : never;\n","export const base64ToBase64Url = (b64: string): string => {\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/[=]*$/g, '');\n};\n\nexport const base64UrlToBuffer = (b64url: string): Uint8Array => {\n  const b64 = b64url\n    .replace(/-/g, '+')\n    .replace(/_/g, '/')\n    .replace(/[=]*$/g, '');\n  return Buffer.from(b64, 'base64');\n};\n\nexport function bufferToBase64Url(buffer: ArrayBuffer): string {\n  // buffer to binary string\n  const byteView = new Uint8Array(buffer);\n  let str = '';\n  for (const charCode of byteView) {\n    str += String.fromCharCode(charCode);\n  }\n\n  // binary string to base64\n  const base64String = btoa(str); //Buffer.from(str).toString('base64');\n\n  // base64 to base64url\n  return base64String\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/[=]/g, '');\n}\n","export function isDevelopment() {\n  return process.env.NODE_ENV === 'development';\n}\n\nexport function isProductionBuild() {\n  return process.env.RELEASE === 'production';\n}\n","import { EthereumRpcError, ethErrors } from 'eth-rpc-errors';\nimport { CommonError, ErrorCode } from '@core/types';\n\nexport type ErrorData = {\n  reason: ErrorCode;\n  originalError?: unknown;\n  [key: string]: any;\n};\n\nexport interface WrappedError extends EthereumRpcError<ErrorData> {\n  data: ErrorData;\n}\n\nexport const isWrappedError = (maybeErr: unknown): maybeErr is WrappedError => {\n  return (\n    typeof maybeErr === 'object' &&\n    maybeErr !== null &&\n    'code' in maybeErr &&\n    'data' in maybeErr &&\n    typeof maybeErr.code === 'number' &&\n    typeof maybeErr.data === 'object' &&\n    maybeErr.data !== null &&\n    'reason' in maybeErr.data\n  );\n};\n\nexport function wrapError(\n  fallbackError?: WrappedError | Error | string,\n): (err: unknown) => never {\n  return (err: unknown) => {\n    if (isWrappedError(err)) {\n      throw err;\n    }\n\n    if (isWrappedError(fallbackError)) {\n      throw fallbackError;\n    }\n\n    throw ethErrors.rpc.internal({\n      data: {\n        reason: CommonError.Unknown,\n        originalError: fallbackError ?? err,\n      },\n    });\n  };\n}\n\nexport const isUserRejectionError = (err: any) => {\n  if (!err) {\n    return false;\n  }\n\n  if (typeof err === 'object') {\n    return err.message?.startsWith('User rejected') || err.code === 4001;\n  }\n\n  return false;\n};\n","export * from './errorHelpers';\n","type ExponentialBackoffOptions = {\n  attempt: number; // The current attempt number\n  startsAfter?: number; // The attempt number after which the delay should start increasing.\n  maxDelay?: number; // The maximum delay (in ms), to avoid waiting for ridiculously long time before next attempts.\n};\n\n/**\n * Returns the delay (in milliseconds) before another attempt should start.\n * Runs on power of 2.\n */\nexport const getExponentialBackoffDelay = ({\n  attempt,\n  startsAfter = 3,\n  maxDelay = 30000,\n}: ExponentialBackoffOptions) => {\n  return Math.min(maxDelay, 2 ** Math.max(1, attempt - startsAfter + 1) * 1000);\n};\n","import browser, { Windows } from 'webextension-polyfill';\nimport { Subject } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { ContextContainer } from '@core/types';\n\nconst NOTIFICATION_WIDTH = 375;\nconst NOTIFICATION_HEIGHT = 668;\nconst WINDOWS_SCROLLBAR_WIDTH = 26;\nconst contextToOpenIn = ContextContainer.CONFIRM;\n/**\n * Fired when a window is removed (closed).\n */\nconst windowRemovedSignal = new Subject<number>();\n\n/**\n * Fired when the currently focused window changes. Returns chrome.windows.WINDOW_ID_NONE if\n * all Chrome windows have lost focus. Note: On some Linux window managers, WINDOW_ID_NONE is\n * always sent immediately preceding a switch from one Chrome window to another.\n */\nconst windowFocusChangedSignal = new Subject<number>();\n\n/**\n * Pipe the two events blow into the matching signal. This way we dont create a bunch of listeners\n */\nbrowser.windows.onRemoved.addListener((windowId: number) => {\n  windowRemovedSignal.next(windowId);\n});\n\nbrowser.windows.onFocusChanged.addListener((windowId: number) => {\n  windowFocusChangedSignal.next(windowId);\n});\n\n/**\n * Since we cant get direct events from the window we have to rely on a global events that a window has been\n * closed. Each window or tab created then returns a config with a listener on the global events. The listener\n * filters by the windowId tied to the event. Once that is reached then the consumer is notified and can act accordingly\n *\n * @param info the window configs used to create the window\n * @returns\n */\nfunction createWindowInfoAndEvents(info: Windows.Window) {\n  return {\n    ...info,\n    removed: windowRemovedSignal.pipe(\n      filter((windowId) => windowId === info.id),\n    ),\n    focusChanged: windowRemovedSignal.pipe(\n      filter((windowId) => windowId === info.id),\n    ),\n  };\n}\n\nconst checkForError = () => {\n  const { lastError } = browser.runtime;\n  if (!lastError) {\n    return undefined;\n  }\n  // if it quacks like an Error, its an Error\n  if (lastError.message) {\n    return lastError;\n  }\n  // repair incomplete error object (eg chromium v77)\n  return new Error('Something went wrong.');\n};\n\nexport const openNewTab = async (options: {\n  url: string;\n  selected?: boolean;\n}) => {\n  try {\n    const tab = await browser.tabs.create(options);\n    const error = checkForError();\n    if (error) {\n      throw new Error(error.message);\n    }\n    return tab;\n  } catch (error) {\n    return error;\n  }\n};\n\nexport const openWindow = async (options: Windows.CreateCreateDataType) => {\n  try {\n    const newWindow = await browser.windows.create(options);\n    return createWindowInfoAndEvents(newWindow);\n  } catch (error) {\n    console.error(error);\n    throw new Error('failed to open new window');\n  }\n};\n\nexport const openPopup = async ({\n  url,\n  setSelfAsOpener = false,\n  top = 0,\n  right = 0,\n}) => {\n  const platform = await browser.runtime.getPlatformInfo();\n\n  const isPlatformWindows = platform?.os === 'win';\n  let left = 0;\n  try {\n    const lastFocused = await browser.windows.getLastFocused();\n    // Position window in top right corner of lastFocused window.\n    top = lastFocused.top ? lastFocused.top + top : 0;\n    left =\n      typeof lastFocused.left === 'number' &&\n      typeof lastFocused.width === 'number'\n        ? lastFocused.left + (lastFocused.width - NOTIFICATION_WIDTH) - right\n        : 0;\n  } catch (_) {\n    // do nothing, don't know where the last window is so let's just place it to 0,0\n  }\n\n  return openWindow({\n    url,\n    focused: true,\n    setSelfAsOpener,\n    type: 'popup',\n    height: !isPlatformWindows\n      ? NOTIFICATION_HEIGHT\n      : NOTIFICATION_HEIGHT + WINDOWS_SCROLLBAR_WIDTH,\n    width: !isPlatformWindows\n      ? NOTIFICATION_WIDTH\n      : NOTIFICATION_WIDTH + WINDOWS_SCROLLBAR_WIDTH,\n    left,\n    top,\n  });\n};\n\nexport const openExtensionNewWindow = async (\n  route?: string,\n  queryString?: string,\n) => {\n  let extensionURL = browser.runtime.getURL(contextToOpenIn);\n\n  if (queryString) {\n    extensionURL += `?${queryString}`;\n  }\n\n  if (route) {\n    extensionURL += `#/${route}`;\n  }\n\n  return openPopup({\n    url: extensionURL,\n  });\n};\n\nexport const reload = () => {\n  browser.runtime.reload();\n};\n","import z from 'zod';\nimport type { ZodSchema } from 'zod';\n\nexport async function fetchAndVerify<T extends ZodSchema>(\n  fetchOptions: Parameters<typeof fetch>,\n  schema: T,\n): Promise<z.infer<T>> {\n  const response = await fetch(...fetchOptions);\n\n  if (!response.ok) {\n    throw new Error(`Request failed with status ${response.status}`);\n  }\n\n  const responseJson = await response.json();\n  return schema.parse(responseJson);\n}\n","import { filter, Observable } from 'rxjs';\n\nexport function filterFalseyValues<T = any>() {\n  return (observer: Observable<T>) => observer.pipe(filter((value) => !!value));\n}\n","import { Blockchain } from '@avalabs/core-bridge-sdk';\nimport { TokenWithBalance } from '@avalabs/vm-module-types';\n\nexport function findTokenForAsset(\n  symbol: string,\n  nativeChain: Blockchain,\n  tokens: TokenWithBalance[],\n) {\n  // When the source is Avalanche use the wrapped version of the symbol e.g. BTC.b\n  const wrappedSymbol = getWrappedSymbol(symbol, nativeChain);\n\n  return tokens.find((t) => t.symbol === symbol || t.symbol === wrappedSymbol);\n}\n\nfunction getWrappedSymbol(symbol: string, chain: Blockchain): string {\n  if (chain === Blockchain.ETHEREUM) {\n    return `${symbol}.e`;\n  } else if (chain === Blockchain.BITCOIN) {\n    return `${symbol}.b`;\n  }\n  return symbol;\n}\n","import { BTC_ACCESS_ERROR_PREFIX } from '@core/types';\n\nexport function getFireblocksBtcAccessErrorCode(message: string) {\n  const [, code] = message.split(BTC_ACCESS_ERROR_PREFIX);\n\n  if (typeof code === 'undefined' || code === '') {\n    return null;\n  }\n\n  return parseInt(code);\n}\n","import { FireblocksAccount } from '@core/types';\n\n// If we have the BTC address for a Fireblocks account, that means that we were\n// provided the correct API credentials (otherwise we wouldn't be able to fetch\n// the address).\nexport function isFireblocksApiSupported(account?: FireblocksAccount) {\n  return Boolean(account?.addressBTC);\n}\n","interface GetAccountKey {\n  address: string;\n  isTestnet?: boolean;\n}\n\nexport function getAccountKey({ address, isTestnet }: GetAccountKey) {\n  const accountSuffix = !isTestnet ? '' : '-test';\n  return `${address}${accountSuffix}`;\n}\n","import { NetworkVMType } from '@avalabs/vm-module-types';\n\nimport { Account, NetworkWithCaipId } from '@core/types';\n\nimport { mapAddressesToVMs } from './address';\n\nexport function getAddressForChain(\n  network?: NetworkWithCaipId,\n  account?: Partial<Account>,\n) {\n  if (!network || !account) {\n    return '';\n  }\n\n  return (\n    mapAddressesToVMs(account)[network.vmName satisfies NetworkVMType] ?? ''\n  );\n}\n","export const getCoreWebUrl = (address?: string, networkId?: number) => {\n  const baseCoreWebUrl = process.env.CORE_WEB_BASE_URL;\n  if (!address) {\n    return baseCoreWebUrl;\n  }\n\n  if (address && networkId) {\n    return `${baseCoreWebUrl}/account/${address}?network=${networkId}`;\n  }\n  return `${baseCoreWebUrl}/account/${address}`;\n};\n","import { ChainId } from '@avalabs/core-chains-sdk';\n\nexport function getXPChainIds(isMainnet: boolean) {\n  const xChainId = isMainnet ? ChainId.AVALANCHE_X : ChainId.AVALANCHE_TEST_X;\n  const pChainId = isMainnet ? ChainId.AVALANCHE_P : ChainId.AVALANCHE_TEST_P;\n\n  return [pChainId, xChainId];\n}\n\nexport function getDefaultChainIds(isMainnet: boolean) {\n  return [\n    isMainnet ? ChainId.AVALANCHE_MAINNET_ID : ChainId.AVALANCHE_TESTNET_ID,\n    ...getXPChainIds(isMainnet),\n  ];\n}\n","import { BridgeType } from '@avalabs/bridge-unified';\nimport { FeatureFlags, FeatureGates } from '@core/types';\n\nexport const getEnabledBridgeTypes = (featureFlags: Partial<FeatureFlags>) => {\n  const enabled: BridgeType[] = [];\n\n  if (featureFlags[FeatureGates.UNIFIED_BRIDGE_CCTP]) {\n    enabled.push(BridgeType.CCTP);\n  }\n  if (featureFlags[FeatureGates.UNIFIED_BRIDGE_ICTT]) {\n    enabled.push(BridgeType.ICTT_ERC20_ERC20);\n  }\n  if (featureFlags[FeatureGates.UNIFIED_BRIDGE_AB_EVM]) {\n    enabled.push(BridgeType.AVALANCHE_EVM);\n  }\n  if (featureFlags[FeatureGates.UNIFIED_BRIDGE_AB_BTC_TO_AVA]) {\n    enabled.push(BridgeType.AVALANCHE_BTC_AVA);\n  }\n  if (featureFlags[FeatureGates.UNIFIED_BRIDGE_AB_AVA_TO_BTC]) {\n    enabled.push(BridgeType.AVALANCHE_AVA_BTC);\n  }\n\n  return enabled;\n};\n","import { Blockchain } from '@avalabs/core-bridge-sdk';\nimport { Chain } from '@avalabs/bridge-unified';\nimport { Network } from '@avalabs/core-chains-sdk';\nimport type { NetworkWithCaipId } from '@core/types';\nimport { networkToBlockchain } from './bridge';\n\nfunction getAvalancheExplorerBaseUrl(isMainnet = true) {\n  return isMainnet\n    ? 'https://subnets.avax.network/c-chain'\n    : 'https://subnets-test.avax.network/c-chain';\n}\n\nfunction getAvalancheTxLink(hash: string, isMainnet = true) {\n  const root = getAvalancheExplorerBaseUrl(isMainnet);\n  return `${root}/tx/${hash}`;\n}\n\nfunction getEtherscanLink(txHash: string, isMainnet: boolean) {\n  const root = isMainnet\n    ? 'https://etherscan.io'\n    : 'https://sepolia.etherscan.io';\n  return `${root}/tx/${txHash}`;\n}\n\nfunction getBTCBlockchainLink(txHash: string, isMainnet: boolean) {\n  const env = isMainnet ? 'btc' : 'btc-testnet';\n  return `https://www.blockchain.com/${env}/tx/${txHash}`;\n}\nexport function getExplorerAddress(\n  chain: Blockchain | Chain,\n  txHash: string,\n  isMainnet: boolean,\n  getNetwork: (chainId: string) => NetworkWithCaipId | undefined,\n) {\n  const normalizedChain =\n    typeof chain === 'object' ? networkToBlockchain(chain) : chain;\n\n  switch (normalizedChain) {\n    case Blockchain.AVALANCHE:\n      return getAvalancheTxLink(txHash, isMainnet);\n    case Blockchain.BITCOIN:\n      return getBTCBlockchainLink(txHash, isMainnet);\n    case Blockchain.ETHEREUM:\n      return getEtherscanLink(txHash, isMainnet);\n  }\n\n  if (typeof chain === 'string') {\n    return '#';\n  }\n\n  const network = getNetwork(chain.chainId);\n\n  return network ? getExplorerAddressByNetwork(network, txHash, 'tx') : '#';\n}\n\nexport function getAvalancheAddressLink(hash: string, isMainnet = true) {\n  const root = getAvalancheExplorerBaseUrl(isMainnet);\n\n  return `${root}/address/${hash}`;\n}\n\nexport function getExplorerAddressByNetwork(\n  network: Network,\n  hash: string,\n  hashType: 'address' | 'tx' = 'tx',\n) {\n  try {\n    // Try to respect any query params set on {network.explorerUrl}\n    const baseUrl = new URL(network.explorerUrl);\n    baseUrl.pathname += `/${hashType}/${hash}`;\n    return baseUrl.toString();\n  } catch {\n    return `${network.explorerUrl}/${hashType}/${hash}`;\n  }\n}\n","export function getHexStringToBytes(hex: string): number | null {\n  if (!hex) return null;\n\n  // the first 2 chars can be ignore since it indicates the hexadecimal representation ( -2 )\n  // the reason byte size is calculated this way => F in hex is the biggest number which can be represented with 4 bits (1111)\n  // therefore 2 chars at a time can be represented in 1 byte which is 8 bits\n  // so the byte value of a hex is the half of the character count\n\n  return (hex.length - 2) / 2;\n}\n","import { NftMetadata } from '@core/types';\nimport { ipfsResolverWithFallback } from './ipsfResolverWithFallback';\n\nasync function fetchWithTimeout(uri: string, timeout = 5000) {\n  const controller = new AbortController();\n  setTimeout(() => controller.abort(), timeout);\n\n  return fetch(uri, { signal: controller.signal });\n}\n\nexport async function getNftMetadata(tokenUri: string) {\n  let data: NftMetadata = {};\n  if (!tokenUri) {\n    return {};\n  } else if (tokenUri.startsWith('data:application/json;base64,')) {\n    const value = tokenUri.substring(29);\n    try {\n      const json = Buffer.from(value, 'base64').toString();\n      data = JSON.parse(json);\n    } catch {\n      data = {};\n    }\n  } else {\n    data = await fetchWithTimeout(ipfsResolverWithFallback(tokenUri))\n      .then((r) => r.json())\n      .catch(() => ({}));\n  }\n  return data;\n}\n","import { runtime } from 'webextension-polyfill';\nimport { SYNCED_DOMAINS } from '../constants';\n\nexport const isSyncDomain = (\n  domain: string,\n  exposedDomainList: string[] = [],\n) => {\n  return [runtime.id, ...SYNCED_DOMAINS, ...exposedDomainList].some(\n    (syncDomain) => {\n      // Match exact domains, but also allow subdomains (i.e. develop.core-web.pages.dev)\n      return syncDomain === domain || domain.endsWith(`.${syncDomain}`);\n    },\n  );\n};\n\n/**\n * Returns the extension's ID for synced domains (i.e. the Core Suite apps)\n */\nexport const getSyncDomain = (domain: string) => {\n  return isSyncDomain(domain) ? runtime.id : domain;\n};\n","import { isUserRejectionError } from './errors';\n\n/**\n * Use this util function to distinguish between the user rejecting the\n */\nexport async function handleTxOutcome<T>(txRequestPromise: Promise<T>): Promise<\n  | {\n      isApproved: boolean;\n      result: T;\n      error?: never;\n      hasError: false;\n    }\n  | {\n      isApproved: boolean;\n      result?: never;\n      error: unknown;\n      hasError: true;\n    }\n> {\n  try {\n    const result = await txRequestPromise;\n\n    return {\n      isApproved: true,\n      hasError: false,\n      result,\n    };\n  } catch (err) {\n    return {\n      isApproved: !isUserRejectionError(err),\n      hasError: true,\n      error: err,\n    };\n  }\n}\n","import { Account, Balances } from '@core/types';\nimport { getAllAddressesForAccount } from './account';\n\nexport function hasAccountBalances(\n  balances: Balances,\n  account: Partial<Account>,\n  networkIds: number[],\n) {\n  const accountAddresses = getAllAddressesForAccount(account);\n\n  return Object.entries(balances)\n    .filter(([networkId]) => networkIds.includes(Number(networkId)))\n    .some(([, item]) => {\n      if (!item) {\n        return false;\n      }\n      const balanceAddresses = Object.keys(item);\n\n      return balanceAddresses.some((address) => {\n        return accountAddresses.includes(address);\n      });\n    });\n}\n","import BN from 'bn.js';\n\nimport {\n  TokenWithBalance,\n  TokenWithBalanceBTC,\n} from '@avalabs/vm-module-types';\n\nexport const hasUnconfirmedBalance = (\n  token: TokenWithBalance,\n): token is TokenWithBalanceBTC & { unconfirmedBalance: BN } => {\n  return 'unconfirmedBalance' in token && Boolean(token.unconfirmedBalance);\n};\n","import { Avalanche } from '@avalabs/core-wallets-sdk';\n\nexport const getAvaxAssetId = (isTestnet: boolean) =>\n  isTestnet\n    ? Avalanche.FujiContext.avaxAssetID\n    : Avalanche.MainnetContext.avaxAssetID;\n","export * from './isTxHistoryItem';\nexport * from './getAvaxAssetId';\n","import { NetworkVMType } from '@avalabs/vm-module-types';\nimport { TxHistoryItem } from '@core/types';\n\nexport function isNonXPHistoryItem(\n  tx: TxHistoryItem,\n): tx is TxHistoryItem<\n  Exclude<NetworkVMType, NetworkVMType.AVM | NetworkVMType.PVM>\n> {\n  return tx.vmType !== 'AVM' && tx.vmType !== 'PVM';\n}\n\nexport function isPchainTxHistoryItem(\n  tx: TxHistoryItem,\n): tx is TxHistoryItem<NetworkVMType.PVM> {\n  return tx.vmType === 'PVM';\n}\n","function incrementAndCall<T>(\n  prom: () => Promise<T>,\n  interval = 0,\n): Promise<T | never> {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      prom()\n        .then((res) => resolve(res))\n        .catch((err) => reject(err));\n    }, 500 * interval);\n  });\n}\n/**\n * If we have api requests or fetches that need to be tried a few times in order to get results\n * we expect than we can do an incremental step off before telling the user it failed\n *\n * @param prom\n * @param errorParser\n * @param increment\n * @param maxTries\n * @returns promise result\n */\nexport async function incrementalPromiseResolve<T>(\n  prom: () => Promise<T>,\n  errorParser: (res: any) => boolean,\n  increment = 0,\n  maxTries = 10,\n) {\n  try {\n    const res = await incrementAndCall<T>(prom, increment);\n    if (maxTries === increment + 1) return res;\n    if (errorParser(res)) {\n      return incrementalPromiseResolve(\n        prom,\n        errorParser,\n        increment + 1,\n        maxTries,\n      );\n    }\n    return res;\n  } catch (err) {\n    if (maxTries === increment + 1)\n      throw typeof err === 'string' ? new Error(err) : err;\n    if (errorParser(err)) {\n      return incrementalPromiseResolve(\n        prom,\n        errorParser,\n        increment + 1,\n        maxTries,\n      );\n    }\n    throw typeof err === 'string' ? new Error(err) : err;\n  }\n}\n","export * from './address';\nexport * from './actions/getUpdatedActionData';\nexport * from './accounts';\nexport * from './bridge';\nexport * from './network/getProviderForNetwork';\nexport * from './network/addGlacierAPIKeyIfNeeded';\nexport * from './network/buildGlacierAuthHeaders';\nexport * from './network/isAvalancheNetwork';\nexport * from './network/isAvalanchePchainNetwork';\nexport * from './network/isAvalancheXchainNetwork';\nexport * from './network/isEthereumNetwork';\nexport * from './network/isBitcoinNetwork';\nexport * from './network/isSolanaNetwork';\nexport * from './network/isValidHttpHeader';\nexport * from './getSyncDomain';\nexport * from './createMnemonicPhrase';\nexport * from './errors';\nexport * from './send/btcSendUtils';\nexport * from './calculateTotalBalance';\nexport * from './shouldUseWalletConnectApproval';\nexport * from './object';\nexport * from './hasAccountBalances';\nexport * from './isAddressValid';\nexport * from './isContactValid';\nexport * from './logging';\nexport * from './history';\nexport * from './account';\nexport * from './getEnabledBridgeTypes';\nexport * from './getExplorerAddress';\nexport * from './getNftMetadata';\nexport * from './constants';\nexport * from './keystore';\nexport * from './getAddressForChain';\nexport * from './bridgeTransactionUtils';\nexport * from './seedless/getCubeSigner';\nexport * from './seedless/authenticateWithApple';\nexport * from './seedless/authenticateWithGoogle';\nexport * from './seedless/getOidcTokenProvider';\nexport * from './seedless/getSignerToken';\nexport * from './seedless/fido';\nexport * from './seedless/seedlessEventFilters';\nexport * from './walletConnectEventFilters';\nexport * from './nfts/getSmallImageForNFT';\nexport * from './nfts/metadataParser';\nexport * from './nfts/isNFT';\nexport * from './nfts/nftTypesUtils';\nexport * from './fireblocks/getFireblocksBtcAccessErrorCode';\nexport * from './fireblocks/isFireblocksApiSupported';\nexport * from './canSkipApproval';\nexport * from './onPageActivated';\nexport * from './caipConversion';\nexport * from './findTokenForAsset';\nexport * from './incrementalPromiseResolve';\nexport * from './typeUtils';\nexport * from './assertions';\nexport * from './getHexStringToBytes';\nexport * from './isSupportedBrowser';\nexport * from './calculateGasAndFees';\nexport * from './isTokenMalicious';\nexport * from './updateIfDifferent';\nexport * from './sumByProperty';\nexport * from './newsletter';\nexport * from './normalizeBalance';\nexport * from './lowerCaseKeys';\nexport * from './makeBNLike';\nexport * from './measureDuration';\nexport * from './isLedgerVersionCompatible';\nexport * from './hasUnconfirmedBalance';\nexport * from './ipsfResolverWithFallback';\nexport * from './extensionUtils';\nexport * from './array';\nexport * from './getCoreWebUrl';\nexport * from './stringToBigint';\nexport * from './isActiveTab';\nexport * from './getDefaultChainIds';\nexport * from './jsonRpcEngine';\nexport * from './environment';\nexport * from './exponentialBackoff';\nexport * from './stripAddressPrefix';\nexport * from './handleTxOutcome';\nexport * from './isBtcAddressInNetwork';\nexport * from './isPrimarySubnet';\nexport * from './isSwimmerNetwork';\nexport * from './isBitcoin';\nexport * from './bigintToBig';\nexport * from './seedPhraseValidation';\nexport * from './distributiveomit';\nexport * from './isFailedToFetchError';\nexport * from './encoding';\nexport * from './promiseResolver';\nexport * from './getAccountKey';\nexport * from './noop';\nexport * from './number';\nexport * from './truncateAddress';\nexport * from './filterFalsyValues';\nexport * from './account';\nexport * from './balance';\nexport * from './isLockStateChangedEvent';\nexport * from './isWalletStateUpdateEvent';\nexport * from './fetchAndVerify';\nexport * from './openFullscreenTab';\nexport * from './approveSeedlessRegistration';\n","import { ipfsResolver } from '@avalabs/core-utils-sdk';\n\nexport const IPFS_URL = 'https://ipfs.io';\n\nexport function ipfsResolverWithFallback(\n  sourceUrl: string | undefined,\n  desiredGatewayPrefix: string = IPFS_URL,\n) {\n  if (!sourceUrl) {\n    return '';\n  }\n\n  try {\n    return ipfsResolver(sourceUrl, desiredGatewayPrefix);\n  } catch {\n    return sourceUrl;\n  }\n}\n","import { tabs } from 'webextension-polyfill';\n\nexport const isActiveTab = async (tabId: number) => {\n  try {\n    const tab = await tabs.get(tabId);\n    return Boolean(tab) && tab.active;\n  } catch {\n    return false;\n  }\n};\n","import { isBech32Address } from '@avalabs/core-bridge-sdk';\nimport { isAddress } from 'ethers';\nimport { isAddress as isSvmAddress } from '@solana/kit';\nimport { stripAddressPrefix } from './stripAddressPrefix';\nimport { utils } from '@avalabs/avalanchejs';\n\nexport const isValidAddress = (address: string) => {\n  return !!address.length && isAddress(address);\n};\n\nexport const isValidBtcAddress = (address: string) => {\n  return !!address.length && isBech32Address(address);\n};\n\nexport const isValidPvmAddress = (address: string) => {\n  return isValidXPAddressWithPrefix(address, 'P-');\n};\n\nexport const isValidAvmAddress = (address: string) => {\n  return isValidXPAddressWithPrefix(address, 'X-');\n};\n\nexport const isValidSvmAddress = (address: string) => {\n  return isSvmAddress(address);\n};\n\nfunction isValidXPAddressWithPrefix(value: string, forcedPrefix?: string) {\n  const address =\n    forcedPrefix && !value.startsWith(forcedPrefix)\n      ? `${forcedPrefix}${value}`\n      : value;\n\n  const addressBody = stripAddressPrefix(address);\n  return isValidXPAddress(addressBody);\n}\n\nexport const isValidXPAddress = (address: string) => {\n  try {\n    utils.parseBech32(address);\n\n    return true;\n  } catch {\n    return false;\n  }\n};\n","import { Network, NetworkVMType } from '@avalabs/core-chains-sdk';\n\nexport function isBitcoin(network?: Network) {\n  return network?.vmName === NetworkVMType.BITCOIN;\n}\n","import {\n  isBase58AddressInNetwork,\n  isBech32AddressInNetwork,\n} from '@avalabs/core-bridge-sdk';\n\n/**\n * Check if the given address is a valid Bitcoin address\n * @param address Bitcoin address, bech32 or b58\n * @param isMainnet Verify address against mainnet or testnet\n */\nexport function isBtcAddressInNetwork(address: string, isMainnet: boolean) {\n  return (\n    isBech32AddressInNetwork(address, isMainnet) ||\n    isBase58AddressInNetwork(address, isMainnet)\n  );\n}\n","import type { Contact } from '@avalabs/types';\nimport { isAddress } from 'ethers';\nimport { isBech32Address } from '@avalabs/core-bridge-sdk';\nimport { isValidSvmAddress, isValidXPAddress } from './isAddressValid';\n\nexport const isContactValid = (contact: Contact) => {\n  if (\n    !contact.name ||\n    (!contact.address &&\n      !contact.addressBTC &&\n      !contact.addressXP &&\n      !contact.addressSVM)\n  ) {\n    return { valid: false, reason: 'contact name or address is missing' };\n  }\n\n  const isAddressValid =\n    (!contact.address || isAddress(contact.address)) &&\n    (!contact.addressBTC || isBech32Address(contact.addressBTC)) &&\n    (!contact.addressXP || isValidXPAddress(contact.addressXP)) &&\n    (!contact.addressSVM || isValidSvmAddress(contact.addressSVM));\n\n  if (isAddressValid) {\n    return { valid: true, reason: '' };\n  }\n  return { valid: false, reason: 'address is invalid' };\n};\n","export const isFailedToFetchError = (err: unknown): boolean => {\n  return err instanceof Error && /Failed to fetch/.test(err.message);\n};\n","// ledgerAppVersion >= requiredAppVersion\nexport function isLedgerVersionCompatible(\n  ledgerAppVersion: string,\n  requiredAppVersion: string,\n) {\n  const compare = ledgerAppVersion.localeCompare(\n    requiredAppVersion,\n    undefined,\n    {\n      numeric: true,\n      sensitivity: 'base',\n    },\n  );\n\n  // ledgerAppVersion > requiredAppVersion\n  if (compare === 1) return true;\n  // ledgerAppVersion = requiredAppVersion\n  if (compare === 0) return true;\n  // ledgerAppVersion < requiredAppVersion\n  if (compare === -1) return false;\n}\n","import { ExtensionConnectionEvent, LockEvents } from '@core/types';\n\nexport function isLockStateChangedEvent(\n  evt: ExtensionConnectionEvent<boolean>,\n) {\n  return evt.name === LockEvents.LOCK_STATE_CHANGED;\n}\n","import { Avalanche } from '@avalabs/core-wallets-sdk';\n\nexport function isPrimarySubnet(subnetId: string) {\n  return subnetId === Avalanche.MainnetContext.pBlockchainID;\n}\n","import { Browser, detect } from 'detect-browser';\n\nexport const supportedBrowsers: Browser[] = ['chrome'];\nexport const isSupportedBrowser = () => {\n  const browser = detect();\n  const isSupported = supportedBrowsers.includes(\n    (browser?.name ?? '') as Browser,\n  );\n\n  return isSupported;\n};\n","import { ChainId, Network } from '@avalabs/core-chains-sdk';\n\nexport function isSwimmer(network: Network) {\n  return isSwimmerByChainId(network.chainId);\n}\n\nexport function isSwimmerByChainId(chainId: number) {\n  return !!(chainId === ChainId.SWIMMER || chainId === ChainId.SWIMMER_TESTNET);\n}\n","import { TokenType, TokenWithBalance } from '@avalabs/vm-module-types';\nimport { Erc20TokenBalance } from '@avalabs/glacier-sdk';\nimport { NetworkContractToken } from '@avalabs/core-chains-sdk';\n\nexport const isTokenMalicious = (\n  token: TokenWithBalance | NetworkContractToken,\n) => {\n  if (!('type' in token) || token.type !== TokenType.ERC20) {\n    return false;\n  }\n\n  return token.reputation === Erc20TokenBalance.tokenReputation.MALICIOUS;\n};\n","import {\n  ExtensionConnectionEvent,\n  WalletEvents,\n  WalletDetails,\n} from '@core/types';\n\nexport function isWalletStateUpdateEvent(\n  evt: ExtensionConnectionEvent<WalletDetails[]>,\n) {\n  return evt.name === WalletEvents.WALLET_STATE_UPDATE;\n}\n","import { JsonRpcEngine } from 'json-rpc-engine';\nimport { createFetchMiddleware } from 'eth-json-rpc-middleware';\nimport { Network } from '@avalabs/core-chains-sdk';\nimport { addGlacierAPIKeyIfNeeded } from './network/addGlacierAPIKeyIfNeeded';\n\nexport async function engine(network: Network) {\n  const fetchMiddleware = createFetchMiddleware({\n    get rpcUrl() {\n      return addGlacierAPIKeyIfNeeded(network.rpcUrl);\n    },\n  });\n  const rpcEngine = new JsonRpcEngine();\n  rpcEngine.push(fetchMiddleware);\n  return rpcEngine;\n}\n","/**\n * Helper utilities for encryption and password hashing, browser-safe.\n * Encryption is using AES-GCM with a random public nonce.\n */\n\nimport { sha256 } from '@noble/hashes/sha256';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\n\nconst SALT_SIZE = 16;\n\nconst AES_LENGTH = 256;\n\nconst TAG_LENGTH = 128;\n\nconst KEYGEN_ITERATIONS_V3 = 200000; // v3 and and any version above\n\nconst makeSalt = () => randomBytes(SALT_SIZE);\n\nexport const getHash = (password: string, salt: Uint8Array): Uint8Array =>\n  sha256(concatBytes(utf8ToBytes(password), salt));\n\nexport const calculatePasswordHash = (\n  password: string,\n  salt: Uint8Array,\n): { salt: Uint8Array; hash: Uint8Array } => {\n  let slt: Uint8Array;\n\n  if (salt instanceof Uint8Array) {\n    slt = salt;\n  } else {\n    slt = makeSalt();\n  }\n\n  const hash = getHash(password, getHash(password, slt));\n  return { salt: slt, hash };\n};\n\nconst importKey = async (pwkey: Uint8Array): Promise<CryptoKey> =>\n  crypto.subtle.importKey('raw', pwkey, { name: 'PBKDF2' }, false, [\n    'deriveKey',\n  ]);\n\nconst deriveKey = async (\n  keyMaterial: CryptoKey,\n  salt: Uint8Array,\n  iterations = KEYGEN_ITERATIONS_V3,\n): Promise<CryptoKey> =>\n  crypto.subtle.deriveKey(\n    {\n      name: 'PBKDF2',\n      salt,\n      iterations,\n      hash: 'SHA-256',\n    },\n    keyMaterial,\n    { name: 'AES-GCM', length: AES_LENGTH },\n    false,\n    ['encrypt', 'decrypt'],\n  );\n\nexport const decrypt = async (\n  password: string,\n  ciphertext: Uint8Array,\n  salt: Uint8Array,\n  iv: Uint8Array,\n  keygenIterations?: number,\n): Promise<Uint8Array> => {\n  const pwkey = getHash(password, salt);\n  const keyMaterial = await importKey(pwkey);\n  const pkey = await deriveKey(keyMaterial, salt, keygenIterations);\n\n  const pt = await crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv, // The initialization vector you used to encrypt\n      additionalData: salt, // The additionalData you used to encrypt (if any)\n      tagLength: TAG_LENGTH, // The tagLength you used to encrypt (if any)\n    },\n    pkey, // from importKey above\n    ciphertext, // ArrayBuffer of the data\n  );\n\n  return new Uint8Array(pt);\n};\n","export * from './keystore';\nexport * from './cryptoHelpers';\nexport * as KeystoreFixtures from './keystore-fixtures';\n","/**\n * All of the keys in the files below are for testing purposes only.\n * Do not use them in any other way.\n */\n\nimport KEYSTORE_FILE_V2 from './keystore-v2.json';\nimport KEYSTORE_FILE_V3 from './keystore-v3.json';\nimport KEYSTORE_FILE_V4 from './keystore-v4.json';\nimport KEYSTORE_FILE_V5 from './keystore-v5.json';\nimport KEYSTORE_FILE_V6 from './keystore-v6.json';\nimport KEYSTORE_FILE_V6_PKEY from './keystore-v6-private-key.json';\n\nexport const KEYSTORE_V2 = {\n  file: KEYSTORE_FILE_V2,\n  password: '111111111',\n  expectedKeys: [\n    { key: '2DvMW4ZsNVdiiBsrEdPBTDr47bTtgr4H8qQKXz2D37YKeTLwDw' },\n    { key: '2rr9Fzq87moKGkkJeCjqewGEWY1KW4Na3bnF31GecggLL16XXG' },\n  ],\n  expectedPhrases: [\n    {\n      key: 'patient dragon there taxi husband medal amused push busy draft only axis chat august december essence vintage must liquid zero truck inner potato effort',\n      type: 'mnemonic',\n    },\n    {\n      key: 'visual arctic dune seminar ask balcony mass truly entire surround income battle clump village manual alter purpose various squeeze recipe round fade blame meadow',\n      type: 'mnemonic',\n    },\n  ],\n} as const;\nexport const KEYSTORE_V3 = {\n  file: KEYSTORE_FILE_V3,\n  password: '111111111',\n  expectedKeys: [\n    { key: '2DvMW4ZsNVdiiBsrEdPBTDr47bTtgr4H8qQKXz2D37YKeTLwDw' },\n    { key: '2rr9Fzq87moKGkkJeCjqewGEWY1KW4Na3bnF31GecggLL16XXG' },\n  ],\n  expectedPhrases: [\n    {\n      key: 'patient dragon there taxi husband medal amused push busy draft only axis chat august december essence vintage must liquid zero truck inner potato effort',\n      type: 'mnemonic',\n    },\n    {\n      key: 'visual arctic dune seminar ask balcony mass truly entire surround income battle clump village manual alter purpose various squeeze recipe round fade blame meadow',\n      type: 'mnemonic',\n    },\n  ],\n} as const;\nexport const KEYSTORE_V4 = {\n  file: KEYSTORE_FILE_V4,\n  password: '111111111',\n  expectedKeys: [{ key: 'jegD9bfh1qYjnyxUgnG92CEyAx7s4iZRgcYatdN2u1qhy1Tbr' }],\n  expectedPhrases: [\n    {\n      key: 'general ritual pitch clump tragic entry possible detail case moment fade sleep cabin pig churn solid nation wrestle armor because simple disagree cry meat',\n      type: 'mnemonic',\n    },\n  ],\n} as const;\nexport const KEYSTORE_V5 = {\n  file: KEYSTORE_FILE_V5,\n  password: '111111111',\n  expectedKeys: [\n    {\n      key: 'solar ordinary sentence pelican trim ring indicate cake ordinary water size improve impose gentle frown sound know siren sick elder wait govern tortoise unit',\n    },\n  ],\n  expectedPhrases: [\n    {\n      key: 'solar ordinary sentence pelican trim ring indicate cake ordinary water size improve impose gentle frown sound know siren sick elder wait govern tortoise unit',\n      type: 'mnemonic',\n    },\n  ],\n} as const;\nexport const KEYSTORE_V6 = {\n  file: KEYSTORE_FILE_V6,\n  password: '111111111',\n  expectedPhrases: [\n    {\n      key: 'solar ordinary sentence pelican trim ring indicate cake ordinary water size improve impose gentle frown sound know siren sick elder wait govern tortoise unit',\n      type: 'mnemonic',\n    },\n  ],\n} as const;\nexport const KEYSTORE_V6_PKEY = {\n  file: KEYSTORE_FILE_V6_PKEY,\n  password: '123123123',\n  expectedPhrases: [\n    {\n      key: 'PrivateKey-2NryVJe1H9dqRbJggntZggK7fEmj3QpCHTqadj6i6m4qciANPE',\n      type: 'singleton',\n    },\n  ],\n} as const;\n","import * as bip39 from 'bip39';\nimport { toBytes } from '@noble/hashes/utils';\nimport { utils } from '@avalabs/avalanchejs';\n\nimport {\n  AccessWalletMultipleInput,\n  AllKeyFileDecryptedTypes,\n  AllKeyFileTypes,\n  KeyFileDecryptedV2,\n  KeyFileDecryptedV3,\n  KeyFileDecryptedV4,\n  KeyFileDecryptedV5,\n  KeyFileDecryptedV6,\n  KeyFileV2,\n  KeyFileV3,\n  KeyFileV4,\n  KeyFileV5,\n  KeyFileV6,\n  KeystoreError,\n} from '@core/types';\n\nimport { getHash, decrypt, calculatePasswordHash } from './cryptoHelpers';\n\nexport const KEYSTORE_VERSION = '6.0';\n\nconst KEYGEN_ITERATIONS_V2 = 100000;\n\nasync function readV2(data: KeyFileV2, pass) {\n  const version = data.version;\n\n  const salt = utils.base58check.decode(data.salt);\n\n  const checkHash = getHash(pass, salt);\n  const checkHashString = utils.base58check.encode(toBytes(checkHash));\n\n  if (checkHashString !== data.pass_hash) {\n    throw KeystoreError.InvalidPassword;\n  }\n\n  const decryptedKeys = await Promise.all(\n    data.keys.map(async (keyData) => {\n      const key = utils.base58check.decode(keyData.key);\n      const nonce = utils.base58check.decode(keyData.iv);\n\n      const decryptedKey = await decrypt(\n        pass,\n        key,\n        salt,\n        nonce,\n        KEYGEN_ITERATIONS_V2,\n      );\n\n      return {\n        key: utils.base58check.encode(decryptedKey),\n      };\n    }),\n  );\n\n  return {\n    version,\n    activeIndex: 0,\n    keys: decryptedKeys,\n  };\n}\nasync function readV3(data: KeyFileV3, pass) {\n  const version = data.version;\n\n  const salt = utils.base58check.decode(data.salt);\n\n  const checkHash = await calculatePasswordHash(pass, salt);\n  const checkHashString = utils.base58check.encode(checkHash.hash);\n\n  if (checkHashString !== data.pass_hash) {\n    throw KeystoreError.InvalidPassword;\n  }\n\n  const decryptedKeys = await Promise.all(\n    data.keys.map(async (keyData) => {\n      const key = utils.base58check.decode(keyData.key);\n      const nonce = utils.base58check.decode(keyData.iv);\n\n      const decryptedKey = await decrypt(pass, key, salt, nonce);\n\n      return {\n        key: utils.base58check.encode(decryptedKey),\n      };\n    }),\n  );\n\n  return {\n    version,\n    activeIndex: 0,\n    keys: decryptedKeys,\n  };\n}\nasync function readV4(data: KeyFileV4, pass): Promise<KeyFileDecryptedV5> {\n  const version = data.version;\n\n  const salt = utils.base58check.decode(data.salt);\n  const checkHash = await calculatePasswordHash(pass, salt);\n  const checkHashString = utils.base58check.encode(checkHash.hash);\n\n  if (checkHashString !== data.pass_hash) {\n    throw KeystoreError.InvalidPassword;\n  }\n\n  const decryptedKeys = await Promise.all(\n    data.keys.map(async (keyData) => {\n      const key = utils.base58check.decode(keyData.key);\n      const nonce = utils.base58check.decode(keyData.iv);\n\n      const decryptedKey = await decrypt(pass, key, salt, nonce);\n\n      return {\n        key: utils.base58check.encode(decryptedKey),\n      };\n    }),\n  );\n\n  return {\n    version,\n    activeIndex: 0,\n    keys: decryptedKeys,\n  };\n}\n\nasync function readV5(data: KeyFileV5, pass): Promise<KeyFileDecryptedV5> {\n  const version = data.version;\n\n  const salt = utils.base58check.decode(data.salt);\n\n  const checkHash = await calculatePasswordHash(pass, salt);\n  const checkHashString = utils.base58check.encode(checkHash.hash);\n\n  if (checkHashString !== data.pass_hash) {\n    throw KeystoreError.InvalidPassword;\n  }\n\n  const decoder = new TextDecoder();\n\n  const decryptedKeys = await Promise.all(\n    data.keys.map(async (keyData) => {\n      const key = utils.base58check.decode(keyData.key);\n      const nonce = utils.base58check.decode(keyData.iv);\n\n      return {\n        key: decoder.decode(await decrypt(pass, key, salt, nonce)),\n      };\n    }),\n  );\n\n  return {\n    version,\n    activeIndex: 0,\n    keys: decryptedKeys,\n  };\n}\n\nasync function readV6(data: KeyFileV6, pass): Promise<KeyFileDecryptedV6> {\n  const version = data.version;\n  const activeIndex = data.activeIndex;\n\n  const salt = utils.base58check.decode(data.salt);\n  const decoder = new TextDecoder();\n\n  const decryptedKeys = await Promise.all(\n    data.keys.map(async (keyData) => {\n      const key = utils.base58check.decode(keyData.key);\n      const nonce = utils.base58check.decode(keyData.iv);\n\n      try {\n        return {\n          key: decoder.decode(await decrypt(pass, key, salt, nonce)),\n          type: keyData.type,\n        };\n      } catch (_err) {\n        throw KeystoreError.InvalidPassword;\n      }\n    }),\n  );\n\n  return {\n    version,\n    activeIndex: activeIndex || 0,\n    keys: decryptedKeys,\n  };\n}\n\nexport async function readKeyFile(\n  data: AllKeyFileTypes,\n  pass: string,\n): Promise<AllKeyFileDecryptedTypes> {\n  switch (data.version) {\n    case '6.0':\n      return await readV6(data as KeyFileV6, pass);\n    case '5.0':\n      return await readV5(data as KeyFileV5, pass);\n    case '4.0':\n      return await readV4(data as KeyFileV4, pass);\n    case '3.0':\n      return await readV3(data as KeyFileV3, pass);\n    case '2.0':\n      return await readV2(data as KeyFileV2, pass);\n    default:\n      throw KeystoreError.InvalidVersion;\n  }\n}\n\nfunction extractKeysV2({\n  keys,\n}:\n  | KeyFileDecryptedV2\n  | KeyFileDecryptedV3\n  | KeyFileDecryptedV4): AccessWalletMultipleInput[] {\n  return keys.map((key) => {\n    const keyBuf = Buffer.from(utils.base58check.decode(key.key));\n    const keyHex = keyBuf.toString('hex');\n    const paddedKeyHex = keyHex.padStart(64, '0');\n    const mnemonic = bip39.entropyToMnemonic(paddedKeyHex);\n\n    return {\n      key: mnemonic,\n      type: 'mnemonic',\n    };\n  });\n}\n\nfunction extractKeysV5(file: KeyFileDecryptedV5): AccessWalletMultipleInput[] {\n  return file.keys.map((key) => ({\n    key: key.key,\n    type: 'mnemonic',\n  }));\n}\n\nfunction extractKeysV6(file: KeyFileDecryptedV6): AccessWalletMultipleInput[] {\n  return file.keys.map((key) => ({\n    type: key.type,\n    key: key.key,\n  }));\n}\n\nexport function extractKeysFromDecryptedFile(\n  file: AllKeyFileDecryptedTypes,\n): AccessWalletMultipleInput[] {\n  switch (file.version) {\n    case '6.0':\n      return extractKeysV6(file as KeyFileDecryptedV6);\n    case '5.0':\n      return extractKeysV5(file as KeyFileDecryptedV5);\n    case '4.0':\n      return extractKeysV2(file as KeyFileDecryptedV4);\n    case '3.0':\n      return extractKeysV2(file as KeyFileDecryptedV3);\n    case '2.0':\n      return extractKeysV2(file as KeyFileDecryptedV2);\n    default:\n      throw KeystoreError.InvalidVersion;\n  }\n}\n","import { ExtensionConnectionMessage } from '@core/types';\nimport { Observable, tap } from 'rxjs';\nimport { isDevelopment } from './environment';\nexport const repeat = (str, times) => new Array(times + 1).join(str);\n\nexport const padStart = (num, maxLength, char = ' ') =>\n  repeat(char, maxLength - num.toString().length) + num;\n\nexport const formatTime = (time) => {\n  const h = padStart(time.getHours(), 2, '0');\n  const m = padStart(time.getMinutes(), 2, '0');\n  const s = padStart(time.getSeconds(), 2, '0');\n  const ms = padStart(time.getMilliseconds(), 3, '0');\n  return `${h}:${m}:${s}.${ms}`;\n};\n\nexport const now = () => formatTime(new Date());\n\nconst style = (color, bold = true) => {\n  return `color:${color};font-weight:${bold ? '600' : '300'};font-size:11px`;\n};\n\nexport function formatAndLog(\n  message: string,\n  value: any,\n  config?: {\n    color?: string;\n  },\n) {\n  console.groupCollapsed(\n    '%c%s  %s',\n    style(config?.color ?? '#cccccc'),\n    now(),\n    message,\n  );\n  console.log(value.data ? requestParser(value.data) : responseParser(value));\n  console.groupEnd();\n}\n\nexport function responseParser(response: ExtensionConnectionMessage) {\n  function setKeyAndValue(key: string) {\n    const value = response[key];\n\n    if (key === 'result' || key === 'value') {\n      try {\n        return value ? JSON.parse(value) : value;\n      } catch {\n        return value;\n      }\n    }\n\n    return value;\n  }\n\n  return Object.keys(response).reduce((acc, key) => {\n    acc[key] = setKeyAndValue(key);\n    return acc;\n  }, {});\n}\n\nexport function requestParser(request: ExtensionConnectionMessage) {\n  function setKeyAndValue(key: string) {\n    if (key === 'params') {\n      return `${key}: ${JSON.stringify(request[key] || [])}`;\n    }\n    return `${key}: ${request[key]}`;\n  }\n\n  return Object.keys(request).reduce((acc, key) => {\n    return acc ? `${acc}\\n${setKeyAndValue(key)}` : setKeyAndValue(key);\n  }, ``);\n}\n\nexport function toLogger<T = any>(name: any, showLogs = true) {\n  return (observer: Observable<T>) => {\n    return observer.pipe(tap((value) => showLogs && formatAndLog(name, value)));\n  };\n}\n\nexport function connectionLog(message: string) {\n  console.log('%c%s', style('#F2C53D'), ` connection: ${message}`);\n}\n\nexport function disconnectLog(message: string) {\n  console.log('%c%s', style('#FA981D'), ` disconnected: ${message}`);\n}\n\nexport function responseLog(message: string, value?: any) {\n  if (value.result || value.data?.result || value.result === '') {\n    formatAndLog(` ${message}`, value, { color: '#A6BF4B' });\n  } else if (value.error || value.data?.error) {\n    formatAndLog(` ${message}`, value, { color: '#E3460E' });\n  } else {\n    formatAndLog(` ${message}`, value, { color: '#cccccc' });\n  }\n}\n\nexport function requestLog(message: string, data?: any) {\n  formatAndLog(` ${message}`, data, { color: '#424242' });\n}\n\nexport function eventLog(message: string, data?: any) {\n  formatAndLog(` ${message}`, data, { color: '#598AFA' });\n}\n\nexport function stateLog(data?: any) {\n  // prevent logging sensitive information such as mnemonic or wallet object in production\n\n  if (!isDevelopment()) {\n    return;\n  }\n\n  if (data.walletState.locked) {\n    formatAndLog(` Background State (Locked)`, data, { color: '#E346C5' });\n  } else {\n    formatAndLog(` Background State`, data, { color: '#E346C5' });\n  }\n}\n","export const lowerCaseKeys = <T>(obj: Record<string, T>): Record<string, T> => {\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, value]) => [key.toLowerCase(), value]),\n  );\n};\n","import { BNLike } from 'ethereumjs-util';\nimport { BigNumberish } from 'ethers';\n\nexport function makeBNLike(\n  n: BigNumberish | undefined | null,\n): BNLike | undefined {\n  if (n == null) return undefined;\n  return '0x' + BigInt(n).toString(16);\n}\n","export const measureDuration = (\n  id?: string,\n): {\n  measurementId: string;\n  start: () => void;\n  end: () => number;\n} => {\n  const measurementId = id ?? crypto.randomUUID();\n\n  const start = () => {\n    performance.mark(`${measurementId}-start`);\n  };\n\n  const end = (): number => {\n    const measurement = performance.measure(\n      `${measurementId}-measurement`,\n      `${measurementId}-start`,\n    );\n\n    performance.clearMarks(`${measurementId}-start`);\n    performance.clearMeasures(`${measurementId}-measurement`);\n\n    return measurement.duration;\n  };\n\n  return { measurementId, start, end };\n};\n","export function addGlacierAPIKeyIfNeeded(url: string): string {\n  if (!process.env.GLACIER_URL || !process.env.PROXY_URL) {\n    return url;\n  }\n\n  // RPC urls returned in the token list are always using the production URL\n  const knownHosts = new Set([\n    'glacier-api.avax.network',\n    'proxy-api.avax.network',\n    new URL(process.env.GLACIER_URL).host,\n    new URL(process.env.PROXY_URL).host,\n  ]);\n\n  const urlObject = new URL(url);\n\n  if (process.env.GLACIER_API_KEY && knownHosts.has(urlObject.host)) {\n    urlObject.searchParams.append('token', process.env.GLACIER_API_KEY);\n    return urlObject.toString();\n  }\n\n  return url;\n}\n","import { CustomRpcHeaders } from '@core/types';\n\nexport const buildGlacierAuthHeaders = (apiKey: string): CustomRpcHeaders => {\n  if (!apiKey) {\n    return {};\n  }\n\n  return {\n    'X-Glacier-Api-Key': apiKey,\n  };\n};\n","import {\n  Avalanche,\n  BitcoinProvider,\n  JsonRpcBatchInternal,\n  SolanaProvider,\n  getSolanaProvider,\n} from '@avalabs/core-wallets-sdk';\nimport { NetworkVMType } from '@avalabs/core-chains-sdk';\nimport { FetchRequest, Network as EthersNetwork } from 'ethers';\n\nimport { Network } from '@core/types';\n\nimport { addGlacierAPIKeyIfNeeded } from './addGlacierAPIKeyIfNeeded';\n\nexport type SupportedProvider =\n  | BitcoinProvider\n  | JsonRpcBatchInternal\n  | Avalanche.JsonRpcProvider\n  | SolanaProvider;\n\nexport const getProviderForNetwork = async (\n  network: Network,\n  useMulticall = false,\n): Promise<SupportedProvider> => {\n  if (network.vmName === NetworkVMType.SVM) {\n    return getSolanaProvider({\n      isTestnet: Boolean(network.isTestnet),\n      rpcUrl: network.isTestnet\n        ? 'https://api.devnet.solana.com' // NowNodes does not support Solana Devnet\n        : `${process.env.PROXY_URL}/proxy/nownodes/sol`,\n    });\n  }\n\n  if (network.vmName === NetworkVMType.BITCOIN) {\n    return new BitcoinProvider(\n      !network.isTestnet,\n      undefined,\n      `${process.env.PROXY_URL}/proxy/nownodes/${\n        network.isTestnet ? 'btcbook-testnet' : 'btcbook'\n      }`,\n      `${process.env.PROXY_URL}/proxy/nownodes/${\n        network.isTestnet ? 'btc-testnet' : 'btc'\n      }`,\n      process.env.GLACIER_API_KEY ? { token: process.env.GLACIER_API_KEY } : {},\n    );\n  } else if (network.vmName === NetworkVMType.EVM) {\n    const fetchConfig = new FetchRequest(\n      addGlacierAPIKeyIfNeeded(network.rpcUrl),\n    );\n\n    if (network.customRpcHeaders) {\n      const headers = Object.entries(network.customRpcHeaders);\n\n      for (const [name, value] of headers) {\n        fetchConfig.setHeader(name, value);\n      }\n    }\n\n    const provider = new JsonRpcBatchInternal(\n      useMulticall\n        ? {\n            maxCalls: 40,\n            multiContractAddress: network.utilityAddresses?.multicall,\n          }\n        : 40,\n      fetchConfig,\n      new EthersNetwork(network.chainName, network.chainId),\n    );\n\n    provider.pollingInterval = 2000;\n\n    return provider;\n  } else if (\n    network.vmName === NetworkVMType.AVM ||\n    network.vmName === NetworkVMType.PVM ||\n    network.vmName === NetworkVMType.CoreEth\n  ) {\n    return network.isTestnet\n      ? Avalanche.JsonRpcProvider.getDefaultFujiProvider()\n      : Avalanche.JsonRpcProvider.getDefaultMainnetProvider();\n  } else {\n    throw new Error('unsupported network');\n  }\n};\n","import { Network, ChainId } from '@avalabs/core-chains-sdk';\n\nexport function isAvalancheNetwork(network: Network) {\n  return isAvalancheChainId(network.chainId);\n}\n\nexport function isAvalancheChainId(chainId: number) {\n  return (\n    ChainId.AVALANCHE_MAINNET_ID === chainId ||\n    ChainId.AVALANCHE_LOCAL_ID === chainId ||\n    ChainId.AVALANCHE_TESTNET_ID === chainId\n  );\n}\n","import { ChainId, Network, NetworkVMType } from '@avalabs/core-chains-sdk';\n\nexport function isPchainNetwork(network?: Network) {\n  if (!network) {\n    return false;\n  }\n  return network.vmName === NetworkVMType.PVM;\n}\n\nexport function isPchainNetworkId(chainId: number) {\n  return (\n    ChainId.AVALANCHE_P === chainId || ChainId.AVALANCHE_TEST_P === chainId\n  );\n}\n","import { ChainId, Network, NetworkVMType } from '@avalabs/core-chains-sdk';\n\nexport function isXchainNetwork(network?: Network) {\n  if (!network) {\n    return false;\n  }\n  return network.vmName === NetworkVMType.AVM;\n}\n\n//TODO: Fix this once we figure out how to separate between x and p chain ID\nexport function isXchainNetworkId(chainId: number) {\n  return (\n    ChainId.AVALANCHE_X === chainId || ChainId.AVALANCHE_TEST_X === chainId\n  );\n}\n","import { Network, ChainId } from '@avalabs/core-chains-sdk';\n\nexport function isBitcoinNetwork(network: Network) {\n  return isBitcoinChainId(network.chainId);\n}\n\nexport function isBitcoinChainId(chainId: number) {\n  return ChainId.BITCOIN === chainId || ChainId.BITCOIN_TESTNET === chainId;\n}\n","import { Network, ChainId } from '@avalabs/core-chains-sdk';\n\nexport function isEthereumNetwork(network: Network) {\n  return isEthereumChainId(network.chainId);\n}\n\nexport function isEthereumChainId(chainId: number) {\n  return (\n    ChainId.ETHEREUM_HOMESTEAD === chainId ||\n    ChainId.ETHEREUM_TEST_GOERLY === chainId ||\n    ChainId.ETHEREUM_TEST_RINKEBY === chainId ||\n    ChainId.ETHEREUM_TEST_SEPOLIA === chainId\n  );\n}\n","import { Network, ChainId } from '@avalabs/core-chains-sdk';\n\nexport function isSolanaNetwork(network?: Network) {\n  return network ? isSolanaChainId(network.chainId) : false;\n}\n\nexport function isSolanaChainId(chainId: number) {\n  return (\n    ChainId.SOLANA_DEVNET_ID === chainId ||\n    ChainId.SOLANA_MAINNET_ID === chainId ||\n    ChainId.SOLANA_TESTNET_ID === chainId\n  );\n}\n","export const isValidHttpHeader = (name: string, value: string) => {\n  try {\n    new Headers({\n      [name]: value,\n    });\n    return true;\n  } catch {\n    return false;\n  }\n};\n","export function isNewsletterConfigured() {\n  return Boolean(\n    process.env.NEWSLETTER_BASE_URL &&\n      process.env.NEWSLETTER_PORTAL_ID &&\n      process.env.NEWSLETTER_FORM_ID,\n  );\n}\n\nexport async function signUpForNewsletter(\n  data: Record<string, string>,\n): Promise<Response> {\n  if (!isNewsletterConfigured()) {\n    throw new Error('Newsletter is not configured');\n  }\n\n  const proxyURl = `${process.env.NEWSLETTER_BASE_URL}/v1/hs/forms/${process.env.NEWSLETTER_PORTAL_ID}/${process.env.NEWSLETTER_FORM_ID}`;\n\n  const headers = {\n    Accept: '*',\n    'Content-Type': 'application/json',\n  };\n  const requestOptions = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(data),\n  };\n\n  return fetch(proxyURl, requestOptions);\n}\n","import { ipfsResolverWithFallback } from '../ipsfResolverWithFallback';\n\nconst COVALENT_IMG_SIZER =\n  'https://image-proxy.svc.prod.covalenthq.com/cdn-cgi/image';\n\n/**\n * Covalent has an on the fly image resizer, it resolves image urls then resizes the image.\n *\n * This allows us to request smaller images depending on the UI needs\n *\n * @param imgUrl the url of the image to convert to size\n * @returns The url to the image which is sized at the time of request\n */\nexport function getSmallImageForNFT(\n  imgUrl: string,\n  imageSize: '256' | '512' | '1024' = '256',\n) {\n  const url = ipfsResolverWithFallback(imgUrl);\n  return `${COVALENT_IMG_SIZER}/width=${imageSize},fit/${url}`;\n}\n","import {\n  NftTokenWithBalance,\n  TokenType,\n  TokenWithBalance,\n} from '@avalabs/vm-module-types';\n\nexport function isNftTokenType(type: TokenType) {\n  return type === TokenType.ERC721 || type === TokenType.ERC1155;\n}\n\nexport function isNFT(token: TokenWithBalance): token is NftTokenWithBalance {\n  return isNftTokenType(token.type);\n}\n","import { RawTokenAttribute, TokenAttribute } from '@core/types';\n\nexport const parseAttributes = (attributes) => {\n  return Array.isArray(attributes)\n    ? parseRawAttributesArray(attributes)\n    : attributes === 'string'\n      ? parseRawAttributesString(attributes)\n      : attributes;\n};\n\nexport const parseRawAttributesString = (rawAttributesString?: string) => {\n  if (rawAttributesString === undefined) return [];\n  const rawAttributes: RawTokenAttribute[] = rawAttributesString\n    ? JSON.parse(rawAttributesString)\n    : [];\n\n  const parsedAttributes = rawAttributes.reduce(\n    (acc: TokenAttribute[], attr) => [\n      ...acc,\n      {\n        name: attr.name ?? attr.trait_type,\n        value: attr.value,\n      },\n    ],\n    [],\n  );\n\n  return parsedAttributes;\n};\n\nconst parseRawAttributesArray = (\n  rawAttributesArray:\n    | { trait_type?: string; name?: string; value: string }[]\n    | undefined,\n) => {\n  if (rawAttributesArray === undefined) return [];\n\n  const parsedAttributes = rawAttributesArray.map((attr) => {\n    return {\n      name: attr.name ?? attr.trait_type,\n      value: attr.value,\n    };\n  });\n\n  return parsedAttributes;\n};\n","import {\n  Erc1155TokenBalance,\n  Erc721TokenBalance,\n  ListErc1155BalancesResponse,\n} from '@avalabs/glacier-sdk';\n\nexport function is1155Response(\n  item,\n): item is PromiseFulfilledResult<ListErc1155BalancesResponse> {\n  return Object.keys(item.value).includes('erc1155TokenBalances');\n}\n\nexport function isErc721TokenBalance(\n  token: Erc721TokenBalance | Erc1155TokenBalance,\n): token is Erc721TokenBalance {\n  return token.ercType === Erc721TokenBalance.ercType.ERC_721;\n}\n","export const noop = () => {\n  // noop for testing puposes\n};\n","import { bnToBig } from '@avalabs/core-utils-sdk';\nimport type Big from 'big.js';\nimport { isBN } from 'bn.js';\nimport type BN from 'bn.js';\n\nimport { bigintToBig } from './bigintToBig';\n\nexport function normalizeBalance(\n  balance: BN | Big | bigint | undefined,\n  decimals: number,\n): Big | undefined {\n  if (isBN(balance)) {\n    return bnToBig(balance, decimals);\n  }\n\n  if (typeof balance === 'bigint') {\n    return bigintToBig(balance, decimals);\n  }\n\n  return balance;\n}\n","export function toPrecision(num: string, precision = 4) {\n  const [leftSide, rightSide] = num.split('.');\n\n  if (!rightSide) {\n    return leftSide;\n  }\n\n  return `${leftSide}.${rightSide.substring(0, precision)}`;\n}\n","import { EnsureDefined, ExcludeUndefined } from '@core/types';\n\nexport const omitUndefined = <T extends Record<PropertyKey, unknown>>(obj: T) =>\n  Object.fromEntries(\n    Object.entries(obj).filter(([, value]) => value !== undefined),\n  ) as ExcludeUndefined<T>;\n\nexport const hasDefined = <T extends object, K extends keyof T>(\n  obj: T,\n  key: K,\n): obj is EnsureDefined<T, K> => {\n  return obj[key] !== undefined;\n};\n","/**\n * Pre-rendering causes some issues with the way the extension\n * communicates with dApps. Namely, when the page is first pre-rendered,\n * content scripts are injected before the page is activated\n * by the user. Then when the user finally activates it, the connection\n * gets lost.\n *\n * This util is useful for only running certain actions after the page\n * has been activated by the user. This ensures that the connection\n * remains active.\n *\n * References:\n * https://developer.chrome.com/blog/prerender-pages/\n * https://developer.chrome.com/blog/extension-instantnav/#lifecyle\n */\nexport function onPageActivated(callback) {\n  // eslint-disable-next-line\n  // @ts-ignore\n  if (document.prerendering) {\n    document.addEventListener('prerenderingchange', callback, { once: true });\n  } else {\n    callback();\n  }\n}\n","import { tabs } from 'webextension-polyfill';\n\nexport const openFullscreenTab = (url: string) => {\n  tabs.create({\n    url: `/fullscreen.html#/${url}`,\n  });\n};\n","export function resolve<T = any>(promise: Promise<T>) {\n  try {\n    return promise.then((res) => [res, null]).catch((err) => [null, err]);\n  } catch (err) {\n    return Promise.resolve([null, err]);\n  }\n}\n","import { Mnemonic } from 'ethers';\n\nexport const wordPhraseLength = [12, 18, 24];\n\nexport const isPhraseCorrect = (phrase: string) => {\n  const trimmed = phrase.trim().split(/\\s+/g);\n\n  return (\n    wordPhraseLength.includes(trimmed.length) &&\n    Mnemonic.isValidMnemonic(trimmed.join(' ').toLowerCase())\n  );\n};\n","import { launchWebAuthFlow } from './launchWebAuthFlow';\n\nexport async function authenticateWithApple(): Promise<string> {\n  const clientId = process.env.APPLE_OAUTH_CLIENT_ID;\n  const redirectUrl = process.env.APPLE_OAUTH_REDIRECT_URL;\n\n  // This is the base URL that the Core Seedless API should redirect to after receiving the data from Apple.\n  const baseUrl = 'https://' + chrome.runtime.id + '.chromiumapp.org';\n\n  if (!clientId || !redirectUrl) {\n    throw new Error('Apple OAuth not configured');\n  }\n\n  const url = new URL('https://appleid.apple.com/auth/authorize');\n\n  url.searchParams.set('client_id', clientId);\n  url.searchParams.set('nonce', crypto.randomUUID());\n  url.searchParams.set('response_type', 'code id_token');\n  url.searchParams.set('state', baseUrl);\n  url.searchParams.set('redirect_uri', redirectUrl);\n  url.searchParams.set('scope', 'email');\n  // \"form_post\" response mode is forced since we request user's email in \"scope\".\n  // Reference: https://developer.apple.com/documentation/sign_in_with_apple/request_an_authorization_to_the_sign_in_with_apple_server#query-parameters\n  url.searchParams.set('response_mode', 'form_post');\n\n  return launchWebAuthFlow(url);\n}\n","import { launchWebAuthFlow } from './launchWebAuthFlow';\n\nexport async function authenticateWithGoogle(): Promise<string> {\n  const manifest = chrome.runtime.getManifest();\n\n  if (!manifest.oauth2 || !manifest.oauth2.scopes) {\n    throw new Error('Oauth not configured');\n  }\n\n  const redirectUri = 'https://' + chrome.runtime.id + '.chromiumapp.org';\n  const url = new URL('https://accounts.google.com/o/oauth2/auth');\n\n  url.searchParams.set('client_id', manifest.oauth2.client_id);\n  url.searchParams.set('response_type', 'id_token');\n  url.searchParams.set('redirect_uri', redirectUri);\n  url.searchParams.set('scope', manifest.oauth2.scopes.join(' '));\n\n  return launchWebAuthFlow(url);\n}\n","import { FIDOApiEndpoint, FIDOApiRequest } from '@core/types';\nimport { bufferToBase64Url } from '../../encoding';\n\nexport function convertRequest(\n  endpoint: FIDOApiEndpoint,\n  options: FIDOApiRequest,\n): string {\n  if (\n    endpoint === FIDOApiEndpoint.Authenticate ||\n    endpoint === FIDOApiEndpoint.Register\n  ) {\n    return JSON.stringify(options, convertBuffersToBase64Url);\n  }\n\n  throw new Error('Unsupported FIDO identity endpoint');\n}\n\nfunction convertBuffersToBase64Url(\n  this: Record<string, unknown>,\n  key: string,\n  value: any,\n) {\n  const el = this[key];\n\n  if (el instanceof Buffer) {\n    return bufferToBase64Url(el);\n  }\n\n  return value;\n}\n","import { cloneDeep, get, update } from 'lodash';\n\nimport { DecodedFIDOResult, EncodedFIDOResult } from '@core/types';\nimport { base64UrlToBuffer } from '../../encoding';\n\n// Result properties that are known to contain Base64Url-encoded\n// values. We need these values to be converted back to Buffers\n// to satisfy CubeSigner's SDK.\nconst KNOWN_BUFFER_PROPERTIES = [\n  'rawId',\n  'response.clientDataJSON',\n  'response.attestationObject',\n  'response.authenticatorData',\n  'response.signature',\n  'response.userHandle',\n];\n\nexport function convertResult(result: EncodedFIDOResult): DecodedFIDOResult {\n  const copy = cloneDeep(result);\n\n  KNOWN_BUFFER_PROPERTIES.forEach((path) => {\n    // If object does not contain given property or it is nullish,\n    // do nothing with it.\n    const currentValue = get(copy, path);\n\n    if (currentValue === undefined || currentValue === null) {\n      return;\n    }\n\n    // Otherwise, convert it to Buffer\n    update(copy, path, base64UrlToBuffer);\n  });\n\n  return copy as unknown as DecodedFIDOResult;\n}\n","export * from './convertRequest';\nexport * from './convertResult';\nexport * from './validateResponse';\nexport * from './launchFidoFlow';\nexport * from './seedless-utils';\n","import { windows } from 'webextension-polyfill';\n\nimport {\n  DecodedFIDOResult,\n  FIDOApiEndpoint,\n  FIDOApiRequest,\n  KeyType,\n} from '@core/types';\nimport { convertRequest } from './convertRequest';\nimport { convertResult } from './convertResult';\nimport { isValidResponse } from './validateResponse';\nimport { openPopup } from '../../extensionUtils';\n\nexport async function launchFidoFlow(\n  endpoint: FIDOApiEndpoint,\n  challenge: FIDOApiRequest,\n  keyType?: KeyType,\n): Promise<DecodedFIDOResult> {\n  const baseUrl = process.env.SEEDLESS_FIDO_IDENTITY_URL;\n\n  if (!baseUrl) {\n    throw new Error('FIDO Identity Service URL is not configured');\n  }\n\n  const url = new URL(baseUrl);\n  url.pathname = endpoint;\n  url.searchParams.set('responseMode', 'post-message');\n  url.searchParams.set('origin', location.origin);\n  url.searchParams.set('options', convertRequest(endpoint, challenge));\n\n  if (endpoint === FIDOApiEndpoint.Register) {\n    if (!keyType) {\n      throw new Error('FIDO key type not defined for registration request');\n    }\n\n    url.searchParams.set('keyType', keyType);\n  }\n\n  const popup = await openPopup({\n    url: url.toString(),\n    setSelfAsOpener: true,\n    right: 70,\n  });\n\n  // Make sure to close the popup if the calling window gets closed\n  window.addEventListener('beforeunload', () => {\n    if (popup?.id) {\n      windows.remove(popup.id).catch(() => {\n        // Do nothing, we can't really do anything about it and\n        // the most likely reason of error is that it was already closed.\n      });\n    }\n  });\n\n  return new Promise((resolve, reject) => {\n    // Throw error if popup is closed prematurely\n    const closeSubscription = popup.removed.subscribe(() => {\n      reject(new Error('Popup closed'));\n    });\n\n    const onResponse = (event: MessageEvent) => {\n      if (event.origin !== url.origin) {\n        return;\n      }\n\n      const response = JSON.parse(event.data);\n\n      if (isValidResponse(endpoint, response)) {\n        // Popup can now be closed safely\n        closeSubscription.unsubscribe();\n        if (popup?.id) {\n          windows.remove(popup.id).then(() => {\n            // Do nothing, we can't really do anything about it and\n            // the most likely reason of error is that it was already closed.\n          });\n        }\n        window.removeEventListener('message', onResponse);\n\n        resolve(convertResult(response));\n      }\n    };\n\n    window.addEventListener('message', onResponse);\n  });\n}\n","import {\n  SignerSession,\n  UserExportInitResponse,\n} from '@cubist-labs/cubesigner-sdk';\nimport { ArrayElement, MfaRequestType, RecoveryMethod } from '@core/types';\n\nexport const isTokenExpiredError = (\n  err: unknown,\n): err is Error & { status: 403 } => {\n  // When CubeSigner's refresh token (or the entire session) expires,\n  // we get a 403 Forbidden error on attempted API calls.\n  return err instanceof Error && 'status' in err && err.status === 403;\n};\n\nexport const isFailedMfaError = (\n  err: unknown,\n): err is Error & { status: 403 } => {\n  // When CubeSigner's refresh token (or the entire session) expires,\n  // we get a 403 Forbidden error on attempted API calls.\n  return (\n    err instanceof Error &&\n    'status' in err &&\n    err.status === 403 &&\n    err.message.includes('Invalid')\n  );\n};\n\nexport const isExportRequestOutdated = (\n  exportRequest: UserExportInitResponse,\n) => exportRequest.exp_epoch <= Date.now() / 1000;\n\nexport const mapMfasToRecoveryMethods = (\n  method: ArrayElement<Awaited<ReturnType<SignerSession['user']>>['mfa']>,\n): RecoveryMethod => {\n  if (method.type === 'fido') {\n    return {\n      ...method,\n      type: MfaRequestType.Fido,\n    };\n  }\n\n  return {\n    type: MfaRequestType.Totp,\n  };\n};\n","import Joi from 'joi';\nimport {\n  EncodedFIDOAuthenticationResult,\n  EncodedFIDORegistrationResult,\n  FIDOApiEndpoint,\n} from '@core/types';\nimport { Monitoring } from '../../..';\n\nconst REGISTRATION_RESPONSE_SCHEMA = Joi.object<\n  EncodedFIDORegistrationResult,\n  true\n>({\n  id: Joi.string().required(),\n  rawId: Joi.string().required(),\n  type: Joi.string(),\n  response: Joi.object<EncodedFIDORegistrationResult['response'], true>({\n    attestationObject: Joi.string().required(),\n    clientDataJSON: Joi.string().required(),\n  }).unknown(true),\n}).unknown(true);\n\nconst AUTHENTICATION_RESPONSE_SCHEMA = Joi.object<\n  EncodedFIDOAuthenticationResult,\n  true\n>({\n  id: Joi.string().required(),\n  rawId: Joi.string().required(),\n  type: Joi.string(),\n  response: Joi.object<EncodedFIDOAuthenticationResult['response'], true>({\n    authenticatorData: Joi.string().required(),\n    clientDataJSON: Joi.string().required(),\n    signature: Joi.string().required(),\n    userHandle: Joi.string().allow(null),\n  }).unknown(true),\n}).unknown(true);\n\nexport const isValidResponse = (\n  endpoint: FIDOApiEndpoint,\n  response: unknown,\n) => {\n  // The schemas allow additional properties to be defined,\n  // but we care about the ones that are specified in the schema.\n  const schema =\n    endpoint === FIDOApiEndpoint.Authenticate\n      ? AUTHENTICATION_RESPONSE_SCHEMA\n      : REGISTRATION_RESPONSE_SCHEMA;\n  const { error } = schema.validate(response);\n\n  if (error) {\n    const messages = error.details.map(({ message }) => message);\n    Monitoring.sentryCaptureException(\n      new Error(`Invalid Identity API response: ${messages.join(' | ')}`),\n      Monitoring.SentryExceptionTypes.SEEDLESS,\n    );\n\n    return false;\n  }\n\n  return true;\n};\n","import {\n  CubeSignerResponse,\n  EnvInterface,\n  MfaReceipt,\n  NewSessionResponse,\n  OidcClient,\n  SignerSession,\n  SignerSessionData,\n  SignerSessionManager,\n  envs,\n} from '@cubist-labs/cubesigner-sdk';\n\n/**\n * Get the CubeSigner deployment environment to use.\n *\n * Defaults to 'gamma' but can be overridden via the 'CUBESIGNER_ENV' environment variable.\n *\n * @return {EnvInterface} CubeSigner deployment environment\n */\nexport function getEnv(): EnvInterface {\n  return envs[process.env.CUBESIGNER_ENV || 'gamma'];\n}\n\n/**\n * Get the ID of the CubeSigner organization to use.\n *\n * Must be set via the 'SEEDLESS_ORG_ID' environment variable.\n *\n * @return {string} The ID of the organization in CubeSigner.\n */\nexport function getOrgId(): string {\n  const orgId = process.env.SEEDLESS_ORG_ID;\n  if (!orgId) {\n    throw new Error('SEEDLESS_ORG_ID must be set');\n  }\n  return orgId;\n}\n\n/**\n * Create a CubeSigner API client for methods that require OIDC authorization.\n *\n * This client can be used to:\n * - obtain a proof of identity (see {@link OidcClient.identityProve})\n * - obtain a full CubeSigner session (see {@link OidcClient.sessionCreate})\n *\n * @param {string} oidcToken The OIDC token to include in 'Authorization' header.\n * @return {OidcClient} CubeSigner API client for methods that require OIDC authorization.\n */\nexport function getOidcClient(oidcToken: string): OidcClient {\n  return new OidcClient(getEnv(), getOrgId(), oidcToken);\n}\n\n/**\n * Create a CubeSigner API client for methods that require signer session authorization.\n *\n * @param {NewSessionResponse | SignerSessionData} sessionInfo Signer session information\n *  (e.g., obtained via {@link OidcClient.sessionCreate}) from which to construct the client.\n * @return {SignerSession} CubeSigner API client.\n */\nexport async function getSignerSession(\n  sessionInfo: NewSessionResponse | SignerSessionData,\n): Promise<SignerSession> {\n  return new SignerSession(\n    await SignerSessionManager.createFromSessionInfo(\n      getEnv(),\n      getOrgId(),\n      sessionInfo,\n    ),\n  );\n}\n\n/**\n * Request a new CubeSigner session by logging in via OIDC.\n *\n * The new session can be passed to {@link getSignerSession} to create a CubeSigner API client.\n *\n * @param {string} oidcToken The OIDC token to include in 'Authorization' header.\n * @param {MfaReceipt | undefined} mfaReceipt Optional MFA receipt to attach to this request.\n * @return {CubeSignerResponse<SignerSessionData>} The response. If MFA for this request is\n *   required, {@link CubeSignerResponse.requiresMfa()} is set to true and\n *   {@link CubeSignerResponse.mfaSessionInfo()} contains a temporary session that allows\n *   access to the CubeSigner MFA endpoints; otherwise, {@link CubeSignerResponse.data()}\n *   contains the new session information.\n */\nexport async function requestOidcAuth(\n  oidcToken: string,\n  mfaReceipt?: MfaReceipt | undefined,\n): Promise<CubeSignerResponse<SignerSessionData>> {\n  const oidcClient = getOidcClient(oidcToken);\n  return await oidcClient.sessionCreate(\n    ['sign:*', 'manage:*', 'export:*'],\n    {\n      // How long singing with a particular token works from the token creation\n      auth_lifetime: 5 * 60, // 5 minutes\n      // How long a refresh token is valid, the user has to unlock Core in this timeframe otherwise they will have to re-login\n      // Sessions expire either if the session lifetime expires or if a refresh token expires before a new one is generated\n      refresh_lifetime: 90 * 24 * 60 * 60, // 90 days\n      // How long till the user absolutely must sign in again\n      session_lifetime: 1 * 365 * 24 * 60 * 60, // 1 year\n    },\n    mfaReceipt,\n  );\n}\n","import { SeedlessAuthProvider } from '@core/types';\nimport { authenticateWithGoogle } from './authenticateWithGoogle';\nimport { authenticateWithApple } from './authenticateWithApple';\n\nexport type OidcTokenGetter = () => Promise<string>;\n\nconst SUPPORTED_PROVIDERS: Record<SeedlessAuthProvider, OidcTokenGetter> = {\n  [SeedlessAuthProvider.Google]: authenticateWithGoogle,\n  [SeedlessAuthProvider.Apple]: authenticateWithApple,\n};\n\nexport const getOidcTokenProvider = (\n  authProvider?: SeedlessAuthProvider,\n): OidcTokenGetter | never => {\n  if (!authProvider || !SUPPORTED_PROVIDERS[authProvider]) {\n    throw new Error(`Unsupported provider: ${authProvider || 'unknown'}`);\n  }\n\n  return SUPPORTED_PROVIDERS[authProvider];\n};\n","import {\n  CubeSigner,\n  SignerSessionData,\n  SignerSessionManager,\n  envs,\n} from '@cubist-labs/cubesigner-sdk';\n\nexport const getSignerToken = async (\n  oidcAuthResponse: Awaited<ReturnType<CubeSigner['oidcLogin']>>,\n): Promise<SignerSessionData> => {\n  const sessionInfo = oidcAuthResponse.data();\n  const sessionMgr = await SignerSessionManager.createFromSessionInfo(\n    envs[process.env.CUBESIGNER_ENV || ''],\n    process.env.SEEDLESS_ORG_ID || '',\n    sessionInfo,\n  );\n\n  return sessionMgr.storage.retrieve();\n};\n","export function launchWebAuthFlow(url: URL): Promise<string> {\n  return new Promise((resolve, reject) => {\n    chrome.identity.launchWebAuthFlow(\n      {\n        url: url.toString(),\n        interactive: true,\n      },\n      (redirectedTo) => {\n        if (!redirectedTo) {\n          reject(new Error('Redirect url is undefined'));\n          return;\n        }\n\n        if (chrome.runtime.lastError) {\n          // Example: Authorization page could not be loaded.\n          return reject(chrome.runtime.lastError);\n        }\n\n        const parsedUrl = new URL(redirectedTo);\n        const params = new URLSearchParams(parsedUrl.hash.slice(1)); // hash contains a query string\n        const idToken = params.get('id_token');\n\n        if (!idToken) {\n          throw new Error('no id token');\n        }\n\n        resolve(idToken);\n      },\n    );\n  });\n}\n","import {\n  ExtensionConnectionEvent,\n  MfaChoiceRequest,\n  MfaRequestData,\n  RecoveryMethod,\n  SeedlessEvents,\n} from '@core/types';\n\nexport function isSeedlessTokenEvent(\n  evt: ExtensionConnectionEvent,\n): evt is ExtensionConnectionEvent<void> {\n  return (\n    evt?.name === SeedlessEvents.TokenExpired ||\n    evt?.name === SeedlessEvents.TokenRefreshed\n  );\n}\n\nexport function isSeedlessMfaEvent(\n  evt: ExtensionConnectionEvent,\n): evt is ExtensionConnectionEvent<MfaRequestData> {\n  return (\n    evt?.name === SeedlessEvents.MfaRequest ||\n    evt?.name === SeedlessEvents.MfaFailure ||\n    evt?.name === SeedlessEvents.MfaClear\n  );\n}\n\nexport function isSeedlessMfaMethodsUpdatedEvent(\n  evt: ExtensionConnectionEvent,\n): evt is ExtensionConnectionEvent<RecoveryMethod[]> {\n  return evt?.name === SeedlessEvents.MfaMethodsUpdated;\n}\n\nexport function isSeedlessMfaChoiceRequest(\n  evt: ExtensionConnectionEvent,\n): evt is ExtensionConnectionEvent<MfaChoiceRequest> {\n  return evt?.name === SeedlessEvents.MfaChoiceRequest;\n}\n","import {\n  BitcoinInputUTXO,\n  BitcoinProvider,\n  createTransferTx,\n  getMaxTransferAmount,\n} from '@avalabs/core-wallets-sdk';\nimport { inputBytes } from 'coinselect/utils';\n\nimport { BtcSendOptions } from '@core/types';\n\nimport { isBtcAddressInNetwork } from '../isBtcAddressInNetwork';\nimport { SendErrorMessage } from '@core/types';\nimport { TokenWithBalanceBTC } from '@avalabs/vm-module-types';\n\nexport const getBtcInputUtxos = async (\n  provider: BitcoinProvider,\n  token: TokenWithBalanceBTC,\n  feeRate?: number,\n) => {\n  const utxos = await provider.getScriptsForUtxos(token.utxos ?? []);\n\n  if (typeof feeRate === 'number') {\n    // Filter out UTXOs that would not be used with the current fee rate,\n    // that is those for which fee to use the UTXO would be higher than its value.\n    return utxos.filter((utxo) => {\n      const utxoFee = inputBytes(utxo) * feeRate;\n\n      return utxoFee < utxo.value;\n    });\n  }\n\n  return utxos;\n};\n\nexport const buildBtcTx = async (\n  from: string,\n  provider: BitcoinProvider,\n  { amount, address, token, feeRate }: BtcSendOptions,\n) => {\n  const utxos = await getBtcInputUtxos(provider, token);\n\n  return createTransferTx(\n    address,\n    from,\n    amount,\n    feeRate,\n    utxos,\n    provider.getNetwork(),\n  );\n};\n\nexport const validateBtcSend = (\n  from: string,\n  { address, amount, feeRate }: BtcSendOptions,\n  utxos: BitcoinInputUTXO[],\n  isMainnet: boolean,\n) => {\n  if (!address) {\n    return SendErrorMessage.ADDRESS_REQUIRED;\n  }\n\n  if (!feeRate) {\n    return SendErrorMessage.INVALID_NETWORK_FEE;\n  }\n\n  if (!isBtcAddressInNetwork(address, isMainnet)) {\n    return SendErrorMessage.INVALID_ADDRESS;\n  }\n\n  if (!amount || amount <= 0) {\n    return SendErrorMessage.AMOUNT_REQUIRED;\n  }\n\n  const maxTransferAmount = Math.max(\n    getMaxTransferAmount(utxos, address, from, feeRate),\n    0,\n  );\n\n  if (amount > maxTransferAmount) {\n    return SendErrorMessage.INSUFFICIENT_BALANCE;\n  }\n\n  return null;\n};\n","import { type Network, NetworkVMType } from '@avalabs/core-chains-sdk';\nimport { type Account, AccountType } from '@core/types';\n\nexport function shouldUseWalletConnectApproval(\n  network: Network,\n  account: Account,\n) {\n  // We are not supporting CoreEth as a network\n  if (network.vmName === NetworkVMType.CoreEth) {\n    return false;\n  }\n\n  if (\n    account.type === AccountType.FIREBLOCKS ||\n    account.type === AccountType.WALLET_CONNECT\n  ) {\n    return network.vmName === NetworkVMType.BITCOIN ? false : true;\n  }\n\n  return false;\n}\n","import Big from 'big.js';\n\nexport function stringToBigint(value: string, decimals: number): bigint {\n  const big = Big(value.replace(/,/gi, ''));\n  const tens = Big(10).pow(decimals);\n  const mult = big.times(tens);\n  const rawStr = mult.toFixed(0, 0);\n  return BigInt(rawStr);\n}\n","/**\n * Removes the C-, P- and X- prefix from the provided address.\n */\nexport const stripAddressPrefix = (address: string) =>\n  address.replace(/^[XPC]-/, '');\n","import { formatAndLog } from './logging';\n\nexport const sumByProperty = <O extends Record<T, unknown>, T extends keyof O>(\n  values: O[],\n  key: T,\n): number => {\n  return values.reduce((acc, curr, index) => {\n    const value = curr[key];\n\n    if (typeof value === 'number') {\n      return acc + value;\n    }\n\n    // Log out instances when provided list contains non-numeric values\n    formatAndLog(\n      `sumByProperty(): object at index ${index} was ignored. Property ${String(\n        key,\n      )} does not contain a number:`,\n      curr,\n    );\n\n    return acc;\n  }, 0);\n};\n","export const truncateAddress = (address: string, size = 6): string => {\n  const firstChunk = address.substring(0, size);\n  const lastChunk = address.substr(-(size / 2));\n\n  return `${firstChunk}...${lastChunk}`;\n};\n","export const isFulfilled = <T>(\n  x: PromiseSettledResult<T>,\n): x is PromiseFulfilledResult<T> => x.status === 'fulfilled';\n\nexport const isNotNullish = <T>(x: T): x is NonNullable<T> => x != null;\n","import { isEqual } from 'lodash';\nimport type { Dispatch, SetStateAction } from 'react';\n\ntype ExtractTypeFromStateSetter<Type> =\n  Type extends Dispatch<SetStateAction<infer T>> ? { StateType: T } : never;\n\n/**\n * @param newValue New value being proposed to the state setter\n * @returns A callback to be passed to React's SetState functions.\n * \t\t\t\t\tIt will only update the state if the actual value (not the reference) change.\n * \t\t\t\t\tUse it to prevent unnecessary re-renders.\n */\nexport function updateIfDifferent<\n  StateSetter extends Dispatch<SetStateAction<any>>,\n>(\n  setStateFn: StateSetter,\n  newState: ExtractTypeFromStateSetter<StateSetter>['StateType'],\n) {\n  setStateFn((prevState) => {\n    if (newState === prevState) {\n      return prevState;\n    }\n\n    if (isEqual(prevState, newState)) {\n      return prevState;\n    }\n\n    return newState;\n  });\n}\n","import {\n  ExtensionConnectionEvent,\n  WalletConnectEvent,\n  WalletConnectEventType,\n  WalletConnectSessionPermissionsMismatch,\n  WalletConnectUriGeneratedEvent,\n} from '@core/types';\n\nexport function isUriGeneratedEvent(\n  evt: ExtensionConnectionEvent,\n): evt is ExtensionConnectionEvent<WalletConnectUriGeneratedEvent> {\n  return evt?.name === WalletConnectEvent.UriGenerated;\n}\n\nexport function isSessionPermissionsMismatchEvent(\n  evt: ExtensionConnectionEvent,\n): evt is ExtensionConnectionEvent<WalletConnectSessionPermissionsMismatch> {\n  return evt?.name === WalletConnectEvent.SessionPermissionsMismatch;\n}\n\nexport function isWalletConnectEvent(\n  evt: ExtensionConnectionEvent,\n): evt is ExtensionConnectionEvent<WalletConnectEventType> {\n  const wcEvents = Object.values(WalletConnectEvent) as string[];\n\n  return wcEvents.includes(evt?.name);\n}\n","import { GaslessSdk } from '@avalabs/core-gasless-sdk';\nimport { OFFSCREEN_SCRIPT } from '@core/common';\nimport { ExtensionRequest, GaslessEvents } from '@core/types';\nimport browser, { Runtime } from 'webextension-polyfill';\n\nconst connection: Runtime.Port = browser.runtime.connect({\n  name: OFFSCREEN_SCRIPT,\n});\n\nconnection.onMessage.addListener(async (param: string) => {\n  const params: {\n    name: string;\n    value: {\n      request: string;\n      token: string;\n      message: {\n        pipelineIndex?: number;\n      };\n    };\n  } = JSON.parse(param);\n  const { value, name } = params;\n  if (\n    name !== GaslessEvents.SEND_OFFSCREEN_MESSAGE ||\n    value.request !== ExtensionRequest.GASLESS_FETCH_AND_SOLVE_CHALLENGE\n  ) {\n    throw new Error('Incorrect offscreen message or request name');\n  }\n  const { token, message } = value;\n  const gasStationUrl = process.env.GASLESS_SERVICE_URL;\n\n  if (!gasStationUrl) {\n    throw new Error('GASLESS_SERVICE_URL is missing');\n  }\n\n  const sdk = new GaslessSdk(gasStationUrl, {\n    appCheckToken: token,\n  });\n\n  const { difficulty, challengeHex } = await sdk.fetchChallenge();\n  const { solutionHex } = await sdk.solveChallenge(challengeHex, difficulty);\n  connection.postMessage(\n    JSON.stringify({\n      params: {\n        request: {\n          method: ExtensionRequest.GASLESS_SET_HEX_VALUES,\n          tabId: -1,\n          params: {\n            solutionHex,\n            challengeHex,\n            pipelineIndex: message.pipelineIndex ?? undefined,\n          },\n        },\n      },\n    }),\n  );\n});\n","import { PartialBy } from '@avalabs/vm-module-types';\n\nimport { PubKeyType } from './wallet';\n\nexport enum AccountType {\n  PRIMARY = 'primary',\n  IMPORTED = 'imported', // Imported using private key\n  WALLET_CONNECT = 'walletConnect',\n  FIREBLOCKS = 'fireblocks',\n}\n\nexport type ImportedAccountType = Exclude<AccountType, AccountType.PRIMARY>;\n\nexport enum ImportType {\n  PRIVATE_KEY = 'privateKey',\n  WALLET_CONNECT = 'walletConnect',\n  FIREBLOCKS = 'fireblocks',\n}\nexport const IMPORT_TYPE_TO_ACCOUNT_TYPE_MAP: Record<\n  ImportType,\n  ImportedAccountType\n> = {\n  [ImportType.PRIVATE_KEY]: AccountType.IMPORTED,\n  [ImportType.WALLET_CONNECT]: AccountType.WALLET_CONNECT,\n  [ImportType.FIREBLOCKS]: AccountType.FIREBLOCKS,\n};\n\nexport type ImportData =\n  | PrivateKeyImportData\n  | WalletConnectImportData\n  | FireblocksImportData;\n\nexport type FireblocksApiData = {\n  vaultAccountId: string;\n  key: string;\n  secret: string;\n};\n\nexport type FireblocksImportData = {\n  importType: ImportType.FIREBLOCKS;\n  data: {\n    addresses: {\n      addressC: string;\n      addressBTC?: string;\n    };\n    api?: FireblocksApiData;\n  };\n};\n\nexport type WalletConnectAddresses = {\n  addressC: string;\n  addressBTC?: string;\n  addressAVM?: string;\n  addressPVM?: string;\n  addressCoreEth?: string;\n};\n\nexport type WalletConnectImportData = {\n  importType: ImportType.WALLET_CONNECT;\n  data: {\n    addresses: WalletConnectAddresses;\n    pubKey?: PubKeyType;\n  };\n};\n\nexport type PrivateKeyImportData = {\n  importType: ImportType.PRIVATE_KEY;\n  data: string;\n};\n\nexport interface AccountStorageItem {\n  id: string;\n  name: string;\n  addressBTC?: string;\n  addressC: string;\n  addressAVM?: string;\n  addressPVM?: string;\n  addressCoreEth?: string;\n  addressHVM?: string;\n  addressSVM?: string;\n  type?: AccountType;\n}\n\nexport interface PrimaryAccount extends AccountStorageItem {\n  index: number;\n  type: AccountType.PRIMARY;\n  addressBTC: string;\n  walletId: string;\n}\n\nexport type ImportedAccount =\n  | ImportedPrivateKeyAccount\n  | WalletConnectAccount\n  | FireblocksAccount;\nexport interface ImportedPrivateKeyAccount extends AccountStorageItem {\n  type: AccountType.IMPORTED;\n  addressBTC: string;\n}\n\nexport interface WalletConnectAccount extends AccountStorageItem {\n  type: AccountType.WALLET_CONNECT;\n}\nexport interface FireblocksAccount extends AccountStorageItem {\n  type: AccountType.FIREBLOCKS;\n}\n\nexport type Account = PrimaryAccount | ImportedAccount;\n\nexport type WalletId = string;\nexport interface Accounts {\n  active?: Account;\n  primary: Record<WalletId, PrimaryAccount[]>;\n  imported: Record<\n    string,\n    ImportedAccount | WalletConnectAccount | FireblocksAccount\n  >;\n}\n\nexport const ACCOUNTS_STORAGE_KEY = 'accounts';\n\nexport enum AccountsEvents {\n  ACCOUNTS_UPDATED = 'accounts-updated',\n  ACTIVE_ACCOUNT_CHANGED = 'active-account-changed',\n}\n\nexport enum GetPrivateKeyErrorTypes {\n  Password = 'password',\n  Type = 'type',\n  Chain = 'chain',\n  DerivePath = 'derivePath',\n  Mnemonic = 'mnemonic',\n}\n\nexport type GetAddressesInRangeResponse = {\n  internal: string[];\n  external: string[];\n};\n\nexport type GetAddressesInRangeDisplayData = {\n  indices: {\n    externalStart: number;\n    internalStart: number;\n    externalLimit: number;\n    internalLimit: number;\n  };\n  addresses: GetAddressesInRangeResponse;\n};\n\nexport enum PrivateKeyChain {\n  C = 'C',\n  XP = 'XP',\n}\n\nexport type AccountWithOptionalAddresses = PartialBy<\n  Account,\n  Extract<keyof Account, `address${string}`>\n>;\n\nexport const IMPORTED_ACCOUNTS_WALLET_ID = '__IMPORTED__';\n","import {\n  BatchApprovalParams,\n  DisplayData,\n  DappInfo,\n  RpcMethod,\n  SigningData,\n} from '@avalabs/vm-module-types';\nimport { DAppProviderRequest, JsonRpcRequestPayload } from './dapp-connection';\nimport { ACTION_HANDLED_BY_MODULE } from './util-types';\n\nexport enum ActionStatus {\n  // user has been shown the UI and we are waiting on approval\n  PENDING = 'pending',\n  // user has approved and we are waiting on the background to confirm\n  SUBMITTING = 'submitting',\n  // tx was submitted and returned successful\n  COMPLETED = 'completed',\n  ERROR = 'error',\n  ERROR_USER_CANCELED = 'error-user-canceled',\n}\n\nexport enum ActionType {\n  Single = 'single',\n  Batch = 'batch',\n}\n\ntype ActionBase<DisplayData = any, Params = any> = JsonRpcRequestPayload<\n  DAppProviderRequest | RpcMethod,\n  Params\n> & {\n  type: ActionType;\n  caipId?: string;\n  scope: string;\n  context?: Record<string, unknown>;\n  dappInfo?: DappInfo;\n  [ACTION_HANDLED_BY_MODULE]?: boolean;\n  time?: number;\n  status?: ActionStatus;\n  result?: any;\n  error?: string;\n  // we store the window ID of the confirmation popup so\n  // that we can clean up stale actions later\n  popupWindowId?: number;\n  inAppPromptId?: number;\n  actionId?: string;\n  displayData: DisplayData;\n};\n\nexport type Action<DisplayData = any, Params = any> = ActionBase<\n  DisplayData,\n  Params\n> & {\n  type: ActionType.Single;\n  signingData?: SigningData;\n};\n\nexport type MultiTxAction = ActionBase<DisplayData, unknown> & {\n  type: ActionType.Batch;\n  signingRequests: BatchApprovalParams['signingRequests'];\n  displayData: DisplayData;\n};\n\nexport interface Actions {\n  [id: string]: Action | MultiTxAction;\n}\n\nexport interface ActionUpdate<DisplayData = any> {\n  id: any;\n  status: ActionStatus;\n  displayData?: DisplayData;\n  signingData?: never; // Don't allow overriding signingData this way\n  result?: any;\n  error?: string;\n  tabId?: number;\n}\nexport const ACTIONS_STORAGE_KEY = 'actions';\n\nexport enum ActionsEvent {\n  ACTION_UPDATED = 'action-updated',\n  ACTION_COMPLETED = 'action-completed',\n}\n\nexport enum ActionCompletedEventType {\n  COMPLETED = 'completed',\n  ERROR = 'error',\n}\n\nexport type ActionCompletedEvent = {\n  type: ActionCompletedEventType;\n  action: Action;\n  result: string;\n};\n\nexport const isBatchApprovalAction = (\n  action: Action | MultiTxAction,\n): action is MultiTxAction => action && action.type === ActionType.Batch;\n\nexport const buildActionForRequest = <\n  Params extends { scope: string; displayData: unknown },\n>(\n  request: JsonRpcRequestPayload<DAppProviderRequest | RpcMethod, unknown>,\n  params: Params,\n): Action<Params['displayData'], unknown> => {\n  return {\n    ...request,\n    type: ActionType.Single,\n    scope: params.scope,\n    displayData: params.displayData,\n  };\n};\n","export interface AnalyticsState {\n  deviceId: string;\n  userId: string;\n  addressId?: string;\n}\n\nexport interface AnalyticsSessionState {\n  sessionId: string;\n}\n\nexport interface AnalyticsUnencryptedState {\n  deviceId?: string;\n}\n\nexport interface AnalyticsCapturedEvent {\n  name: string;\n  windowId: string;\n  properties?: Record<string, any>;\n}\n\nexport interface UserEnvironmentAnalytics {\n  $os: string;\n  $browser: string;\n  $browser_version: string;\n}\n\nexport enum AnalyticsEvents {\n  ANALYTICS_STATE_UPDATED = 'AnalyticsEvents: ANALYTICS_STATE_UPDATED',\n}\n\nexport const ANALYTICS_STORAGE_KEY = 'ANALYTICS_STORAGE_KEY';\nexport const ANALYTICS_UNENCRYPTED_STORAGE_KEY =\n  'ANALYTICS_UNENCRYPTED_STORAGE_KEY';\n\nexport const ANALYTICS_SESSION_KEY = 'ANALYTICS_SESSION_KEY';\n\n//Based on CAIP-2\nexport enum BlockchainId {\n  P_CHAIN = 'avax:11111111111111111111111111111111LpoYY',\n  P_CHAIN_TESTNET = 'avax:fuji-11111111111111111111111111111111LpoYY',\n  X_CHAIN = 'avax:2oYMBNV4eNHyqk2fjjV5nVQLDbtmNJzq5s3qs3Lo6ftnC6FByM',\n  X_CHAIN_TESTNET = 'avax:2JVSBoinj9C2J33VntvzYtVJNZdN2NKiwwKjcumHUWEb5DbBrm',\n}\n","import * as Sentry from '@sentry/browser';\n\nexport type ChallengeRequest = {\n  id: string;\n  tracker: Sentry.Transaction;\n  registrationId?: string;\n  solution?: string;\n};\n\nexport type ChallengeSolver = (details: string) => string | Promise<string>;\n\nexport enum Algorithm {\n  SHA256 = 'SHA256',\n  SHA512 = 'SHA512',\n}\n\nexport enum ChallengeTypes {\n  BASIC = 'BASIC',\n  REVERSE = 'REVERSE',\n}\n\nexport type AppCheckRegistrationChallenge = {\n  requestId: string;\n  registrationId: string;\n  type: ChallengeTypes;\n  event: string;\n  details: string;\n};\n","import { Action, MultiTxAction } from './actions';\n\nexport type ApprovalRequest = {\n  action: Action | MultiTxAction;\n  url: string;\n};\n\nexport enum ApprovalEvent {\n  ApprovalRequested = 'approval-requested',\n}\n","import {\n  NftTokenWithBalance,\n  TokenWithBalance,\n  TokenWithBalanceAVM,\n  TokenWithBalanceBTC,\n  TokenWithBalancePVM,\n} from '@avalabs/vm-module-types';\n\nimport { EnsureDefined } from './util-types';\n\nexport const BALANCES_CACHE_KEY = 'balances-service-cache';\n\nexport enum BalanceServiceEvents {\n  UPDATED = 'BalanceServiceEvents:updated',\n}\n\nexport type RawTokenAttribute = {\n  value: string;\n} & (\n  | {\n      name: string;\n      trait_type: never;\n    }\n  | {\n      name: never;\n      trait_type: string;\n    }\n);\n\nexport interface NftMetadata {\n  attributes?: string;\n  name?: string;\n  image?: string;\n  description?: string;\n}\n\nexport interface TokenAttribute {\n  name: string;\n  value: string;\n}\n\n// store balances in the structure of network ID -> address -> tokens\nexport interface Balances<TokenTypes = TokenWithBalance> {\n  [networkId: string | number]: {\n    [accountAddress: string]: {\n      [tokenAddressOrSymbol: string]: TokenTypes;\n    };\n  };\n}\nexport interface BalancesInfo {\n  balances: {\n    tokens: Balances;\n    nfts: Balances<NftTokenWithBalance>;\n  };\n  isBalancesCached: boolean;\n}\n\nexport interface CachedBalancesInfo {\n  totalBalance?: TotalBalance;\n  balances?: Balances;\n  lastUpdated?: number;\n}\n\nexport type TotalBalance = {\n  [address: string | number]: {\n    sum: number | null;\n    priceChange: TotalPriceChange;\n  };\n};\n\nexport interface TotalPriceChange {\n  value: number;\n  percentage: number[];\n}\n\nexport class GlacierUnhealthyError extends Error {\n  message = 'Glacier is unhealthy. Try again later.';\n}\n\nexport const hasUnconfirmedBTCBalance = (\n  token?: TokenWithBalance,\n): token is EnsureDefined<TokenWithBalanceBTC, 'unconfirmedBalance'> =>\n  Boolean(token && 'unconfirmedBalance' in token);\n\nexport const isAvaxWithUnavailableBalance = (\n  token?: TokenWithBalance,\n): token is TokenWithBalanceAVM | TokenWithBalancePVM =>\n  Boolean(\n    token &&\n      'balancePerType' in token &&\n      token.available &&\n      token.available !== token.balance,\n  );\n\nexport const getUnconfirmedBalanceInCurrency = (token?: TokenWithBalance) => {\n  if (!token || !hasUnconfirmedBTCBalance(token)) {\n    return undefined;\n  }\n\n  return token.unconfirmedBalanceInCurrency;\n};\n\nexport type TotalBalanceForWallet = {\n  totalBalanceInCurrency?: number;\n  hasBalanceOnUnderivedAccounts: boolean;\n};\n","import {\n  Asset,\n  Blockchain,\n  BridgeTransaction,\n  WrapStatus,\n} from '@avalabs/core-bridge-sdk';\nimport { BridgeType, GasSettings } from '@avalabs/bridge-unified';\nimport { Network } from '@avalabs/core-chains-sdk';\nimport { TokenWithBalance } from '@avalabs/vm-module-types';\n\nexport enum TransferEventType {\n  WRAP_STATUS = 'wrap_status',\n  TX_HASH = 'tx_hash',\n}\n\nexport type TransferEvent =\n  | {\n      type: TransferEventType.WRAP_STATUS;\n      status: WrapStatus;\n    }\n  | {\n      type: TransferEventType.TX_HASH;\n      txHash: string;\n    };\n\nexport interface BridgeState {\n  bridgeTransactions: {\n    [key: string]: BridgeTransaction;\n  };\n  isDevEnv: boolean;\n}\n\nexport type PartialBridgeTransaction = Pick<\n  BridgeTransaction,\n  | 'sourceChain'\n  | 'sourceTxHash'\n  | 'sourceStartedAt'\n  | 'targetChain'\n  | 'amount'\n  | 'symbol'\n>;\n\nexport enum BridgeEvents {\n  BRIDGE_CONFIG_UPDATE_EVENT = 'BRIDGE_CONFIG_UPDATE_EVENT',\n  BRIDGE_STATE_UPDATE_EVENT = 'BRIDGE_STATE_UPDATE_EVENT',\n  BRIDGE_TRANSFER_EVENT = 'BRIDGE_TRANSFER_EVENT',\n}\n\nexport const BRIDGE_STORAGE_KEY = 'bridge';\n\nexport const DefaultBridgeState: BridgeState = {\n  bridgeTransactions: {},\n  isDevEnv: false,\n};\n\nexport interface BtcTransactionResponse {\n  hash: string;\n  gasLimit: bigint;\n  value: bigint;\n  confirmations: number;\n  from: string;\n}\n\nexport type CustomGasSettings = {\n  maxFeePerGas?: bigint;\n  maxPriorityFeePerGas?: bigint;\n  gasLimit?: bigint;\n};\n\nexport type BridgeActionDisplayData = {\n  currentBlockchain: Blockchain;\n  sourceNetwork: Network;\n  targetNetwork: Network;\n  amountStr: string;\n  asset: Asset;\n  token: TokenWithBalance;\n  gasLimit: bigint;\n  gasSettings?: CustomGasSettings;\n};\n\nexport type BridgeOptions = {\n  bridgeType?: BridgeType;\n  gasSettings?: GasSettings;\n};\n","import type { Contact } from '@avalabs/types';\n\nexport interface ContactsState {\n  contacts: Contact[];\n}\n\nexport enum ContactsEvents {\n  CONTACTS_UPDATED = 'ContactsEvents: CONTACTS_UPDATED',\n}\n\nexport const CONTACTS_STORAGE_KEY = 'contacts';\n","import Joi from 'joi';\n\nexport type CurrencyExchangeRates = Record<string, Record<string, number>>;\n\nexport type CurrencyExchangeRatesState = {\n  date: string;\n  rates: CurrencyExchangeRates;\n};\n\nexport const ExchangeRatesSchema = Joi.object<CurrencyExchangeRates>({\n  date: Joi.string().required(),\n  usd: Joi.object().pattern(Joi.string(), Joi.number()),\n});\n\nexport enum CurrencyServiceEvents {\n  RatesUpdated = 'CurrencyService::RatesUpdated',\n}\n\n// We're only loading exchange rates for USD at the moment.\nexport const CURRENCY_EXCHANGE_RATES_URL =\n  'https://cdn.jsdelivr.net/npm/@fawazahmed0/currency-api@latest/v1/currencies/usd.min.json';\n\n// We refresh data every one hour.\n// No need to do it more often, since the above API updates the exchange rates daily.\nexport const CURRENCY_EXCHANGE_RATES_REFRESH_INTERVAL = 1000 * 60 * 60;\n\nexport const CURRENCY_EXCHANGE_RATES_STORAGE_KEY = 'currency-exchange-rates';\n","import { Maybe } from '@avalabs/core-utils-sdk';\nimport { RpcResponse } from '@avalabs/vm-module-types';\nimport { EthereumProviderError } from 'eth-rpc-errors';\nimport { SerializedEthereumRpcError } from 'eth-rpc-errors/dist/classes';\n\nimport { Action } from './actions';\nimport { DomainMetadata } from './domain-metadata';\n\nexport enum DAppProviderRequest {\n  DOMAIN_METADATA_METHOD = 'avalanche_sendDomainMetadata',\n  CONNECT_METHOD = 'eth_requestAccounts',\n  INIT_DAPP_STATE = 'avalanche_getProviderState',\n  ETH_ACCOUNTS = 'eth_accounts',\n  WALLET_PERMISSIONS = 'wallet_requestPermissions',\n  WALLET_GET_PERMISSIONS = 'wallet_getPermissions',\n  WALLET_ADD_CHAIN = 'wallet_addEthereumChain',\n  WALLET_GET_CHAIN = 'wallet_getEthereumChain',\n  WALLET_SWITCH_ETHEREUM_CHAIN = 'wallet_switchEthereumChain',\n  WALLET_WATCH_ASSET = 'wallet_watchAsset',\n  PERSONAL_EC_RECOVER = 'personal_ecRecover',\n  PERSONAL_SIGN = 'personal_sign',\n  ETH_SIGN_TYPED_DATA_V4 = 'eth_signTypedData_v4',\n  ETH_SIGN_TYPED_DATA_V3 = 'eth_signTypedData_v3',\n  ETH_SIGN_TYPED_DATA_V1 = 'eth_signTypedData_v1',\n  ETH_SIGN_TYPED_DATA = 'eth_signTypedData',\n  ETH_SIGN = 'eth_sign',\n  AVALANCHE_GET_CONTACTS = 'avalanche_getContacts',\n  AVALANCHE_CREATE_CONTACT = 'avalanche_createContact',\n  AVALANCHE_UPDATE_CONTACT = 'avalanche_updateContact',\n  AVALANCHE_REMOVE_CONTACT = 'avalanche_removeContact',\n  AVALANCHE_GET_ACCOUNTS = 'avalanche_getAccounts',\n  AVALANCHE_GET_ADDRESSES_IN_RANGE = 'avalanche_getAddressesInRange',\n  AVALANCHE_GET_BRIDGE_STATE = 'avalanche_getBridgeState',\n  AVALANCHE_SELECT_WALLET = 'avalanche_selectWallet',\n  AVALANCHE_SET_DEVELOPER_MODE = 'avalanche_setDeveloperMode',\n  ACCOUNT_SELECT = 'avalanche_selectAccount',\n  ACCOUNT_RENAME = 'avalanche_renameAccount',\n  ACCOUNTS_DELETE = 'avalanche_deleteAccounts',\n  AVALANCHE_GET_ACCOUNT_PUB_KEY = 'avalanche_getAccountPubKey',\n  AVALANCHE_SEND_TRANSACTION = 'avalanche_sendTransaction',\n  AVALANCHE_SIGN_TRANSACTION = 'avalanche_signTransaction',\n  AVALANCHE_SIGN_MESSAGE = 'avalanche_signMessage',\n  BITCOIN_SEND_TRANSACTION = 'bitcoin_sendTransaction',\n  WALLET_RENAME = 'avalanche_renameWallet',\n  WALLET_ADD_NETWORK = 'wallet_addNetwork',\n  WALLET_GET_PUBKEY = 'wallet_getPublicKey',\n  WALLET_CONNECT = 'wallet_requestAccountPermission',\n}\n\nexport enum Web3Event {\n  // https://eips.ethereum.org/EIPS/eip-1193#connect-1\n  // not emitted as a separate event from the background, the inpage provider handles it\n  // based on the `avalanche_getProviderState` and the `chainChanged` event\n  CONNECT = 'connect',\n  // https://eips.ethereum.org/EIPS/eip-1193#disconnect-1\n  DISCONNECT = 'disconnect',\n  // https://eips.ethereum.org/EIPS/eip-1193#accountschanged-1\n  ACCOUNTS_CHANGED = 'accountsChanged',\n  ACCOUNTS_CHANGED_CA = 'accountsChangedCA', // Chain-agnostic version of ACCOUNTS_CHANGED\n  // https://eips.ethereum.org/EIPS/eip-1193#chainchanged-1\n  CHAIN_CHANGED = 'chainChanged',\n}\n\nexport interface JsonRpcRequestParams<Method extends string, Params = unknown> {\n  readonly scope: string;\n  readonly sessionId: string;\n  readonly request: JsonRpcRequestPayload<Method, Params>;\n}\n\nexport type JsonRpcRequestPayload<\n  Method extends string = any,\n  Params = unknown,\n> = Params extends undefined\n  ? JsonRpcRequestPayloadWithoutParams<Method>\n  : JsonRpcRequestPayloadWithParams<Method, Params>;\n\nexport interface JsonRpcRequest<Method extends string = any, Params = unknown> {\n  readonly jsonrpc: '2.0';\n  readonly id: string;\n  readonly method: 'provider_request';\n  readonly params: JsonRpcRequestParams<Method, Params>;\n  readonly context?: { tabId?: number } & Record<string, unknown>;\n}\n\ninterface JsonRpcRequestPayloadBase<Method extends string = any> {\n  readonly id: string;\n  readonly method: Method;\n  readonly site?: DomainMetadata;\n  readonly tabId?: number;\n  readonly context?: Record<string, unknown>;\n}\n\ninterface JsonRpcRequestPayloadWithParams<\n  Method extends string = any,\n  Params = unknown,\n> extends JsonRpcRequestPayloadBase<Method> {\n  readonly params: Params;\n}\n\ninterface JsonRpcRequestPayloadWithoutParams<Method extends string = any>\n  extends JsonRpcRequestPayloadBase<Method> {\n  readonly params?: never;\n}\n\nexport interface JsonRpcSuccess<T = unknown> {\n  result: Maybe<T | symbol>;\n}\nexport interface JsonRpcFailure {\n  error: EthereumProviderError<unknown> | SerializedEthereumRpcError | Error;\n}\nexport declare type JsonRpcResponse<T = unknown> =\n  | JsonRpcSuccess<T>\n  | JsonRpcFailure\n  | RpcResponse;\n\n/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\nexport interface DAppRequestHandler {\n  /**\n   * Optional: Only used when the action needs user approval\n   * IS ONLY called when `actionsService.addAction` and a `DEFERRED_RESPONSE` is used by the handler.\n   * Called by the ActionsService after the user confirms the request on the approval popup.\n   */\n  onActionApproved?: (\n    pendingAction: Action,\n    result: any,\n    onSuccess: (result: unknown) => Promise<void>,\n    onError: (error: Error) => Promise<void>,\n    tabId?: number,\n  ) => Promise<void>;\n}\n\nexport abstract class DAppRequestHandler<\n  RequestParams = unknown,\n  ResponseParams = any,\n> {\n  abstract methods: DAppProviderRequest[];\n\n  abstract handleAuthenticated: (\n    rpcCall: JsonRpcRequestParams<DAppProviderRequest, RequestParams>,\n  ) => Promise<JsonRpcResponse<ResponseParams>>;\n\n  abstract handleUnauthenticated: (\n    rpcCall: JsonRpcRequestParams<DAppProviderRequest, RequestParams>,\n  ) => Promise<JsonRpcResponse<ResponseParams>>;\n}\n","// The API reference:\n// https://docs.open.debank.com/en/reference/api-models/portfolioitemobject\n\nexport type DebankChain = {\n  id: string;\n  community_id: number;\n  name: string;\n  native_token_id: string;\n  logo_url: string;\n  wrapped_token_id: string;\n  is_support_pre_exec: boolean;\n};\n\nexport interface Collection {\n  id: string;\n  chain: string;\n  name: string;\n  description: string | null;\n  logo_url: string;\n  is_verified: boolean;\n  credit_score: number;\n  is_scam: boolean;\n  is_suspicious: boolean;\n  is_core: boolean;\n  floor_price: number;\n  tokens?: DebankNFTItem[];\n  is_erc1155?: boolean;\n  is_erc721?: boolean;\n}\n\nexport interface DebankNFTItem {\n  id: string;\n  contract_id: string;\n  inner_id: string;\n  chain: string;\n  symbol: string;\n  name: string;\n  description: string;\n  content_type: 'image' | 'image_url' | 'video_url' | 'audio_url';\n  content: string;\n  thumbnail_url: string;\n  total_supply?: number;\n  attributes: {\n    trait_type: string;\n    value: string | number;\n  }[];\n  detail_url: string;\n  collection_id?: string;\n  is_erc1155?: boolean;\n  is_erc721: boolean;\n  pay_token: {\n    id: string;\n    name: string;\n    symbol?: string;\n    amount: number;\n    logo_url?: string;\n    time_at: number;\n    date_at?: string;\n    price?: number;\n  };\n  usd_price: number;\n  collection?: Collection | null;\n  amount?: number;\n}\n\nexport type DebankTokenItem = {\n  content_type?: 'image' | 'image_url' | 'video_url' | 'audio_url' | undefined;\n  content?: string | undefined;\n  inner_id?: any;\n  amount: number;\n  chain: string;\n  decimals: number;\n  display_symbol: string | null;\n  id: string;\n  is_core: boolean;\n  is_verified: boolean;\n  is_wallet: boolean;\n  is_scam?: boolean;\n  is_infinity?: boolean;\n  is_suspicious?: boolean;\n  logo_url: string;\n  name: string;\n  optimized_symbol: string;\n  price: number;\n  symbol: string;\n  time_at: number;\n  usd_value?: number;\n  raw_amount?: string;\n  raw_amount_hex_str?: string;\n  price_24h_change?: number | null;\n};\n\nexport interface DebankPortfolioTokenItem extends DebankTokenItem {\n  claimable_amount?: number;\n}\n\nexport type DebankNftObject = {\n  chain: string;\n  collection: {\n    id: string;\n    name: string;\n    create_at: number;\n    chains: string[];\n    is_suspicious?: boolean;\n    is_verified?: boolean;\n    floor_price?: number | null;\n  };\n  content: string;\n  content_type: 'image' | 'image_url' | 'video_url' | 'audio_url';\n  contract_id: string;\n  description: string | null;\n  detail_url: string;\n  id: string;\n  inner_id: string;\n  name: string;\n  total_supply: number;\n  amount: number;\n};\n\nexport enum DebankProtocolDetailTypes {\n  COMMON = 'common',\n  LOCKED = 'locked',\n  LENDING = 'lending',\n  LEVERAGED_FARMING = 'leveraged_farming',\n  VESTING = 'vesting',\n  REWARD = 'reward',\n  OPTIONS_SELLER = 'options_seller',\n  OPTIONS_BUYER = 'options_buyer',\n  PERPETUALS = 'perpetuals',\n  INSURANCE_SELLER = 'insurance_seller',\n  INSURANCE_BUYER = 'insurance_buyer',\n}\n\nexport type DebankPortfolioItemObject = {\n  stats: {\n    asset_usd_value: number;\n    debt_usd_value: number;\n    net_usd_value: number;\n  };\n  update_at: number;\n  name: string;\n  detail_types: DebankProtocolDetailTypes[];\n  detail: {\n    supply_token_list?: DebankPortfolioTokenItem[];\n    reward_token_list?: DebankPortfolioTokenItem[];\n    borrow_token_list?: DebankPortfolioTokenItem[];\n    unlock_at?: number;\n    health_rate?: number;\n    debt_ratio?: number;\n    daily_unlock_amount?: number;\n    end_at?: number;\n\n    // Optional detail properties: https://docs.open.debank.com/en/reference/api-models/portfolioitemobject#locked-locked-position\n\n    // For reward items:\n    token_list?: DebankPortfolioTokenItem[];\n\n    // For vesting protocols\n    token?: DebankPortfolioTokenItem;\n\n    // For Options Seller / Options Buyer\n    strike_token?: DebankPortfolioTokenItem;\n    underlying_token?: DebankPortfolioTokenItem;\n    collateral_token_list?: DebankPortfolioTokenItem[];\n\n    // For perpetuals:\n    pnl_usd_value?: number;\n\n    type?: number | string;\n    style?: 'American' | 'European';\n    exercise_start_at?: number;\n    exercise_end_at?: number;\n    is_auto_exercise?: boolean;\n    exercise_profit?: number;\n    usd_value?: number;\n    description?: string;\n    expired_at?: number;\n    side?: 'Long' | 'Short';\n    base_token?: DebankPortfolioTokenItem;\n    quote_token?: DebankPortfolioTokenItem;\n    position_token?: DebankPortfolioTokenItem;\n    margin_token?: DebankPortfolioTokenItem;\n    margin_rate?: { amount: number };\n    leverage?: number;\n    daily_funding_rate?: number;\n    entry_price?: number;\n    mark_price?: number;\n    liquidation_price?: number;\n  };\n};\n\nexport type DebankComplexProtocol = {\n  id: string;\n  chain: string;\n  name: string;\n  site_url: string;\n  logo_url: string;\n  has_supported_portfolio: boolean;\n  tvl: number;\n  portfolio_item_list: DebankPortfolioItemObject[];\n};\n\nexport type DebankTxPreExecutionResult = {\n  balance_change: {\n    success: boolean;\n    error: null | {\n      code: number;\n      message: string;\n    };\n    send_token_list: DebankTokenItem[];\n    receive_token_list: DebankTokenItem[];\n    send_nft_list: DebankNFTItem[];\n    receive_nft_list: DebankNFTItem[];\n    usd_value_change: number;\n  };\n  gas: {\n    success?: boolean;\n    error?: {\n      code: number;\n      msg: string;\n    } | null;\n    gas_used: number;\n    gas_limit: number;\n  };\n  is_multisig: boolean;\n  multisig?: any;\n  pre_exec: {\n    success: boolean;\n    error?: {\n      code: number;\n      msg: string;\n    } | null;\n  };\n};\n\nexport type DebankTransactionData = {\n  from: string;\n  to: string;\n  data: string;\n  value: string;\n  chainId: number;\n  nonce: string;\n  gas: string;\n  gasPrice?: string;\n};\n\nexport interface SendTokenAction {\n  type: 'send_token';\n  from_addr: string;\n  to_addr: string;\n  token: DebankTokenItem;\n}\n\nexport interface SendNftAction {\n  type: 'send_nft';\n  from_addr: string;\n  to_addr: string;\n  nft: DebankNFTItem;\n}\n\nexport interface ApproveTokenAction {\n  type: 'approve_token' | 'revoke_token_approval';\n  owner: string;\n  spender: {\n    id: string; //spender address\n    protocol: {\n      id: string;\n      name: string;\n      logo_url: string;\n    };\n  };\n  token: DebankTokenItem;\n}\n\nexport interface ApproveNftAction {\n  type: 'approve_nft' | 'revoke_nft_approval';\n  owner: string;\n  spender: {\n    id: string; //spender address\n    protocol: {\n      id: string;\n      name: string;\n      logo_url: string;\n    };\n  };\n  nft: DebankNFTItem;\n}\n\nexport interface ApproveNftCollectionAction {\n  type: 'approve_nft_collection' | 'revoke_nft_collection_approval';\n  owner: string;\n  spender: {\n    id: string; //spender address\n    protocol: {\n      id: string;\n      name: string;\n      logo_url: string;\n    };\n  };\n  collection: Collection;\n}\n\nexport interface CancelTxAction {\n  type: 'cancel_tx';\n  from_addr: string;\n}\nexport interface DeployContractAction {\n  type: 'deploy_contract';\n  from_addr: string;\n}\nexport interface CallAction {\n  type: 'call';\n  from_addr: string;\n  to_addr: string;\n  contract: {\n    id: string;\n    protocol: {\n      logo_url: string;\n      name: string;\n      id: string;\n    };\n  };\n}\n\nexport type TxAction =\n  | SendTokenAction\n  | SendNftAction\n  | ApproveTokenAction\n  | ApproveNftAction\n  | ApproveNftCollectionAction\n  | CancelTxAction\n  | DeployContractAction\n  | CallAction;\n\nexport interface ExplainTxResponse {\n  actions?: TxAction[];\n  abi?: {\n    func: string;\n    params: unknown[];\n  };\n}\n","export type DefiPortfolio = {\n  totalUsdValue: number;\n  protocols: DefiProtocol[];\n};\n\nexport type DefiProtocol = {\n  id: string;\n  name: string;\n  siteUrl: string;\n  logoUrl: string;\n  totalUsdValue: number;\n\n  chainId?: number;\n  chainLogoUrl?: string;\n  chainName?: string;\n\n  groups: DefiItemGroup[];\n};\n\nexport type DefiToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n  logoUrl: string;\n  price: number;\n  amount: number;\n  usdValue: number;\n};\n\ninterface BaseDefiItem {\n  type: DefiItemType;\n  name: string;\n  netUsdValue: number;\n}\n\nexport enum DefiItemType {\n  Common = 'common',\n  Locked = 'locked',\n  Lending = 'lending',\n  Vesting = 'vesting',\n  Reward = 'reward',\n  InsuranceBuyer = 'insurance_buyer',\n  Perpetual = 'perpetual',\n}\n\nexport interface DefiCommonItem extends BaseDefiItem {\n  type: DefiItemType.Common;\n  supplyTokens?: DefiToken[];\n  rewardTokens?: DefiToken[];\n}\n\nexport interface DefiLendingItem extends BaseDefiItem {\n  type: DefiItemType.Lending;\n  healthRate?: number;\n  supplyTokens: DefiToken[];\n  borrowTokens: DefiToken[];\n  rewardTokens: DefiToken[];\n}\n\nexport interface DefiVestingItem extends BaseDefiItem {\n  type: DefiItemType.Vesting;\n  token: DefiToken & {\n    claimableAmount?: number;\n  };\n  dailyUnlockAmount?: number;\n  endAt?: number;\n}\n\nexport interface DefiRewardItem extends BaseDefiItem {\n  type: DefiItemType.Reward;\n  tokens: DefiToken[];\n}\n\ninterface DefiInsuranceItem extends BaseDefiItem {\n  expiredAt: number;\n  description: string;\n}\nexport interface DefiInsuranceBuyerItem extends DefiInsuranceItem {\n  type: DefiItemType.InsuranceBuyer;\n}\n\nexport interface DefiPerpetualItem extends BaseDefiItem {\n  type: DefiItemType.Perpetual;\n  positionToken: DefiToken;\n  marginToken: DefiToken;\n  profitUsdValue: number;\n  netUsdValue: number;\n}\n\n// Represents a singular DeFi investment\nexport type DefiItem =\n  | DefiCommonItem\n  | DefiLendingItem\n  | DefiVestingItem\n  | DefiRewardItem\n  | DefiPerpetualItem\n  | DefiInsuranceBuyerItem;\n\n// Groups DefiItems under one name (e.g. 'Lending', 'Liquidity Pool')\nexport type DefiItemGroup = {\n  name: string;\n  items: DefiItem[];\n  totalUsdValue: number;\n};\n\nexport interface DefiDataProvider {\n  getUserProtocols(address: string): Promise<DefiProtocol[]>;\n}\n\nexport enum DefiServiceEvents {\n  PortfolioUpdated = 'DefiService::PortfolioUpdated',\n}\n\nexport type DefiPortfolioUpdatedEvent = {\n  address: string;\n  portfolio: DefiPortfolio;\n};\n","export interface DomainMetadataRequest {\n  method: 'avalanche_sendDomainMetadata';\n  params: DomainMetadata;\n}\n\nexport interface DomainMetadata {\n  domain: string;\n  name?: string;\n  icon?: string;\n  tabId?: number;\n  url?: string;\n}\n","import { EthereumRpcError } from 'eth-rpc-errors';\n\nexport type ErrorData = {\n  reason: ErrorCode;\n  originalError?: unknown;\n  [key: string]: any;\n};\n\nexport interface WrappedError extends EthereumRpcError<ErrorData> {\n  data: ErrorData;\n}\n\nexport enum KeystoreError {\n  InvalidPassword = 'keystore-invalid-password',\n  InvalidVersion = 'keystore-invalid-version',\n  NoNewWallets = 'keystore-no-new-wallets',\n  Unknown = 'keystore-unknown-error',\n}\n\nexport enum SwapErrorCode {\n  ClientNotInitialized = 'client-not-initialized',\n  MissingParams = 'missing-params',\n  CannotFetchAllowance = 'cannot-fetch-allowance',\n  MissingContractMethod = 'missing-contract-method',\n  ApiError = 'api-error',\n  UnknownSpender = 'unknown-spender',\n  UnexpectedApiResponse = 'unexpected-api-response',\n  CannotBuildTx = 'cannot-build-tx',\n  InvalidParams = 'invalid-params',\n  FeatureDisabled = 'feature-disabled',\n  TransactionError = 'transaction-error',\n}\n\nexport enum VMModuleError {\n  UnsupportedChain = 'unsupported-chain',\n  UnsupportedMethod = 'unsupported-method',\n  UnsupportedNamespace = 'unsupported-namespace',\n  ModulesNotInitialized = 'modules-not-initialized',\n}\n\nexport enum SeedphraseImportError {\n  ExistingSeedphrase = 'existing-seedphrase',\n}\n\nexport enum UnifiedBridgeError {\n  UnknownAsset = 'unknown-asset',\n  AmountLessThanFee = 'amount-less-than-fee',\n  InvalidFee = 'invalid-fee',\n  UnsupportedNetwork = 'unsupported-network',\n  InvalidTxPayload = 'invalid-tx-payload',\n  NonBitcoinAccount = 'non-bitcoin-account',\n}\n\nexport enum SeedlessError {\n  NoMfaMethodAvailable = 'no-mfa-method-available',\n}\n\nexport enum FireblocksErrorCode {\n  Failed = 'fireblocks-tx-failed',\n  Blocked = 'fireblocks-tx-blocked',\n  Cancelled = 'fireblocks-tx-cancelled',\n  Rejected = 'fireblocks-tx-rejected',\n  Timeout = 'fireblocks-tx-timeout',\n  Unknown = 'fireblocks-tx-unknown-error',\n}\n\nexport enum CommonError {\n  Unknown = 'unknown',\n  UserRejected = 'user-rejected',\n  NetworkError = 'network-error',\n  NoActiveAccount = 'no-active-account',\n  NoActiveNetwork = 'no-active-network',\n  UnknownNetwork = 'unknown-network',\n  UnknownNetworkFee = 'unknown-network-fee',\n  RequestTimeout = 'request-timeout',\n  MigrationFailed = 'migration-failed',\n  ModuleManagerNotSet = 'module-manager-not-set',\n  UnableToSign = 'unable-to-sign',\n  UnableToEstimateGas = 'unable-to-estimate-gas',\n  UnsupportedTokenType = 'unsupported-token-type',\n  MismatchingProvider = 'mismatching-provider',\n}\n\nexport enum LedgerError {\n  TransportNotFound = 'ledger-transport-not-found',\n  NoPublicKeyReturned = 'ledger-no-public-key-returned',\n}\n\nexport enum SecretsError {\n  SecretsNotFound = 'secrets-not-found',\n  UnsupportedSecretType = 'unsupported-secret-type',\n  MissingExtendedPublicKey = 'missing-ext-pubkey',\n  WalletAlreadyExists = 'wallet-already-exists',\n  PublicKeyNotFound = 'public-key-not-found',\n  NoAccountIndex = 'no-account-index',\n  DerivationPathMissing = 'derivation-path-missing',\n  UnknownDerivationPathFormat = 'unknown-derivation-path-format',\n  DerivationPathTooShort = 'derivation-path-too-short',\n  UnsupportedCurve = 'unsupported-curve',\n}\n\nexport enum AccountError {\n  EVMAddressNotFound = 'evm-address-not-found',\n  BTCAddressNotFound = 'btc-address-not-found',\n  SVMAddressNotFound = 'svm-address-not-found',\n  NoAddressesFound = 'no-addresses-found',\n}\n\nexport enum RpcErrorCode {\n  InsufficientFunds = 'INSUFFICIENT_FUNDS',\n}\n\nexport type ErrorCode =\n  | FireblocksErrorCode\n  | SwapErrorCode\n  | CommonError\n  | UnifiedBridgeError\n  | SeedphraseImportError\n  | KeystoreError\n  | SeedlessError\n  | VMModuleError\n  | SecretsError\n  | AccountError\n  | LedgerError;\n","export enum FeatureGates {\n  EVERYTHING = 'everything',\n  EVENTS = 'events',\n  SWAP = 'swap-feature',\n  SWAP_C_CHAIN = 'swap-c-chain',\n  SWAP_ETHEREUM = 'swap-ethereum',\n  SWAP_SOLANA = 'swap-solana',\n  SWAP_FEES = 'swap-fees',\n  SWAP_FEES_JUPITER = 'swap-fees-jupiter',\n  BRIDGE = 'bridge-feature',\n  BRIDGE_ETH = 'bridge-feature-eth',\n  BRIDGE_BTC = 'bridge-feature-btc',\n  SEND = 'send-feature',\n  SEND_P_CHAIN = 'send-p-chain',\n  SEND_X_CHAIN = 'send-x-chain',\n  SENDTRANSACTION_CHAIN_ID_SUPPORT = 'sendtransaction-chain-id-support-feature',\n  BUY = 'buy',\n  BUY_MOONPAY = 'buy-feature-moonpay',\n  BUY_COINBASE = 'buy-feature-coinbase',\n  KEYSTONE = 'keystone',\n  NFT_MARKETPLACE = 'nft-marketplace',\n  BOTTOM_NAVIGATION = 'bottom-navigation',\n  DEFI = 'defi-feature',\n  IMPORT_WALLET_CONNECT = 'import-wallet-connect',\n  IMPORT_FIREBLOCKS = 'import-fireblocks',\n  IN_APP_SUPPORT_P_CHAIN = 'in-app-support-p-chain',\n  IN_APP_SUPPORT_X_CHAIN = 'in-app-support-x-chain',\n  SEEDLESS_ONBOARDING = 'seedless-onboarding',\n  SEEDLESS_ONBOARDING_GOOGLE = 'seedless-onboarding-google',\n  SEEDLESS_ONBOARDING_APPLE = 'seedless-onboarding-apple',\n  SEEDLESS_MFA_PASSKEY = 'seedless-mfa-passkey',\n  SEEDLESS_MFA_AUTHENTICATOR = 'seedless-mfa-authenticator',\n  SEEDLESS_MFA_YUBIKEY = 'seedless-mfa-yubikey',\n  SEEDLESS_SIGNING = 'seedless-signing',\n  SEEEDLESS_MFA_SETTINGS = 'seedless-mfa-settings',\n  SEEDLESS_OPTIONAL_MFA = 'seedless-optional-mfa',\n  UNIFIED_BRIDGE_CCTP = 'unified-bridge-cctp',\n  UNIFIED_BRIDGE_ICTT = 'unified-bridge-ictt',\n  UNIFIED_BRIDGE_AB_EVM = 'unified-bridge-ab-evm',\n  UNIFIED_BRIDGE_AB_AVA_TO_BTC = 'unified-bridge-ab-ava-to-btc',\n  UNIFIED_BRIDGE_AB_BTC_TO_AVA = 'unified-bridge-ab-btc-to-ava',\n  DEBANK_TRANSACTION_PARSING = 'debank-transaction-parsing',\n  DEBANK_TRANSACTION_PRE_EXECUTION = 'debank-transaction-pre-execution',\n  PRIMARY_ACCOUNT_REMOVAL = 'primary-account-removal',\n  ADD_WALLET_WITH_SEEDPHRASE = 'add-wallet-with-seedphrase',\n  ADD_WALLET_WITH_KEYSTORE_FILE = 'add-wallet-with-keystore-file',\n  ADD_WALLET_WITH_LEDGER = 'add-wallet-with-ledger',\n  BLOCKAID_DAPP_SCAN = 'blockaid-dapp-scan',\n  BLOCKAID_DAPP_SCAN_WARNING = 'blockaid-dapp-scan-warning',\n  BLOCKAID_TRANSACTION_SCAN = 'blockaid-transaction-scan',\n  BLOCKAID_JSONRPC_SCAN = 'blockaid-jsonrpc-scan',\n  HALLIDAY_BRIDGE_BANNER = 'halliday-bridge-banner',\n  FIREBASE_CLOUD_MESSAGING = 'firebase-cloud-messaging',\n  ONE_CLICK_SWAP = 'one-click-swap',\n  GASLESS = 'gasless',\n  SOLANA_SUPPORT = 'solana-support',\n  CORE_ASSISTANT = 'core-assistant',\n}\n\nexport enum FeatureFlagEvents {\n  FEATURE_FLAG_UPDATED = 'FeatureFlagEvents: FEATURE_FLAG_UPDATED',\n}\n\nexport type FeatureFlags = Record<FeatureGates, boolean>;\n","import { MessagePayload } from 'firebase/messaging';\nimport {\n  Content,\n  GenerationConfig,\n  Part,\n  Tool,\n  ToolConfig,\n} from 'firebase/vertexai';\n\nexport enum FirebaseEvents {\n  FCM_INITIALIZED = 'FCM_INITIALIZED',\n  FCM_TERMINATED = 'FCM_TERMINATED',\n}\n\nexport type FcmMessageListener = (\n  payload: MessagePayload,\n) => unknown | Promise<unknown>;\n\nexport interface ConfigParams {\n  tools?: Tool[];\n  toolConfig?: ToolConfig;\n  systemInstruction?: string | Part | Content;\n}\nexport interface ChatConfig extends ConfigParams {\n  generationConfig: GenerationConfig;\n}\n","import { DestinationTransferPeerPath, TransactionStatus } from 'fireblocks-sdk';\nimport {\n  AddressResponse as _AddressResponse,\n  PaginatedAddressesResponse as _PaginatedAddressesResponse,\n} from 'fireblocks-sdk';\n\nexport type KnownAddressDictionary = Map<string, DestinationTransferPeerPath>;\n\nexport const TRANSACTION_POLLING_INTERVAL_MS = 2000;\n\nexport const TX_SUBMISSION_FAILURE_STATUSES = [\n  TransactionStatus.BLOCKED,\n  TransactionStatus.CANCELLED,\n  TransactionStatus.CANCELLING,\n  TransactionStatus.TIMEOUT,\n  TransactionStatus.FAILED,\n  TransactionStatus.REJECTED,\n];\n\nexport const BTC_ACCESS_ERROR_PREFIX = `FireblocksBtcAccessError:`;\n\nexport enum FireblocksBtcAccessErrorCode {\n  VaultAccountNotFound,\n  BTCAddressNotFound,\n  InvalidSecretKey,\n  WrongAccountType,\n  SecretsNotConfigured,\n}\n\nexport class FireblocksBtcAccessError extends Error {\n  constructor(public code: FireblocksBtcAccessErrorCode) {\n    super(`${BTC_ACCESS_ERROR_PREFIX}${code}`);\n  }\n}\n\n// On Testnet Fireblocks workspaces, we require the connected vault to have one of those wallets created.\nexport const TESTNET_LOOKUP_ASSETS = [\n  'AVAXTEST', // Avalanche Fuji\n  'ETH_TEST3', // Ethereum Goerli\n  'ETH_TEST4', // Ethereum Rinkeby\n  'ETH_TEST5', // Ethereum Sepolia\n];\n\n// On Mainnet Fireblocks workspaces, we require the connected vault to have one of those wallets created.\n// We need such a wallet to be created, so that we can find the vault account used to connect via WalletConnect.\n// Knowing the vault account allows us to find the matching BTC address.\nexport const MAINNET_LOOKUP_ASSETS = ['AVAX'];\n\nexport const FIREBLOCKS_REQUEST_EXPIRY = 120 * 60; // 2 hours, used only by WalletConnect connections\n\nexport type AddressResponse = Omit<_AddressResponse, 'type'> & {\n  type?: string;\n};\n// this is used as a replacement for PaginatedAddressesResponse from fireblocks sdk\n// due to wrong type declarations\nexport type PaginatedAddressesResponse = Omit<\n  _PaginatedAddressesResponse,\n  'addresses'\n> & {\n  addresses: AddressResponse[];\n};\n","export enum GaslessEvents {\n  SEND_OFFSCREEN_MESSAGE = 'Gasless: SEND_OFFSCREEN_MESSAGE',\n  STATE_UPDATE = 'Gasless: STATE_UPDATE',\n}\n\nexport interface GaslessMessage {\n  name: string;\n  data: string;\n}\n\nexport interface GaslessStateValues {\n  solutionHex?: string;\n  challengeHex?: string;\n  fundTxHex?: string;\n  isFundInProgress?: boolean;\n  fundTxDoNotRetryError?: boolean;\n}\nexport interface GaslessState {\n  solutionHex: string;\n  challengeHex: string;\n  fundTxHex: string;\n  fundTxDoNotRetryError: boolean;\n  isFundInProgress: boolean;\n}\n\nexport enum GaslessPhase {\n  NOT_READY = 'not_ready',\n  NOT_ELIGIBLE = 'not_eligible',\n  READY = 'ready',\n  FUNDING_IN_PROGRESS = 'funding_in_progress',\n  FUNDED = 'funded',\n  ERROR = 'error',\n}\n","import { AnalyzeTxResult } from '@avalabs/bridge-unified';\nimport { NetworkVMType, Transaction } from '@avalabs/vm-module-types';\n\nexport interface TxHistoryItem<VMType = NetworkVMType> extends Transaction {\n  bridgeAnalysis: AnalyzeTxResult;\n  vmType?: VMType;\n}\n","// export * from './all';\nexport * from './account';\nexport * from './actions';\nexport * from './analytics';\nexport * from './app-check';\nexport * from './approvals';\nexport * from './balance';\nexport * from './bridge';\nexport * from './contacts';\nexport * from './currency';\nexport * from './dapp-connection';\nexport * from './debank';\nexport * from './defi';\nexport * from './domain-metadata';\nexport * from './error';\nexport * from './feature-flags';\nexport * from './firebase';\nexport * from './fireblocks';\nexport * from './gasless';\nexport * from './history';\nexport * from './keystone';\nexport * from './keystore';\nexport * from './ledger';\nexport * from './lock';\nexport * from './messages';\nexport * from './navigation-history';\nexport * from './network-fee';\nexport * from './network';\nexport * from './onboarding';\nexport * from './permissions';\nexport * from './secrets';\nexport * from './seedless';\nexport * from './send';\nexport * from './settings';\nexport * from './storage';\nexport * from './tokens';\nexport * from './ui-connection';\nexport * from './ui';\nexport * from './unified-bridge';\nexport * from './util-types';\nexport * from './wallet-connect';\nexport * from './wallet';\nexport * from './web3';\nexport * from './transaction';\nexport * from './notifications';\n","export interface KeystoneSendState {\n  txId: string;\n  signature: string;\n}\n\nexport type CBOR = {\n  cbor: string;\n  type: string;\n};\n\nexport type KeystoneDeviceRequestData = CBOR & {\n  requestId: string;\n  tabId?: number;\n};\n\nexport type KeystoneDeviceResponseData = CBOR & {\n  requestId: string;\n};\n\nexport enum KeystoneEvent {\n  DEVICE_REQUEST = 'KeystoneEvent:device_request',\n}\n\nexport interface KeystoneTransport {\n  requestSignature(cbor: CBOR, tabId?: number): Promise<Buffer>;\n}\n","export type KeystoreFileKeyType = 'mnemonic' | 'singleton';\nexport type AllKeyFileTypes =\n  | KeyFileV2\n  | KeyFileV3\n  | KeyFileV4\n  | KeyFileV5\n  | KeyFileV6;\nexport type AllKeyFileDecryptedTypes =\n  | KeyFileDecryptedV2\n  | KeyFileDecryptedV3\n  | KeyFileDecryptedV4\n  | KeyFileDecryptedV5\n  | KeyFileDecryptedV6;\n\n// V2 #################################\nexport interface KeyFileV2 {\n  salt: string;\n  keys: KeyFileKeyV2[];\n  pass_hash: string;\n  version: string;\n}\n\nexport interface KeyFileKeyV2 {\n  key: string;\n  iv: string;\n  address: string;\n}\n\nexport interface KeyFileDecryptedV2 {\n  version: string;\n  keys: KeyFileKeyDecryptedV2[];\n  activeIndex: number;\n}\n\nexport interface KeyFileKeyDecryptedV2 {\n  key: string;\n}\n\n// V3 #################################\n// Underlying encryption changed.\nexport interface KeyFileV3 {\n  salt: string;\n  keys: KeyFileKeyV3[];\n  pass_hash: string;\n  version: string;\n  warnings: string[];\n}\n\nexport interface KeyFileKeyV3 {\n  key: string;\n  iv: string;\n  address: string;\n}\n\nexport interface KeyFileDecryptedV3 {\n  version: string;\n  keys: KeyFileKeyDecryptedV3[];\n  activeIndex: number;\n}\n\nexport interface KeyFileKeyDecryptedV3 {\n  key: string;\n}\n\n// V4 #################################\n// Avalanche uses bech32 addresses. Removed address field from keys and the warning message.\nexport interface KeyFileV4 {\n  salt: string;\n  keys: KeyFileKeyV4[];\n  pass_hash: string;\n  version: string;\n}\n\nexport interface KeyFileKeyV4 {\n  key: string;\n  iv: string;\n}\n\nexport interface KeyFileDecryptedV4 {\n  version: string;\n  keys: KeyFileKeyDecryptedV4[];\n  activeIndex: number;\n}\n\nexport interface KeyFileKeyDecryptedV4 {\n  key: string;\n}\n\n// V5 #################################\n// Encodes mnemonic phrase as the key.\nexport interface KeyFileV5 {\n  salt: string;\n  keys: KeyFileKeyV5[];\n  pass_hash: string;\n  version: string;\n}\n\nexport interface KeyFileKeyV5 {\n  key: string;\n  iv: string;\n}\n\nexport interface KeyFileDecryptedV5 {\n  version: string;\n  keys: KeyFileKeyDecryptedV5[];\n  activeIndex: number;\n}\n\nexport interface KeyFileKeyDecryptedV5 {\n  key: string;\n}\n\n// V6 #################################\n// Removes pass_hash. Adds activeIndex and a type (mnemonic | singleton) to key\nexport interface KeyFileV6 {\n  salt: string;\n  keys: KeyFileKeyV6[];\n  version: string;\n  activeIndex: number;\n}\n\nexport interface KeyFileKeyV6 {\n  key: string;\n  iv: string;\n  type: KeystoreFileKeyType;\n}\n\nexport interface KeyFileDecryptedV6 {\n  activeIndex: number;\n  version: string;\n  keys: KeyFileKeyDecryptedV6[];\n}\n\nexport interface KeyFileKeyDecryptedV6 {\n  key: string;\n  type: KeystoreFileKeyType;\n}\n\nexport interface AccessWalletMultipleInput {\n  type: 'mnemonic' | 'singleton';\n  key: string;\n}\n\nexport type KeystoreFileContentInfo = {\n  seedPhrasesCount: number;\n  privateKeysCount: number;\n};\n","export interface LedgerDeviceResponseData {\n  requestId: string;\n  method: string;\n  error?: any;\n  result?: any;\n}\n\nexport interface LedgerDeviceRequestData {\n  requestId: string;\n  method: string;\n  params: any;\n}\n\nexport enum LedgerEvent {\n  TRANSPORT_REQUEST = 'LedgerEvent:transport_request',\n  DISCOVER_TRANSPORTS = 'LedgerEvent:discover_transports',\n  TRANSPORT_CLOSE_REQUEST = 'LedgerEvent:transport_close',\n}\n\nexport const LEDGER_VERSION_WARNING_WAS_CLOSED =\n  'LEDGER_VERSION_WARNING_WAS_CLOSED';\n\n/**\n * Ledger app will throw an error if the tx to sign is too large.\n * Approximately `8kb` is the current limit.\n */\nexport const LEDGER_TX_SIZE_LIMIT_BYTES = 8192;\n","export const SESSION_AUTH_DATA_KEY = 'SESSION_AUTH_DATA_KEY';\nexport interface SessionAuthData {\n  password: string;\n  loginTime: number;\n}\n\nexport const LOCK_TIMEOUT = 1000 * 60 * 60 * 12; // 12 hours\nexport enum LockEvents {\n  LOCK_STATE_CHANGED = 'LockServiceEvents:Lock',\n}\n\nexport enum AlarmsEvents {\n  AUTO_LOCK = 'auto-lock',\n}\n\nexport interface LockStateChangedEventPayload {\n  isUnlocked: boolean;\n}\n","import { DAppProviderRequest } from './dapp-connection';\n\nexport enum MessageType {\n  SIGN_TYPED_DATA_V1 = DAppProviderRequest.ETH_SIGN_TYPED_DATA_V1,\n  SIGN_TYPED_DATA_V3 = DAppProviderRequest.ETH_SIGN_TYPED_DATA_V3,\n  SIGN_TYPED_DATA_V4 = DAppProviderRequest.ETH_SIGN_TYPED_DATA_V4,\n  SIGN_TYPED_DATA = DAppProviderRequest.ETH_SIGN_TYPED_DATA,\n  PERSONAL_SIGN = DAppProviderRequest.PERSONAL_SIGN,\n  ETH_SIGN = DAppProviderRequest.ETH_SIGN,\n  AVALANCHE_SIGN = DAppProviderRequest.AVALANCHE_SIGN_MESSAGE,\n}\n\nexport interface MessageDisplayData {\n  data?: any;\n  from?: any;\n  password?: any;\n}\n\nexport type MessageParams = {\n  data: any;\n  from: string;\n  password?: string;\n  accountIndex?: number;\n};\n\nexport type SignMessageData = {\n  messageParams: MessageParams;\n  isMessageValid: boolean;\n  validationError?: string;\n};\n","import * as H from 'history';\n\nexport interface NavigationHistoryDataState {\n  [key: string]: unknown;\n}\n\nexport type NavigationHistoryState = H.History<unknown> | Record<string, never>;\n\nexport interface NavigationHistoryStorage {\n  state: NavigationHistoryState;\n  data: NavigationHistoryDataState;\n}\n\nexport const NAVIGATION_HISTORY_STORAGE_KEY = 'NAVIGATION_HISTORY';\n","export type FeeRate = {\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas?: bigint;\n};\n\nexport interface NetworkFee {\n  displayDecimals: number;\n  baseFee?: bigint;\n  low: FeeRate;\n  medium: FeeRate;\n  high: FeeRate;\n  isFixedFee: boolean;\n}\n\nexport type TransactionPriority = 'low' | 'medium' | 'high';\n\nexport type SerializedNetworkFee = Omit<\n  NetworkFee,\n  'low' | 'medium' | 'high'\n> & {\n  low: bigint;\n  medium: bigint;\n  high: bigint;\n  isFixedFee: boolean;\n};\n","import { Network as _Network } from '@avalabs/core-chains-sdk';\nimport { EnsureDefined, PartialBy } from './util-types';\n\nexport enum NetworkEvents {\n  NETWORK_UPDATE_EVENT = 'network-updated',\n  DEVELOPER_MODE_CHANGED = 'developer-mode-changed',\n  NETWORKS_UPDATED_EVENT = 'networks-updated',\n}\n\nexport const NETWORK_STORAGE_KEY = 'NETWORK_STORAGE_KEY';\nexport const NETWORK_LIST_STORAGE_KEY = 'NETWORK_LIST_STORAGE_KEY';\nexport const NETWORK_OVERRIDES_STORAGE_KEY = 'NETWORK_OVERRIDES_STORAGE_KEY';\n\nexport interface NetworkStorage {\n  favoriteNetworks: number[];\n  customNetworks: Record<number, Network>;\n  dappScopes: Record<string, string>;\n}\n\nexport interface AddEthereumChainParameter {\n  chainId: string;\n  blockExplorerUrls?: string[];\n  chainName?: string;\n  iconUrls?: string[];\n  nativeCurrency?: {\n    name: string;\n    symbol: string;\n    decimals: number;\n  };\n  rpcUrls?: string[];\n  isTestnet?: boolean;\n  requiresGlacierApiKey?: boolean;\n}\n\nexport type Network = _Network &\n  AdvancedNetworkConfig & {\n    caipId?: string;\n  };\n\nexport type NetworkWithCaipId = EnsureDefined<Network, 'caipId'>;\n\nexport type ChainList = Record<string, Network>;\nexport type ChainListWithCaipIds = Record<string, NetworkWithCaipId>;\n\nexport type NetworkOverrides = PartialBy<Network, 'rpcUrl'> &\n  AdvancedNetworkConfig;\n\nexport type CustomRpcHeaders = Record<string, string>;\n\nexport type AdvancedNetworkConfig = {\n  customRpcHeaders?: CustomRpcHeaders;\n};\n\nexport type CustomNetworkPayload = Network & {\n  chainId: number | string; // Chain ID may come in hex-encoded through wallet_addEthereumChain call.\n};\n\nexport type AddEthereumChainDisplayData = {\n  network: EnsureDefined<Network, 'caipId'>;\n  options: {\n    requiresGlacierApiKey: boolean;\n  };\n};\n\nexport const PLACEHOLDER_RPC_HEADERS = { '': '' };\n","export enum NotificationCategories {\n  BALANCE_CHANGES = 'BALANCE_CHANGES',\n  NEWS = 'NEWS',\n}\n\nexport enum BalanceNotificationTypes {\n  BALANCE_CHANGES = 'BALANCE_CHANGES',\n}\n\nexport enum NewsNotificationTypes {\n  PRODUCT_ANNOUNCEMENTS = 'PRODUCT_ANNOUNCEMENTS',\n  OFFERS_AND_PROMOTIONS = 'OFFERS_AND_PROMOTIONS',\n  MARKET_NEWS = 'MARKET_NEWS',\n  PRICE_ALERTS = 'PRICE_ALERTS',\n}\n\nexport enum SubscriptionEvents {\n  SUBSCRIPTIONS_CHANGED_EVENT = 'SUBSCRIPTIONS_CHANGED_EVENT',\n}\n\nexport type NotificationTypes =\n  | BalanceNotificationTypes\n  | NewsNotificationTypes;\n\nexport enum NotificationsEvents {\n  CLIENT_REGISTERED = 'CLIENT_REGISTERED',\n}\n\nexport type NotificationsClientIdStorage = {\n  clientId?: string;\n};\n\nexport type NotificationsBalanceChangesSubscriptionStorage = {\n  isSubscribed: boolean;\n  addresses: string[];\n  chainIds: string[];\n};\n\nexport type NotificationsNewsSubscriptionStorage = Record<\n  NewsNotificationTypes,\n  boolean\n>;\n\nexport type NotificationPayload = {\n  data: {\n    title: string;\n    body: string;\n    event: NotificationTypes;\n    type: NotificationCategories;\n  };\n};\n\nexport type RegisterDeviceResponse = {\n  deviceArn: string;\n};\n","export interface OnboardingState {\n  isOnBoarded: boolean;\n  reImportMnemonic?: boolean;\n  initialOpen: boolean;\n}\n\nexport enum OnboardingPhase {\n  CREATE_WALLET = 'create_wallet',\n  IMPORT_WALLET = 'import_wallet',\n  PASSWORD = 'password',\n  CONFIRM = 'confirm',\n  FINALIZE = 'finalize',\n  RESTART = 'restart',\n  LEDGER = 'ledger',\n  LEDGER_TROUBLE = 'ledger_trouble',\n  ANALYTICS_CONSENT = 'analytics_consent',\n  KEYSTONE = 'keystone',\n  KEYSTONE_TUTORIAL = 'keystone_tutorial',\n  SEEDLESS_GOOGLE = 'seedless_google',\n  SEEDLESS_APPLE = 'seedless_apple',\n}\n\nexport enum OnboardingURLs {\n  ONBOARDING_HOME = '/onboarding',\n  CREATE_WALLET = '/onboarding/create-wallet',\n  SEED_PHRASE = '/onboarding/seed-phrase',\n  KEYSTONE = '/onboarding/keystone',\n  LEDGER = '/onboarding/ledger',\n  CREATE_PASSWORD = '/onboarding/create-password',\n  ANALYTICS_CONSENT = '/onboarding/analytics-consent',\n  LEDGER_TROUBLE = '/onboarding/ledger-trouble',\n  SIGN_IN = '/onboarding/sign-in',\n  RECOVERY_METHODS = '/onboarding/recovery-methods',\n  RECOVERY_METHODS_LOGIN = '/onboarding/recovery-methods-login',\n}\n\nexport const ONBOARDING_EVENT_NAMES = {\n  [OnboardingPhase.CREATE_WALLET]: 'OnboardingCreateNewWalletSelected',\n  [OnboardingPhase.IMPORT_WALLET]: 'OnboardingImportMnemonicSelected',\n  [OnboardingPhase.LEDGER]: 'OnboardingImportLedgerSelected',\n  [OnboardingPhase.KEYSTONE]: 'OnboardingKeystoneSelected',\n  [OnboardingPhase.SEEDLESS_GOOGLE]: 'OnboardingSeedlessGoogleSelected',\n  [OnboardingPhase.SEEDLESS_APPLE]: 'OnboardingSeedlessAppleSelected',\n};\n\nexport enum OnboardingEvents {\n  ONBOARDING_UPDATED_EVENT = 'ONBOARDING_UPDATED_EVENT',\n}\n\nexport const ONBOARDING_STORAGE_KEY = 'onboarding';\n","import { NetworkVMType } from '@avalabs/vm-module-types';\n\nexport interface DappPermissions {\n  domain: string;\n  accounts: {\n    [address: string]: NetworkVMType;\n  };\n}\n\nexport interface Permissions {\n  [domain: string]: DappPermissions;\n}\n\nexport interface PermissionsState {\n  permissions: Permissions;\n}\n\nexport enum PermissionEvents {\n  PERMISSIONS_STATE_UPDATE = 'permissions-state-updated',\n}\n\nexport const PERMISSION_STORAGE_KEY = 'permissions';\n","import { SignerSessionData } from '@cubist-labs/cubesigner-sdk';\nimport { DerivationPath } from '@avalabs/core-wallets-sdk';\nimport { NetworkVMType } from '@avalabs/vm-module-types';\n\nimport {\n  FireblocksApiData,\n  ImportedAccount,\n  PrimaryAccount,\n  WalletConnectAddresses,\n} from './account';\nimport {\n  BtcWalletPolicyDetails,\n  PubKeyType,\n  SeedlessAuthProvider,\n} from './wallet';\n\nexport enum SecretType {\n  // Primary wallet types\n  Mnemonic = 'mnemonic',\n  Ledger = 'ledger',\n  LedgerLive = 'ledger-live',\n  Keystone = 'keystone',\n  Seedless = 'seedless',\n  // Importable wallets types\n  PrivateKey = 'private-key',\n  WalletConnect = 'wallet-connect',\n  Fireblocks = 'fireblocks',\n}\n\nexport type Secp256k1 = 'secp256k1';\nexport type Ed25519 = 'ed25519';\nexport type Curve = Secp256k1 | Ed25519;\nexport const EVM_BASE_DERIVATION_PATH = \"m/44'/60'/0'\";\nexport const AVALANCHE_BASE_DERIVATION_PATH = \"m/44'/9000'/0'\";\n\nexport type AddressPublicKeyJson<HasDerivationPath extends boolean = true> = {\n  type: 'address-pubkey';\n  curve: Curve;\n  derivationPath: HasDerivationPath extends true ? string : null;\n  key: string;\n  btcWalletPolicyDetails?: BtcWalletPolicyDetails;\n};\n\nexport type ExtendedPublicKey = {\n  type: 'extended-pubkey';\n  curve: Secp256k1;\n  derivationPath: string;\n  key: string;\n  btcWalletPolicyDetails?: BtcWalletPolicyDetails;\n};\n\ninterface SecretsBase {\n  secretType: SecretType;\n}\n\ninterface PrimarySecretsBase extends SecretsBase {\n  id: string;\n  name: string;\n  publicKeys: AddressPublicKeyJson[];\n}\n\nexport interface SeedlessSecrets extends PrimarySecretsBase {\n  secretType: SecretType.Seedless;\n  derivationPathSpec: DerivationPath.BIP44;\n  seedlessSignerToken: SignerSessionData;\n  authProvider: SeedlessAuthProvider;\n  userEmail?: string;\n  userId?: string;\n}\n\nexport interface MnemonicSecrets extends PrimarySecretsBase {\n  secretType: SecretType.Mnemonic;\n  mnemonic: string;\n  extendedPublicKeys: ExtendedPublicKey[];\n  derivationPathSpec: DerivationPath.BIP44;\n}\n\nexport interface KeystoneSecrets extends PrimarySecretsBase {\n  secretType: SecretType.Keystone;\n  masterFingerprint: string;\n  extendedPublicKeys: ExtendedPublicKey[];\n  derivationPathSpec: DerivationPath.BIP44;\n}\n\nexport interface LedgerSecrets extends PrimarySecretsBase {\n  secretType: SecretType.Ledger;\n  extendedPublicKeys: ExtendedPublicKey[];\n  derivationPathSpec: DerivationPath.BIP44;\n}\n\nexport interface LedgerLiveSecrets extends PrimarySecretsBase {\n  secretType: SecretType.LedgerLive;\n  derivationPathSpec: DerivationPath.LedgerLive;\n}\n\ninterface ImportedPrivateKeySecrets extends SecretsBase {\n  secretType: SecretType.PrivateKey;\n  secret: string;\n}\n\ninterface ImportedWalletConnectSecrets extends SecretsBase {\n  secretType: SecretType.WalletConnect;\n  addresses: WalletConnectAddresses;\n  pubKey?: PubKeyType;\n}\n\ninterface ImportedFireblocksSecrets extends SecretsBase {\n  secretType: SecretType.Fireblocks;\n  addresses: {\n    addressC: string;\n    addressBTC?: string;\n  };\n  api?: FireblocksApiData;\n}\n\nexport type PrimaryWalletSecrets =\n  | MnemonicSecrets\n  | KeystoneSecrets\n  | LedgerSecrets\n  | LedgerLiveSecrets\n  | SeedlessSecrets;\n\nexport type ImportedAccountSecrets =\n  | ImportedPrivateKeySecrets\n  | ImportedWalletConnectSecrets\n  | ImportedFireblocksSecrets;\n\nexport type AccountWithSeedlessSecrets = Extract<\n  AccountWithSecrets,\n  { secretType: SecretType.Seedless }\n>;\n\nexport type PrimaryAccountWithSecrets = {\n  account: PrimaryAccount;\n} & PrimaryWalletSecrets;\n\nexport type ImportedAccountWithSecrets = {\n  account: ImportedAccount;\n} & ImportedAccountSecrets;\n\nexport type AccountWithSecrets =\n  | PrimaryAccountWithSecrets\n  | ImportedAccountWithSecrets;\n\nexport type DerivedAddresses = {\n  addressC: string;\n  addressBTC?: string;\n  addressAVM?: string;\n  addressPVM?: string;\n  addressCoreEth?: string;\n  addressHVM?: string;\n};\n\nexport type DerivationPathsMap = Record<\n  Exclude<NetworkVMType, NetworkVMType.PVM | NetworkVMType.CoreEth>,\n  string\n>;\n","import { TotpChallenge } from '@cubist-labs/cubesigner-sdk';\n\nexport enum FIDOApiEndpoint {\n  Register = 'register',\n  Authenticate = 'authenticate',\n}\n\nexport type EncodedFIDORegistrationResult = FIDORegistrationResult<true>;\nexport type DecodedFIDORegistrationResult = FIDORegistrationResult<false>;\n\nexport type EncodedFIDOAuthenticationResult = FIDOAuthenticationResult<true>;\nexport type DecodedFIDOAuthenticationResult = FIDOAuthenticationResult<false>;\n\nexport type DecodedFIDOResult =\n  | DecodedFIDORegistrationResult\n  | DecodedFIDOAuthenticationResult;\n\nexport type EncodedFIDOResult =\n  | EncodedFIDORegistrationResult\n  | EncodedFIDOAuthenticationResult;\n\nexport type FIDOApiRequest =\n  | FIDORegistrationRequest\n  | FIDOAuthenticationRequest;\n\nexport enum KeyType {\n  Passkey = 'passkey',\n  Yubikey = 'yubikey',\n}\n\ntype Base64UrlString = string;\n\ntype BufferLikeValue<T> = T extends true ? Base64UrlString : Buffer;\n\ntype FIDORegistrationResult<T> = {\n  id: string;\n  rawId: BufferLikeValue<T>;\n  type?: string;\n  response: {\n    clientDataJSON: BufferLikeValue<T>;\n    attestationObject: BufferLikeValue<T>;\n  };\n};\n\ntype FIDOAuthenticationResult<T> = {\n  id: string;\n  rawId: BufferLikeValue<T>;\n  type?: string;\n  response: {\n    clientDataJSON: BufferLikeValue<T>;\n    authenticatorData: BufferLikeValue<T>;\n    signature: BufferLikeValue<T>;\n    userHandle: BufferLikeValue<T> | null;\n  };\n};\n\ninterface FIDORegistrationRequest {\n  challenge: Buffer;\n  rp: {\n    id: string;\n    name: string;\n  };\n  user: {\n    id: Buffer;\n    name: string;\n    displayName: string;\n  };\n  pubKeyCredParams: Array<{\n    type: string;\n    alg: number;\n  }>;\n  timeout?: number;\n  excludeCredentials?: Array<{\n    type: string;\n    id: Buffer;\n    transports?: Array<string>;\n  }>;\n  authenticatorSelection?: {\n    authenticatorAttachment?: string;\n    requireResidentKey?: boolean;\n    residentKey?: string;\n    userVerification?: string;\n  };\n  attestation?: string;\n  extensions?: Record<string, unknown>;\n}\n\ninterface FIDOAuthenticationRequest {\n  challenge: Buffer;\n  rpId: string;\n  timeout?: number;\n  allowCredentials?: Array<{\n    type: string;\n    id: Buffer;\n    transports?: Array<string>;\n  }>;\n  userVerification?: string;\n  extensions?: Record<string, unknown>;\n}\n\nexport const TOTP_ISSUER = 'Core' as const;\n\nexport class CoreApiError extends Error {}\n\nexport enum SeedlessEvents {\n  TokenExpired = 'token-expired',\n  TokenRefreshed = 'token-refreshed',\n  MfaRequest = 'mfa-request',\n  MfaFailure = 'mfa-failure',\n  MfaClear = 'mfa-clear',\n  MfaMethodsUpdated = 'mfa-methods-updated',\n  MfaChoiceRequest = 'mfa-choice-request',\n}\n\nexport enum MfaRequestType {\n  Totp = 'totp',\n  Fido = 'fido',\n  FidoRegister = 'FidoRegister',\n}\n\nexport type RecoveryMethodTotp = {\n  type: MfaRequestType.Totp;\n};\nexport type RecoveryMethodFido = {\n  id: string;\n  name: string;\n  type: MfaRequestType.Fido;\n};\n\nexport type GetRecoveryMethodsOptions = {\n  excludeFido?: boolean;\n  excludeTotp?: boolean;\n};\nexport type RecoveryMethod = RecoveryMethodFido | RecoveryMethodTotp;\n\nexport enum RecoveryMethodType {\n  Passkey = 'Passkey',\n  Yubikey = 'Yubikey',\n  Authenticator = 'Authenticator',\n}\n\nexport type TotpResetChallenge = Pick<TotpChallenge, 'totpId' | 'totpUrl'>;\n\nexport enum AuthErrorCode {\n  InvalidTotpCode = 'invalid-totp-code',\n  TotpVerificationError = 'totp-verification-error',\n  NoMfaDetails = 'no-mfa-details',\n  UnknownError = 'unknown-error',\n  UnsupportedProvider = 'unsupported-provider',\n  FailedToFetchOidcToken = 'failed-to-fetch-oidc-token',\n  MismatchingEmail = 'mismatching-email',\n  MissingUserId = 'missing-user-id',\n  MismatchingUserId = 'mismatching-user-id',\n  UnsupportedMfaMethod = 'unsupported-mfa-method',\n  FidoChallengeNotApproved = 'fido-challenge-not-approved',\n  FidoChallengeFailed = 'fido-challenge-failed',\n  NoMfaMethodsConfigured = 'no-mfa-methods-configured',\n  WrongMfaResponseAttempt = 'wrong-mfa-response-attempt',\n}\n\nexport enum FidoDeviceType {\n  Passkey = 'Passkey',\n  Yubikey = 'Yubikey',\n}\n\nexport type MfaRequestData = MfaTotpRequest | MfaFidoRequest;\n\nexport type MfaChoiceRequest = {\n  mfaId: string;\n  availableMethods: RecoveryMethod[];\n  tabId?: number;\n};\n\nexport type MfaChoiceResponse = {\n  mfaId: string;\n  chosenMethod: RecoveryMethod;\n};\n\nexport type MfaFidoRequest =\n  | {\n      type: MfaRequestType.Fido;\n      options?: any;\n      mfaId: string;\n      tabId?: number;\n    }\n  | {\n      type: MfaRequestType.FidoRegister;\n      options?: any;\n      keyType: KeyType;\n      mfaId: string;\n      tabId?: number;\n    };\n\nexport type MfaTotpRequest = {\n  type: MfaRequestType.Totp;\n  mfaId: string;\n  options?: never;\n  tabId?: number;\n};\n\nexport type MfaFailureData = {\n  mfaId: string;\n  tabId?: number;\n};\nexport type MfaClearData = MfaFailureData;\n\nexport type MfaResponseData =\n  | {\n      mfaId: string;\n      code: string;\n      answer?: DecodedFIDOResult;\n    }\n  | {\n      mfaId: string;\n      code?: never;\n      answer: any;\n    };\n\nconst ExportRecoveryPhrasePrefix = 'Seedless.ExportRecoveryPhrase';\n\nexport enum SeedlessExportAnalytics {\n  MenuItemClicked = `${ExportRecoveryPhrasePrefix}.MenuItemClicked`,\n  Resigned = `${ExportRecoveryPhrasePrefix}.Resigned`,\n\n  PopupOpened = `${ExportRecoveryPhrasePrefix}.PopupOpened`,\n\n  InitiationStarted = `${ExportRecoveryPhrasePrefix}.InitiationStarted`,\n  InitiationSucceeded = `${ExportRecoveryPhrasePrefix}.InitiationSucceeded`,\n  InitiationFailed = `${ExportRecoveryPhrasePrefix}.InitiationFailed`,\n\n  CancellationStarted = `${ExportRecoveryPhrasePrefix}.CancellationStarted`,\n  CancellationSucceeded = `${ExportRecoveryPhrasePrefix}.CancellationSucceeded`,\n  CancellationFailed = `${ExportRecoveryPhrasePrefix}.CancellationFailed`,\n\n  DecryptionStarted = `${ExportRecoveryPhrasePrefix}.DecryptionStarted`,\n  DecryptionSucceeded = `${ExportRecoveryPhrasePrefix}.DecryptionSucceeded`,\n  DecryptionFailed = `${ExportRecoveryPhrasePrefix}.DecryptionFailed`,\n\n  PhraseCopied = `${ExportRecoveryPhrasePrefix}.PhraseCopied`,\n}\n\nexport enum FIDOSteps {\n  NAMING = 'naming',\n  REGISTER = 'register',\n  LOGIN = 'login',\n  ERROR = 'error',\n}\n\n// When the user wants to login with a FIDO device, we don't get the device exact type (e.g. passkey or yubikey), only we get the tpye it is 'fido\"\n// so we need to handle them as a unit in the login process\nexport enum RecoveryMethodTypes {\n  PASSKEY = 'passkey',\n  TOTP = 'totp',\n  YUBIKEY = 'yubikey',\n  FIDO = 'fido',\n  UNKNOWN = 'unknown',\n}\n","import { TokenWithBalanceBTC } from '@avalabs/vm-module-types';\nexport enum SendErrorMessage {\n  AMOUNT_REQUIRED = 'AMOUNT_REQUIRED',\n  AMOUNT_TOO_LOW = 'AMOUNT_TOO_LOW',\n  ADDRESS_REQUIRED = 'ADDRESS_REQUIRED',\n  C_CHAIN_REQUIRED = 'C_CHAIN_REQUIRED',\n  INVALID_ADDRESS = 'INVALID_ADDRESS',\n  INVALID_NETWORK_FEE = 'INVALID_NETWORK_FEE',\n  INSUFFICIENT_BALANCE = 'INSUFFICIENT_BALANCE',\n  INSUFFICIENT_BALANCE_FOR_FEE = 'INSUFFICIENT_BALANCE_FOR_FEE',\n  EXCESSIVE_NETWORK_FEE = 'EXCESSIVE_NETWORK_FEE',\n  TOKEN_REQUIRED = 'TOKEN_REQUIRED',\n  UNSUPPORTED_TOKEN = 'UNSUPPORTED_TOKEN',\n  UNABLE_TO_FETCH_UTXOS = 'UNABLE_TO_FETCH_UTXOS',\n  UNKNOWN_ERROR = 'UNKNOWN_ERROR',\n  UNSUPPORTED_BY_LEDGER = 'UNSUPPORTED_BY_LEDGER',\n  SEND_NOT_AVAILABLE = 'SEND_NOT_AVAILABLE',\n}\n\nexport type BtcSendOptions = {\n  address: string;\n  amount: number;\n  token: TokenWithBalanceBTC;\n  feeRate: number;\n};\n","import { NetworkContractToken } from '@avalabs/core-chains-sdk';\nimport { EnsureDefined } from './util-types';\n\nexport enum ThemeVariant {\n  LIGHT = 'LIGHT',\n  DARK = 'DARK',\n}\n\nexport enum Languages {\n  EN = 'en',\n  DE = 'de-DE',\n  ES = 'es-EM',\n  FR = 'fr-FR',\n  JA = 'ja-JP',\n  HI = 'hi-IN',\n  KO = 'ko-KR',\n  RU = 'ru-RU',\n  TR = 'tr-TR',\n  ZHCN = 'zh-CN',\n  ZHTW = 'zh-TW',\n}\n\nexport enum LanguageLinks {\n  EN = 'en',\n  DE = 'de',\n  ES = 'es',\n  FR = 'fr',\n  JA = 'ja',\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  HI = 'en', // does not have translated pages in HelpCenter TODO: modify if we are having more external pages with HI language set up\n  KO = 'ko',\n  RU = 'ru',\n  TR = 'tr',\n  ZHCN = 'zh-CN',\n  ZHTW = 'zh-TW',\n}\n\nexport type TokensVisibility = {\n  [key: string]: boolean;\n};\n\nexport type CollectiblesVisibility = {\n  [key: string]: boolean;\n};\n\nexport type AddCustomTokenData = {\n  token: EnsureDefined<NetworkContractToken, 'chainId'>;\n};\n\ntype CustomTokens = {\n  [chain: string]: {\n    [tokenAddress: string]: NetworkContractToken;\n  };\n};\n\nexport interface SettingsState {\n  currency: string;\n  customTokens: CustomTokens;\n  showTokensWithoutBalances: boolean;\n  theme: ThemeVariant;\n  tokensVisibility: TokensVisibility;\n  collectiblesVisibility: CollectiblesVisibility;\n  analyticsConsent: AnalyticsConsent;\n  language: Languages;\n  coreAssistant: boolean;\n}\n\nexport const SETTINGS_STORAGE_KEY = 'settings';\nexport const SETTINGS_UNENCRYPTED_STORAGE_KEY = 'setting_unencrypted';\n\nexport enum SettingsEvents {\n  SETTINGS_UPDATED = 'SettingsEvents: SETTINGS_UPDATED',\n}\n\n// TODO: bring back the commented currencies when the glacier supports them\nexport enum CURRENCIES {\n  USD = 'USD',\n  EUR = 'EUR',\n  GBP = 'GBP',\n  AUD = 'AUD',\n  CAD = 'CAD',\n  CHF = 'CHF',\n  HKD = 'HKD',\n  // JPY: 'JPY',\n  // CNH: 'CNH',\n  // NZD: 'NZD'\n}\n\nexport enum AnalyticsConsent {\n  Pending = 'pending',\n  Approved = 'approved',\n  Denied = 'denied',\n}\n","export const WALLET_STORAGE_ENCRYPTION_KEY = 'WALLET_STORAGE_ENCRYPTION_KEY';\n\nexport interface WalletStorageEncryptionKeyData {\n  storageKey: string;\n}\n\nexport enum KeyDerivationVersion {\n  V1 = 'V1',\n  V2 = 'V2',\n}\n\nexport interface EncryptedData {\n  cypher: number[];\n  nonce: number[];\n  salt?: number[];\n  keyDerivationVersion?: KeyDerivationVersion;\n}\n\nexport interface UnencryptedData<T = any> {\n  data: T;\n}\n","export const TOKENS_PRICE_DATA = 'tokens-price-data';\n\nexport interface PriceChangesData {\n  id: string;\n  symbol: string;\n  name: string;\n  image: string;\n  current_price: number;\n  market_cap: number;\n  market_cap_rank: number;\n  fully_diluted_valuation: number;\n  total_volume: number;\n  high_24h: number;\n  low_24h: number;\n  price_change_24h: number;\n  price_change_percentage_24h: number;\n  market_cap_change_24h: number;\n  market_cap_change_percentage_24h: number;\n  circulating_supply: number;\n  total_supply: number;\n  max_supply: number;\n  ath: number;\n  ath_change_percentage: number;\n  ath_date: string;\n  atl: number;\n  atl_change_percentage: number;\n  atl_date: string;\n  roi: null | {\n    times: number;\n    currency: string;\n    percentage: number;\n  };\n  last_updated: string;\n}\n\nexport interface TokensPriceChangeData {\n  currency: string;\n  lastUpdatedAt: number;\n  priceChanges: TokensPriceShortData;\n}\n\nexport interface TokensPriceShortData {\n  [symbol: string]: {\n    priceChange?: number;\n    priceChangePercentage?: number;\n  };\n}\n\nexport const priceChangeRefreshRate = 1000 * 60 * 60;\n","import { EnsureDefined } from './util-types';\nimport { DomainMetadata } from './domain-metadata';\nimport { TokenType } from '@avalabs/vm-module-types';\n\nexport enum AvalancheChainStrings {\n  AVM = 'X Chain',\n  PVM = 'P Chain',\n  EVM = 'C Chain',\n}\n\nexport enum TransactionType {\n  SEND_TOKEN = 'send_token',\n  SEND_NFT = 'send_nft',\n  APPROVE_TOKEN = 'approve_token',\n  APPROVE_NFT = 'approve_nft',\n  APPROVE_NFT_COLLECTION = 'approve_nft_collection',\n  REVOKE_TOKEN_APPROVAL = 'revoke_token_approval',\n  REVOKE_NFT_APPROVAL = 'revoke_nft_approval',\n  REVOKE_NFT_COLLECTION_APPROVAL = 'revoke_nft_collection_approval',\n  CANCEL_TX = 'cancel_tx',\n  DEPLOY_CONTRACT = 'deploy_contract',\n  SWAP = 'swap',\n  ADD_LIQUIDITY = 'add_liquidity',\n  CALL = 'call',\n}\n\nexport interface TransactionToken {\n  address: string;\n  decimals: number;\n  symbol: string;\n  name: string;\n  logoUri?: string;\n\n  amount?: bigint;\n  usdValue?: number;\n  usdPrice?: number;\n\n  isScam?: boolean;\n  isInfinity?: boolean;\n  isSuspicious?: boolean;\n}\n\nexport interface TransactionNft {\n  type: TokenType.ERC721 | TokenType.ERC1155;\n  address: string;\n  name: string;\n  description: string;\n  logoUri?: string;\n  symbol?: string;\n\n  amount: bigint;\n\n  collection?: {\n    name: string;\n    description: string | null;\n    logoUri: string;\n  };\n\n  isScam?: boolean;\n  isSuspicious?: boolean;\n  size?: number;\n}\n\nexport type TransactionAction =\n  | {\n      type: TransactionType.SEND_TOKEN;\n      fromAddress: string;\n      toAddress: string;\n      token: TransactionToken;\n    }\n  | {\n      type: TransactionType.SEND_NFT;\n      fromAddress: string;\n      toAddress: string;\n      nft: TransactionNft;\n    }\n  | {\n      type:\n        | TransactionType.APPROVE_TOKEN\n        | TransactionType.REVOKE_TOKEN_APPROVAL;\n      spender: {\n        address: string;\n        protocol?: {\n          id: string;\n          name: string;\n          logoUri: string;\n        };\n      };\n      token: TransactionToken;\n      customSpendLimit?: bigint;\n    }\n  | {\n      type: TransactionType.APPROVE_NFT | TransactionType.REVOKE_NFT_APPROVAL;\n      owner: string;\n      spender: {\n        address: string;\n        protocol?: {\n          id: string;\n          name: string;\n          logoUri: string;\n        };\n      };\n      token: TransactionNft;\n    }\n  | {\n      type:\n        | TransactionType.APPROVE_NFT_COLLECTION\n        | TransactionType.REVOKE_NFT_COLLECTION_APPROVAL;\n      owner: string;\n      spender: {\n        address: string;\n        protocol?: {\n          id: string;\n          name: string;\n          logoUri: string;\n        };\n      };\n      collection: {\n        id: string;\n        name: string;\n        description: string;\n        address: string;\n        logoUri: string;\n        type: TokenType.ERC721 | TokenType.ERC1155;\n\n        isScam?: boolean;\n        isSuspicious?: boolean;\n      };\n    }\n  | {\n      type: TransactionType.CANCEL_TX;\n      fromAddress: string;\n    }\n  | {\n      type: TransactionType.DEPLOY_CONTRACT;\n      fromAddress: string;\n    }\n  | {\n      type: TransactionType.CALL;\n      fromAddress: string;\n      contract?: {\n        address: string;\n        protocol?: {\n          id: string;\n          name: string;\n          logoUri: string;\n        };\n      };\n    }\n  | {\n      type: TransactionType.ADD_LIQUIDITY | TransactionType.SWAP;\n      fromAddress: string;\n      contract?: {\n        address: string;\n      };\n    };\n\nexport interface TransactionDisplayValues {\n  fromAddress: string;\n\n  abi?: {\n    func: string;\n    params: unknown[];\n  };\n\n  actions: TransactionAction[];\n\n  gas: {\n    maxPriorityFeePerGas?: bigint;\n    maxFeePerGas: bigint;\n    gasLimit: number;\n    recommendedGasLimit?: number;\n  };\n\n  balanceChange?: {\n    usdValueChange?: number;\n    sendTokenList: TransactionToken[];\n    receiveTokenList: TransactionToken[];\n    sendNftList: TransactionNft[];\n    receiveNftList: TransactionNft[];\n  };\n\n  preExecSuccess?: boolean;\n  isMalicious?: boolean;\n  isSuspicious?: boolean;\n}\n\nexport interface Transaction {\n  site?: DomainMetadata;\n  method: string;\n  chainId: string;\n  txParams: EnsureDefined<EthSendTransactionParamsWithGas, 'chainId'>;\n  displayValues: TransactionDisplayValues;\n  displayOptions?: TxDisplayOptions;\n}\n\nexport interface EthSendTransactionParams {\n  from: string;\n  to?: string;\n  value?: string | bigint;\n  data?: string;\n  gas?: number;\n  gasPrice?: string;\n  maxFeePerGas?: string;\n  maxPriorityFeePerGas?: string;\n  chainId?: string;\n  gasLimit?: string;\n  nonce?: string;\n  type?: number;\n}\n\nexport function isTxParams(\n  params: Partial<EthSendTransactionParams>,\n): params is EthSendTransactionParams {\n  return !!params.from;\n}\n\nexport interface EthSendTransactionParamsWithGas\n  extends EthSendTransactionParams {\n  type: number;\n  gasLimit: string;\n  maxFeePerGas: string;\n}\n\nexport type TxDisplayOptions = {\n  customApprovalScreenTitle?: string;\n  contextInformation?: {\n    title: string;\n    notice?: string;\n  };\n};\n","export enum ExtensionRequest {\n  ONBOARDING_GET_STATE = 'onboarding_getIsOnBoarded',\n  ONBOARDING_SUBMIT = 'onboarding_submit',\n  ONBOARDING_INITIAL_WALLET_OPEN = 'onboarding_initial_wallet_open',\n  MNEMONIC_ONBOARDING_SUBMIT = 'mnemonic_onboarding_submit',\n  SEEDLESS_ONBOARDING_SUBMIT = 'seedless_onboarding_submit',\n  KEYSTONE_ONBOARDING_SUBMIT = 'keystone_onboarding_submit',\n  LEDGER_ONBOARDING_SUBMIT = 'ledger_onboarding_submit',\n\n  NETWORK_SET_ACTIVE = 'network_setActiveNetwork',\n  NETWORK_SET_DEVELOPER_MODE = 'network_setDeveloperMode',\n  NETWORK_ADD_FAVORITE_NETWORK = 'network_add_favorite_networks',\n  NETWORK_REMOVE_FAVORITE_NETWORK = 'network_remove_favorite_network',\n  NETWORK_SAVE_CUSTOM = 'network_saveCustomNetwork',\n  NETWORK_REMOVE_CUSTOM = 'network_removeCustomNetwork',\n  NETWORKS_GET_STATE = 'networks_get_state',\n  NETWORK_UPDATE_DEFAULT = 'network_update_default',\n\n  ACCOUNT_GET_ACCOUNTS = 'account_get',\n  ACCOUNT_SELECT = 'account_select',\n  ACCOUNT_ADD = 'account_add',\n  ACCOUNT_GET_PRIVATEKEY = 'account_get_privatekey',\n\n  SECRETS_APPEND_SOLANA_PUBLIC_KEYS = 'secrets_append_solana_public_keys',\n\n  BALANCES_GET = 'balances_get',\n  BALANCES_START_POLLING = 'balances_start_polling',\n  BALANCES_STOP_POLLING = 'balances_stop_polling',\n  BALANCES_GET_TOTAL_FOR_WALLET = 'balance_get_total_for_wallet',\n  NETWORK_BALANCES_UPDATE = 'network_balances_update',\n  NFT_BALANCES_GET = 'nft_balances_get',\n  NFT_REFRESH_METADATA = 'nft_refresh_metadata',\n  TOKEN_PRICE_GET = 'token_price_get',\n  BALANCE_NATIVE_GET = 'balance_native_get',\n\n  BRIDGE_GET_CONFIG = 'bridge_get_config',\n\n  BRIDGE_GET_STATE = 'bridge_get_state',\n  BRIDGE_TRANSFER_ASSET = 'bridge_transfer_asset',\n  BRIDGE_TRANSACTION_CREATE = 'bridge_transaction_create',\n  BRIDGE_TRANSACTION_REMOVE = 'bridge_transaction_remove',\n  BRIDGE_SET_IS_DEV_ENV = 'bridge_set_is_dev_env',\n  BRIDGE_GET_ETH_MAX_TRANSFER_AMOUNT = 'bridge_get_eth_max_transfer_amount',\n  BRIDGE_ESTIMATE_GAS = 'bridge_estimate_gas',\n\n  WALLET_GET_DETAILS = 'wallet_getDetails',\n  WALLET_UNENCRYPTED_MNEMONIC = 'wallet_getUnencryptedMnemonic',\n  WALLET_GET_BTC_WALLET_POLICY_DETAILS = 'wallet_getBtcWalletPolicyDetails',\n  WALLET_STORE_BTC_WALLET_POLICY_DETAILS = 'wallet_storeBtcWalletPolicyDetails',\n  GET_WALLET_HISTORY = 'wallet_getHistory',\n\n  LOCK_WALLET = 'lock_lock',\n  UNLOCK_WALLET = 'lock_unlock',\n  LOCK_GET_STATE = 'lock_getState',\n  LOCK_CHANGE_PASSWORD = 'lock_changePassword',\n\n  ACTION_GET = 'action_getAction',\n  ACTION_UPDATE = 'action_updateAction',\n  ACTION_UPDATE_TX_DATA = 'action_updateTxData',\n\n  PERMISSIONS_REVOKE_ADDRESS_ACCESS_FOR_DOMAIN = 'permissions_revokeAddressAccessForDomain',\n  PERMISSIONS_GET_PERMISSIONS = 'permissions_getPermissionsForDomain',\n  PERMISSIONS_GET_ALL_PERMISSIONS = 'permissions_getAllPermissions',\n\n  TRANSACTIONS_GET = 'transactions_getTransaction',\n  TRANSACTIONS_UPDATE = 'transactions_updateTransaction',\n\n  SEND_VALIDATE = 'send_validate',\n  SEND_SUBMIT = 'send_submit',\n\n  SETTINGS_GET = 'settings_get',\n  SETTINGS_UPDATE_COLLECTIBLES_VISIBILITY = 'settings_update_collectibles_visibility',\n  SETTINGS_UPDATE_CURRENCY = 'settings_update_currency',\n  SETTINGS_UPDATE_SHOW_NO_BALANCE = 'settings_update_show_no_balance',\n  SETTINGS_UPDATE_THEME = 'settings_update_theme',\n  SETTINGS_UPDATE_TOKENS_VISIBILITY = 'settings_update_tokens_visibility',\n  SETTINGS_ADD_CUSTOM_TOKEN = 'settings_add_custom_token',\n  SETTINGS_GET_TOKEN_DATA = 'settings_get_token_data',\n  SETTINGS_SET_DEFAULT_EXTENSION = 'settings_set_default_extension',\n  SETTINGS_GET_DEFAULT_EXTENSION = 'settings_get_default_extension',\n  SETTINGS_SET_ANALYTICS_CONSENT = 'settings_set_analytics_consent',\n  SETTINGS_SET_LANGUAGE = 'settings_set_language',\n  SETTINGS_SET_CORE_ASSISTANT = 'settings_set_core_assistant',\n\n  CONTACTS_GET = 'contacts_get',\n  CONTACTS_CREATE = 'contacts_create',\n  CONTACTS_UPDATE = 'contacts_update',\n  CONTACTS_REMOVE = 'contacts_remove',\n\n  FAVORITES_CREATE = 'favorites_create',\n  FAVORITES_REMOVE = 'favorites_remove',\n  FAVORITES_GET = 'favorites_get',\n\n  SWAP_GET_RATE = 'swap_get_rate',\n  SWAP_PERFORM = 'swap_perform',\n\n  NETWORK_FEE_GET = 'network_fee_get',\n\n  LEDGER_INIT_TRANSPORT = 'ledger_init_transport',\n  LEDGER_HAS_TRANSPORT = 'ledger_has_transport',\n  LEDGER_RESPONSE = 'ledger_response',\n  LEDGER_REMOVE_TRANSPORT = 'ledger_remove_transport',\n  LEDGER_CLOSE_TRANSPORT = 'ledger_close_transport',\n  SHOW_LEDGER_VERSION_WARNING = 'show_ledger_version_warning',\n  LEDGER_VERSION_WARNING_CLOSED = 'ledger_version_warning_closed',\n  LEDGER_MIGRATE_MISSING_PUBKEYS = 'ledger_migrate_missing_pubkeys',\n\n  KEYSTONE_SUBMIT_SIGNATURE = 'keystone_submit_signature',\n\n  NAVIGATION_HISTORY_GET = 'navigation_history_get',\n  NAVIGATION_HISTORY_SET = 'navigation_history_set',\n  NAVIGATION_HISTORY_DATA_GET = 'navigation_history_data_get',\n  NAVIGATION_HISTORY_DATA_SET = 'navigation_history_data_set',\n\n  ANALYTICS_INIT_IDS = 'analytics_init_ids',\n  ANALYTICS_STORE_IDS = 'analytics_store_ids',\n  ANALYTICS_CLEAR_IDS = 'analytics_clear_ids',\n  ANALYTICS_GET_IDS = 'analytics_get_ids',\n  ANALYTICS_CAPTURE_EVENT = 'analytics_capture_event',\n\n  FEATURE_FLAGS_GET = 'feature_flags_get',\n\n  RESET_EXTENSION_STATE = 'reset_extension_state',\n\n  HISTORY_GET = 'history_get',\n\n  DEFI_GET_PORTFOLIO = 'defi_get_portfolio',\n\n  CURRENCIES_GET_EXCHANGE_RATES = 'currencies_get_exchange_rates',\n\n  GET_NETWORK_TOKENS = 'get_network_tokens',\n\n  WALLET_CONNECT_ESTABLISH_REQUIRED_SESSION = 'wallet_connect_establish_required_session',\n  WALLET_CONNECT_IMPORT_ACCOUNT = 'wallet_connect_import_account',\n\n  FIREBLOCKS_UPDATE_API_CREDENTIALS = 'fireblocks_update_api_credentials',\n\n  SEEDLESS_UPDATE_SIGNER_TOKEN = 'seedless_update_signer_token',\n  SEEDLESS_HAS_TOKEN_EXPIRED = 'seedless_has_token_expired',\n  SEEDLESS_INIT_RECOVERY_PHRASE_EXPORT = 'seedless_init_recovery_phrase_export',\n  SEEDLESS_CANCEL_RECOVERY_PHRASE_EXPORT = 'seedless_cancel_recovery_phrase_export',\n  SEEDLESS_GET_RECOVERY_PHRASE_EXPORT_STATE = 'seedless_get_recovery_phrase_export_state',\n  SEEDLESS_COMPLETE_RECOVERY_PHRASE_EXPORT = 'seedless_complete_recovery_phrase_export',\n  SEEDLESS_SUBMIT_MFA_RESPONSE = 'seedless_submit_mfa_response',\n  SEEDLESS_GET_RECOVERY_METHODS = 'seedless_get_recovery_methods',\n  SEEDLESS_INIT_AUTHENTICATOR_CHANGE = 'seedless_init_authenticator_change',\n  SEEDLESS_COMPLETE_AUTHENTICATOR_CHANGE = 'seedless_complete_authenticator_change',\n  SEEDLESS_CHOOSE_MFA_METHOD = 'seedless_choose_mfa_method',\n  SEEDLESS_ADD_FIDO_DEVICE = 'seedless_add_fido_device',\n  SEEDLESS_REMOVE_FIDO_DEVICE = 'seedless_remove_fido_device',\n  SEEDLESS_REMOVE_TOTP = 'seedless_remove_totp',\n  SEEDLESS_DERIVE_MISSING_KEYS = 'seedless_derive_missing_keys',\n\n  UNIFIED_BRIDGE_GET_FEE = 'unified_bridge_get_fee',\n  UNIFIED_BRIDGE_ESTIMATE_GAS = 'unified_bridge_estimate_gas',\n  UNIFIED_BRIDGE_TRANSFER_ASSET = 'unified_bridge_transfer_asset',\n  UNIFIED_BRIDGE_TRACK_TRANSFER = 'unified_bridge_track_transfer',\n  UNIFIED_BRIDGE_GET_STATE = 'unified_bridge_get_state',\n  UNIFIED_BRIDGE_GET_ASSETS = 'unified_bridge_get_assets',\n\n  WALLET_IMPORT_SEED_PHRASE = 'wallet_import_seed_phrase',\n  WALLET_IMPORT_LEDGER = 'wallet_import_ledger',\n\n  BLOCKAID_DAPP_SCAN = 'blockaid_dapp_scan',\n\n  GASLESS_FETCH_AND_SOLVE_CHALLENGE = 'gasless_fetch_and_solve_challange',\n  GASLESS_FUND_TX = 'gasless_fund_tx',\n  GASLESS_GET_ELIGIBILITY = 'gasless_get_eligibility',\n  GASLESS_SET_HEX_VALUES = 'gasless_set_hex_values',\n  GASLESS_SET_DEFAUlT_STATE_VALUES = 'gasless_set_default_state_values',\n  GASLESS_CREATE_OFFSCREEN = 'gasless_create_offscreen',\n  GASLESS_CLOSE_OFFSCREEN = 'gasless_close_offscreen',\n\n  FIREBASE_SET_MODEL = 'firebase_set_model',\n  FIREBASE_SEND_MESSAGE = 'firebase_send_message',\n\n  NOTIFICATION_SUBSCRIBE = 'notification_subscribe',\n  NOTIFICATION_UNSUBSCRIBE = 'notification_unsubscribe',\n  NOTIFICATION_GET_SUBSCRIPTIONS = 'notification_get_subscriptions',\n}\n\n/* eslint-disable no-prototype-builtins */\n\nimport { Runtime } from 'webextension-polyfill';\nimport { RpcMethod } from '@avalabs/vm-module-types';\n\nimport { ArrayElement } from './util-types';\nimport {\n  DAppProviderRequest,\n  DAppRequestHandler,\n  JsonRpcRequest,\n  JsonRpcRequestPayload,\n} from './dapp-connection';\nimport { ErrorData } from './error';\nimport { EthereumProviderError, EthereumRpcError } from 'eth-rpc-errors';\nimport { SerializedEthereumRpcError } from 'eth-rpc-errors/dist/classes';\n\nexport type ExtensionConnectionMessage<\n  Method extends ExtensionRequest | DAppProviderRequest | RpcMethod = any,\n  Params = any,\n> = JsonRpcRequest<Method, Params>;\n\nexport type HandlerParameters<Type> = ExtractHandlerTypes<Type>['Params'];\n\nexport type ExtensionConnectionMessageResponse<\n  Method extends ExtensionRequest | DAppProviderRequest | RpcMethod = any,\n  Result = any,\n  Params = any,\n> = ExtensionConnectionMessage<Method, Params>['params']['request'] &\n  (\n    | {\n        result: Result;\n        error?: never;\n      }\n    | {\n        result?: never;\n        error:\n          | string\n          | EthereumRpcError<ErrorData>\n          | EthereumProviderError<Params>\n          | SerializedEthereumRpcError;\n      }\n  );\n\nexport interface ExtensionConnectionEvent<V = any> {\n  name: string;\n  value: V;\n}\n\nexport function isConnectionEvent(\n  message: ExtensionConnectionMessageResponse | ExtensionConnectionEvent,\n): message is ExtensionConnectionEvent {\n  return !message.hasOwnProperty('id') && message.hasOwnProperty('name');\n}\n\nexport function isConnectionResponse(\n  message: ExtensionConnectionMessageResponse | ExtensionConnectionEvent,\n): message is ExtensionConnectionMessageResponse {\n  return (\n    message.hasOwnProperty('id') &&\n    !message.hasOwnProperty('name') &&\n    !message.hasOwnProperty('value')\n  );\n}\n\n/**\n * Background handler for messages from the UI.\n * @param Method The ExtensionRequest handled by this handler (only one handler per ExtensionRequest).\n * @param Result Type of the return `result` of the handler.\n * @param Params [Optional] type of `request.params` in the `handle` function.\n * Can be any simple type that is serializable e.g. struct, array, number,\n * string\n */\nexport interface ExtensionRequestHandler<\n  Method extends ExtensionRequest | DAppProviderRequest | RpcMethod,\n  Result,\n  Params = undefined,\n> {\n  method: Method;\n  handle: (\n    rpcCall: ExtensionConnectionMessage<Method, Params>['params'],\n  ) => Promise<ExtensionConnectionMessageResponse<Method, Result, Params>>;\n}\n\ntype ExtractHandlerTypes<Type> =\n  Type extends ExtensionRequestHandler<infer M, infer R, infer P>\n    ? { Method: M; Result: R; Params: P }\n    : Type extends DAppRequestHandler<infer P, infer R>\n      ? {\n          Method: ArrayElement<Type['methods']>;\n          Params: P;\n          Result: R;\n        }\n      : {\n          Method: RpcMethod;\n          Params: Type;\n          Result: string;\n        };\n\ntype ModuleRequestPayload = Record<string, unknown>;\n\n/**\n * The `Handler` type argument is required and must be a reference to a class\n * that implements `ExtensionRequestHandler`.\n */\nexport type RequestHandlerType = <\n  // Reference to a class that implements ExtensionRequestHandler.\n  HandlerOrKnownParams extends\n    | ExtensionRequestHandler<Method, Result, Params>\n    | DAppRequestHandler<Params, Result>\n    | ModuleRequestPayload,\n  // The following type arguments should NOT be provided, they are inferred.\n  Method extends\n    | ExtensionRequest\n    | DAppProviderRequest\n    | RpcMethod = ExtractHandlerTypes<HandlerOrKnownParams>['Method'],\n  Result = Exclude<ExtractHandlerTypes<HandlerOrKnownParams>['Result'], symbol>,\n  Params = ExtractHandlerTypes<HandlerOrKnownParams>['Params'],\n>(\n  message: Omit<JsonRpcRequestPayload<Method, Params>, 'id'>,\n  context?: Record<string, unknown>,\n) => Promise<Result>;\n\ninterface ConnectionEventEmitter {\n  addListener(handler: (event: ExtensionConnectionEvent) => void): void;\n  removeListener(handler: (event: ExtensionConnectionEvent) => void): void;\n}\n\nexport interface ConnectionInfo {\n  domain: string;\n  tabId?: number;\n}\n\nexport type ExtensionEventEmitter = ConnectionEventEmitter;\n\nexport type OffscreenEventEmitter = ConnectionEventEmitter;\nexport interface DAppEventEmitter extends ConnectionEventEmitter {\n  setConnectionInfo(connectionInfo: ConnectionInfo): void;\n}\nexport interface JSONRPCRequestWithDomain extends JsonRpcRequest<any> {\n  domain: string;\n}\n\nexport const CORE_DOMAINS = [\n  'localhost',\n  '127.0.0.1',\n  'core-web.pages.dev',\n  'core.app',\n  'test.core.app',\n  'ava-labs.github.io', // playground\n  'avacloud.io',\n  'avacloud-app.pages.dev',\n  'redesign-aa3.pages.dev',\n];\n\nexport interface ConnectionController {\n  connect(connection: Runtime.Port): void;\n  disconnect(): void;\n}\n","export enum ContextContainer {\n  POPUP = '/popup.html', // this is extension when it opens\n  CONFIRM = '/confirm.html', // this is used for confirms from dApps\n  HOME = '/home.html', // This is used for tabs where the wallet is opened\n  FULLSCREEN = '/fullscreen.html', // This is used for flows that are performed in a full tab (i.e. first ledger connection, seedless MFA setups, etc.)\n}\n","import type {\n  BridgeAsset,\n  BridgeStepDetails,\n  BridgeTransfer,\n  ChainAssetMap,\n} from '@avalabs/bridge-unified';\nimport { FeatureGates } from './feature-flags';\n\nexport type UnifiedBridgeState = {\n  pendingTransfers: Record<string, BridgeTransfer>;\n};\n\nexport const UNIFIED_BRIDGE_TRACKED_FLAGS = [\n  FeatureGates.UNIFIED_BRIDGE_CCTP,\n  FeatureGates.UNIFIED_BRIDGE_ICTT,\n  FeatureGates.UNIFIED_BRIDGE_AB_AVA_TO_BTC,\n  FeatureGates.UNIFIED_BRIDGE_AB_BTC_TO_AVA,\n  FeatureGates.UNIFIED_BRIDGE_AB_EVM,\n];\n\nexport const UNIFIED_BRIDGE_DEFAULT_STATE: UnifiedBridgeState = {\n  pendingTransfers: {},\n};\n\nexport const UNIFIED_BRIDGE_STATE_STORAGE_KEY = 'UNIFIED_BRIDGE_STATE';\n\nexport enum UnifiedBridgeEvent {\n  StateUpdated = 'UNIFIED_BRIDGE_STATE_UPDATED',\n  TransferStepChange = 'UNIFIED_BRIDGE_TRASNFER_STEP_CHANGE',\n  AssetsUpdated = 'UNIFIED_BRIDGE_ASSETS_UPDATED',\n}\n\nexport type UnifiedBridgeStateUpdateEvent = {\n  name: UnifiedBridgeEvent.StateUpdated;\n  value: UnifiedBridgeState;\n};\n\nexport type UnifiedBridgeTransferStepChangeEvent = {\n  name: UnifiedBridgeEvent.TransferStepChange;\n  value: BridgeStepDetails;\n};\n\nexport type UnifiedBridgeAssetsUpdated = {\n  name: UnifiedBridgeEvent.AssetsUpdated;\n  value: ChainAssetMap;\n};\n\nexport type UnifiedBridgeTransferParams = {\n  asset: BridgeAsset;\n  amount: bigint;\n  targetChainId: number;\n  sourceChainId: number;\n  tabId?: number;\n};\n\nexport type UnifiedBridgeEstimateGasParams = Pick<\n  UnifiedBridgeTransferParams,\n  'amount' | 'asset' | 'targetChainId' | 'sourceChainId'\n>;\n","export type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\n// A helper generic that turns only given keys (K) of type T\n// from optional to required.\nexport type EnsureDefined<T, K extends keyof T> = T & Required<Pick<T, K>>;\n\n// A helper generic that turns all keys of given type to \"never\" defined.\nexport type Never<T> = {\n  [P in keyof T]?: never;\n};\n\nexport type ArrayElement<A> = A extends readonly (infer T)[] ? T : never;\n\nexport type FirstParameter<T extends (...args: any) => any> = T extends (\n  ...args: infer P\n) => any\n  ? P[0]\n  : never;\n\nexport const ACTION_HANDLED_BY_MODULE = '__handled.via.vm.modules__';\n\nexport const DEFERRED_RESPONSE: unique symbol = Symbol();\n\nexport type ExcludeUndefined<T extends Record<PropertyKey, unknown>> = {\n  [K in keyof T as T[K] extends undefined ? never : K]: T[K];\n};\n\nexport type PickKeys<T, K extends (keyof T)[]> = Omit<T, K[number]>;\n","import { SessionTypes } from '@walletconnect/types';\n\nexport enum WalletConnectEvent {\n  UriGenerated = 'WalletConnect:uri_generated',\n  SessionPermissionsMismatch = 'WalletConnect:session_permissions_mismatch',\n}\n\nexport type WalletConnectUriGeneratedEvent = {\n  uri: `wc:${string}`;\n  tabId?: number;\n};\n\nexport type WalletConnectSessionPermissionsMismatch = {\n  activeSession: WalletConnectSessionInfo;\n  requiredPermissions: {\n    address: string;\n    chainId: number;\n  };\n  tabId?: number;\n};\n\nexport type WalletConnectEventType =\n  | WalletConnectUriGeneratedEvent\n  | WalletConnectSessionPermissionsMismatch;\n\nexport const CORE_MOBILE_WALLET_ID = 'c3de833a-9cb0-4274-bb52-86e402ecfcd3';\n\nexport const FIREBLOCKS_APP_NAME = 'Fireblocks';\n\nexport type WalletConnectSessionInfo = {\n  addresses: [string, ...string[]];\n  topic: string;\n  chains: [number, ...number[]];\n  walletApp: SessionTypes.Struct['peer']['metadata'] & { walletId?: string };\n};\n\nexport const isProposalExpiredError = (err: any) =>\n  err instanceof Error && err.message === 'Proposal expired';\n\nexport const isNoMatchingKeyError = (err: any) =>\n  err instanceof Error && err.message.includes('No matching key');\n\nexport enum WalletConnectErrorCode {\n  NoAccountsConnected = 'no-accounts-connected',\n  NoClient = 'client-not-initialized',\n  ClientInitFailed = 'client-init-failed',\n  ProposalExpired = 'proposal-expired',\n  IncorrectAddress = 'incorrect-address',\n  UnknownError = 'unknown-error',\n  UserRejected = 'user-rejected',\n}\n\nexport class WalletConnectError extends Error {\n  code: WalletConnectErrorCode;\n  originalError?: Error;\n\n  constructor(\n    message: string,\n    code: WalletConnectErrorCode,\n    originalError?: Error,\n  ) {\n    super(message);\n    this.code = code;\n    this.originalError = originalError;\n  }\n}\n\nexport type ConnectOptions = {\n  chainId: number;\n  tabId?: number;\n  address?: string;\n};\n\nexport type RequestPayload = {\n  method: string;\n  params: unknown[] | Record<string, unknown>;\n};\n\nexport type RequestOptions = {\n  chainId: number;\n  fromAddress: string;\n  tabId?: number;\n  expiry?: number; // in seconds, between 300 (5 minutes) and 604800 (7 days)\n};\nexport interface WalletConnectTransport {\n  connect(options: ConnectOptions): Promise<WalletConnectSessionInfo | never>;\n  request<T = string>(\n    payload: RequestPayload,\n    options: RequestOptions,\n  ): Promise<T | never>;\n  getSessionInfo(\n    lookupAddress: string,\n    chainId?: number,\n  ): Promise<null | WalletConnectSessionInfo>;\n}\n","import type { UnsignedTx } from '@avalabs/avalanchejs';\nimport type {\n  BitcoinInputUTXO,\n  BitcoinOutputUTXO,\n  DerivationPath,\n} from '@avalabs/core-wallets-sdk';\nimport { RpcMethod, SigningData } from '@avalabs/vm-module-types';\nimport { DistributiveOmit } from '@core/common';\nimport { type FireblocksApiData, type ImportType } from './account';\nimport {\n  type ImportedAccountSecrets,\n  type PrimaryWalletSecrets,\n  SecretType,\n} from './secrets';\nimport type { TransactionRequest } from 'ethers';\nimport { TransactionPayload, VMABI } from 'hypersdk-client';\n\nexport interface HVMTransactionRequest {\n  txPayload: TransactionPayload;\n  abi: VMABI;\n}\n\nexport type SolanaSigningRequest = Extract<\n  SigningData,\n  {\n    type:\n      | RpcMethod.SOLANA_SIGN_AND_SEND_TRANSACTION\n      | RpcMethod.SOLANA_SIGN_TRANSACTION\n      | RpcMethod.SOLANA_SIGN_MESSAGE;\n  }\n>;\n\nexport type SignTransactionRequest =\n  | TransactionRequest\n  | BtcTransactionRequest\n  | AvalancheTransactionRequest\n  | HVMTransactionRequest\n  | SolanaSigningRequest;\n\nexport const isSolanaRequest = (\n  sigReq: SignTransactionRequest,\n): sigReq is SolanaSigningRequest =>\n  'type' in sigReq &&\n  (sigReq.type === RpcMethod.SOLANA_SIGN_AND_SEND_TRANSACTION ||\n    sigReq.type === RpcMethod.SOLANA_SIGN_TRANSACTION ||\n    sigReq.type === RpcMethod.SOLANA_SIGN_MESSAGE);\n\nexport const isSolanaMsgRequest = (\n  sigReq: SolanaSigningRequest,\n): sigReq is Extract<\n  SolanaSigningRequest,\n  { type: RpcMethod.SOLANA_SIGN_MESSAGE }\n> => sigReq.type === RpcMethod.SOLANA_SIGN_MESSAGE;\n\nexport interface BtcTransactionRequest {\n  inputs: BitcoinInputUTXO[];\n  outputs: BitcoinOutputUTXO[];\n}\n\nexport interface AvalancheTransactionRequest {\n  tx: UnsignedTx;\n  externalIndices?: number[];\n  internalIndices?: number[];\n}\n\nexport interface WalletLockedState {\n  locked: boolean;\n}\n\nexport type WalletSecretInStorage = {\n  wallets: PrimaryWalletSecrets[];\n  importedAccounts?: Record<string, ImportedAccountSecrets>;\n};\n\nexport type PrivateKeyWalletData = {\n  type: ImportType.PRIVATE_KEY;\n  secret: string;\n};\n\nexport type WalletConnectWalletData = {\n  type: ImportType.WALLET_CONNECT;\n  addresses: {\n    addressC: string;\n  };\n  pubKey?: PubKeyType;\n};\n\nexport type FireblocksWalletData = {\n  type: ImportType.FIREBLOCKS;\n  addresses: {\n    addressC: string;\n    addressBTC?: string;\n  };\n  api?: FireblocksApiData;\n};\n\nexport type ImportedWalletData =\n  | PrivateKeyWalletData\n  | WalletConnectWalletData\n  | FireblocksWalletData;\n\nexport enum WalletEvents {\n  WALLET_STATE_UPDATE = 'wallet-state-updated',\n}\n\nexport const WALLET_STORAGE_KEY = 'wallet';\n\nexport const SUPPORTED_PRIMARY_SECRET_TYPES = [\n  SecretType.Mnemonic,\n  SecretType.Keystone,\n  SecretType.Ledger,\n  SecretType.LedgerLive,\n  SecretType.Seedless,\n];\n\nexport type WalletMetadata = {\n  id: string;\n  name?: string;\n};\n\nexport type WalletDetails =\n  | {\n      id: string;\n      type: SecretType;\n      name?: string;\n      derivationPath: DerivationPath;\n      authProvider?: never;\n      userEmail?: never;\n      userId?: never;\n    }\n  | {\n      id: string;\n      type: SecretType.Seedless;\n      name?: string;\n      derivationPath: DerivationPath;\n      authProvider: SeedlessAuthProvider;\n      userEmail?: string;\n      userId?: string;\n    };\n\nexport type WalletsInfo = {\n  activeWallet?: WalletDetails;\n  wallets: WalletMetadata[];\n};\n\nexport enum SeedlessAuthProvider {\n  Google = 'google',\n  Apple = 'apple',\n}\n\nexport type BtcWalletPolicyDetails = {\n  hmacHex: string;\n  /**\n   * Extended public key of m/44'/60'/n\n   */\n  xpub: string;\n  masterFingerprint: string;\n  name: string;\n};\n\n/**\n * Used for Ledger Live accounts on ledger.\n */\nexport type PubKeyType = {\n  evm: string;\n  /**\n   * Public keys used for X/P chain are from a different derivation path.\n   */\n  xp?: string;\n  svm?: string;\n  btcWalletPolicyDetails?: BtcWalletPolicyDetails;\n  ed25519?: string;\n};\n\nexport type SigningResult =\n  | { txHash: string; signedTx?: never }\n  | { signedTx: string; txHash?: never };\n\ntype PrimaryWalletSecretsWithOptionalName = DistributiveOmit<\n  PrimaryWalletSecrets,\n  'name'\n> & {\n  name?: string;\n};\n\nexport type AddPrimaryWalletSecrets = DistributiveOmit<\n  PrimaryWalletSecretsWithOptionalName,\n  'id'\n>;\n\nexport type ImportSeedphraseWalletParams = {\n  mnemonic: string;\n  name?: string;\n};\n\nexport type ImportLedgerWalletParams = {\n  xpub: string;\n  xpubXP: string;\n  pubKeys?: PubKeyType[];\n  secretType: SecretType.Ledger | SecretType.LedgerLive;\n  name?: string;\n  dryRun?: boolean;\n  numberOfAccountsToCreate?: number;\n};\n\nexport type ImportWalletResult = {\n  type: SecretType;\n  name?: string;\n  id: string;\n};\n","export enum WalletExtensionType {\n  CORE = 'CORE',\n  METAMASK = 'METAMASK',\n  UNKNOWN = 'UNKNOWN',\n  RABBY = 'RABBY',\n  COINBASE = 'COINBASE',\n  PHANTOM = 'PHANTOM',\n  ZERION = 'ZERION',\n  KEPLR = 'KEPLR',\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AC5CA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;ACjCA;AAGA;AAEA;;;;;;;;;;;ACLA;AAEA;AACA;;AAGA;;;;;AAQA;;;;;;;;;;;;;;AAZA;AAsCA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;AC9CA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;AClBA;AACA;AACA;AACA;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;;;;;;;;;;;;;AClBA;AASA;AAIA;AAKA;AAIA;;;;;;;;;;;;;ACtBA;;;;;;;;;ACEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAOA;AAEA;AACA;AAKA;AAEA;AACA;;;;;;;;;;ACjDA;;;;AAAA;AAIA;AAEA;;;AAAA;AAAA;AAKA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;AC7CA;AAIA;AACA;;;;;;;;;;;;;;;;ACLA;AACA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAIA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;AC9DA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;ACvBA;AACA;AACA;;;;;;;;;;ACEA;AAEA;AAMA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;;;;;;;;;ACCA;AAGA;AACA;AACA;AAEA;AACA;;;;;;;;;ACRA;AAGA;AACA;AACA;AACA;AAGA;;;;;;;;;;;;ACdA;AAEA;AAEA;AACA;AACA;;;;;;;;;;;;;ACNA;AAEA;AAEA;AAEA;AAMA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAKA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChFA;AAWA;AAGA;AACA;AAEA;AAGA;AACA;AAEA;AAGA;AACA;AAEA;AAKA;;;;;;;;;;;;AChCA;AACA;AACA;AACA;;;;AAAA;AAAA;AAMA;;AAEA;AAKA;AAQA;AACA;AAGA;AAKA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;ACzCA;AAKA;AAMA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;ACxBA;AAEA;AAGA;AACA;AACA;AAEA;AACA;;;;;;;;;;ACZA;AAGA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACPA;AAEA;AACA;AAKA;;;;;;;;;ACLA;AAGA;AACA;;;;;;;;;;ACHA;AAEA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AAKA;AACA;AAGA;;;;;;AAAA;AAMA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAMA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AClJA;AAoBA;AAQA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAEA;AACA;;;;;;;;;;;ACpDA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AAEA;AACA;AACA;AAEA;AAUA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;;;;;;;;;;;;;AC5GA;AAEA;AACA;AAOA;AAKA;AACA;AACA;AAEA;AAGA;AAEA;;;;;;;;;;;;ACxBA;AAGA;AAGA;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;ACbA;AAEA;AACA;AACA;AACA;;;;;;ACLA;AACA;AAEA;;;;;;;;;;;;ACHA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;;;;;;;;;;AC5BA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;ACNA;AACA;AAYA;AACA;AAUA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;ACzDA;;;;;;;;;ACMA;;;AAGA;AAMA;AACA;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAGA;;;;AAIA;AAGA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AAEA;AACA;AACA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;ACpJA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;ACfA;AAEA;AACA;AACA;;;;;;;;;;ACJA;AAGA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACrBA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACFA;AACA;AACA;AACA;;;;;;;;;;ACJA;AAEA;AAIA;AACA;AACA;AAEA;AAGA;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACdA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;ACvBA;AAIA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1EA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;ACRA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;;;;;;;;;;;;AC5BA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAEA;;AAEA;AAEA;AACA;;;;;;;;;;ACpBA;AAEA;;AAEA;AAeA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjCA;AAEA;AAKA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;ACfA;AAGA;AACA;;;;;;;;;;ACXA;AAEA;;;;;;;;;;;;;ACFA;AACA;;;;;;;;;;ACEA;AAKA;AACA;AAEA;AAGA;AACA;;;;;;;;;ACfA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;;;;;;AASA;AAOA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrGA;AAEA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;AC5CA;AAEA;AACA;AACA;;;;;;;;;;ACJA;AAKA;;;;AAIA;AAEA;AAIA;;;;;;;;;;;;ACdA;AACA;AACA;AAEA;AACA;AAOA;AAAA;AAAA;AAAA;AACA;AAEA;AAMA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AC1BA;AACA;AACA;;;;;;;;;ACFA;AACA;AAIA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACpBA;AAEA;AAGA;AACA;;;;;;;;;;ACNA;AAEA;AACA;AACA;;;;;;;;;;;ACJA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;ACVA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;ACRA;AACA;AAGA;AAGA;AACA;AACA;AAEA;AACA;;;;;;;;;;ACZA;AAMA;AAGA;AACA;;;;;;;;;;;;;;ACVA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;;;AAGA;AAGA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAGA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AAOA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACFA;;;AAGA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7FA;AACA;AACA;AAEA;AAiBA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAQA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACjQA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAOA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;;;ACrHA;AACA;AACA;AAAA;AAAA;AAEA;;;;;;;;;ACDA;AAGA;AACA;AACA;;;;;;;;;ACRA;AAOA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AC1BA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;ACnBA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACVA;AAOA;AACA;AAIA;AAQA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AASA;AAAA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAMA;AAEA;AACA;AAKA;AAGA;AACA;AACA;AACA;;;;;;;;;;;ACnFA;AAEA;AACA;AACA;AAEA;AACA;AAKA;;;;;;;;;;;ACZA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;;;;;;;;;;;ACbA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;;;;;;;;;;;ACdA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;ACRA;AAEA;AACA;AACA;AAEA;AACA;AAMA;;;;;;;;;;;ACbA;AAEA;AACA;AACA;AAEA;AACA;AAKA;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACTA;AACA;AAKA;AAEA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;AC5BA;AAEA;AAGA;;;;;;;AAOA;AAKA;AACA;AACA;;;;;;;;;;;ACnBA;AAMA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;ACVA;AACA;AAKA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;AC7CA;AAMA;AAGA;AACA;AAEA;AAGA;AACA;;;;;;;;;AChBA;AACA;AACA;;;;;;;;;;;;;ACFA;AAEA;AAGA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;ACpBA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;;ACNA;AAKA;AAIA;AACA;;;;;;;;;ACZA;;;;;;;;;;;;;;AAcA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvBA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;ACNA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;ACNA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAIA;;;;;;;;;;ACXA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;AC1BA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;AClBA;AACA;AAEA;AAIA;AAIA;AACA;AAEA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;AC7BA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACJA;AAEA;AAMA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;AChFA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAMA;AAEA;AAIA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC5CA;AACA;AAKA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAKA;AACA;AAEA;AACA;;;;;;;;;;;;;;AC3DA;AAYA;;;;;;AAMA;AAEA;AACA;AAEA;;;;;;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AAEA;AACA;AAEA;;;;;;AAMA;AAIA;AAOA;AAEA;;;;;;;;;;;;AAYA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;;;;ACtGA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;;;;;;;;;;ACnBA;AAOA;AAGA;AACA;AAMA;AACA;;;;;;;;;AClBA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;;;;;;;AC9BA;AAQA;AAGA;AAIA;AAEA;AAGA;AAKA;AAEA;AAGA;AACA;AAEA;AAGA;AACA;;;;;;;;;;;;;;;;;ACrCA;AAMA;AAIA;AACA;AAGA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AAEA;AAQA;AAEA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AACA;;;;;;;;;;;ACnFA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;;;;;;;;;;ACpBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACRA;;AAEA;;;;;;;;;;ACFA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;;;;;;;;;ACvBA;AACA;AACA;AAEA;AACA;;;;;;;;;;ACLA;AAIA;;;;;;;;;;;ACJA;AAMA;;;;;AAKA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;AC7BA;AAQA;AAGA;AACA;AAEA;AAGA;AACA;AAEA;AAGA;AAEA;AACA;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAUA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;ACnDA;;;;;AAAA;AAKA;AAIA;;;;AAAA;AAIA;AACA;AAIA;AACA;AACA;AACA;AA6FA;AAEA;;;AAAA;AAGA;AAEA;;;;;;AAAA;AAMA;AAiBA;;;AAAA;AAGA;AAOA;;;;;;;;;;;;;;;ACpJA;AACA;;AAEA;;AAEA;;;;AALA;AASA;AAEA;;;AAAA;AAGA;AAmDA;AAEA;;;AAAA;AAGA;AAEA;;;AAAA;AAGA;AAQA;AAIA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnFA;;AAAA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;;;;;AAAA;AAKA;;;;;;;;;;AC/BA;;;AAAA;AAGA;AAEA;;;AAAA;AAGA;;;;;;;;;ACZA;;AAAA;AAEA;;;;;;;;;;;;;;ACCA;AAEA;;AAAA;AAEA;AA6DA;;AAAA;;AAEA;AAEA;AAKA;AAUA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;AC1FA;;;AAAA;AAGA;AA6BA;;;;AAAA;AAIA;AAEA;AAEA;AACA;AACA;AACA;;;;;;;;;;AC/CA;;AAAA;AAEA;AAEA;;;;;;;;;;;;;;;ACVA;AASA;AACA;AACA;AACA;AAEA;;AAAA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAEA;;;;;;;;;;;AClBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAuCA;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAVA;AAYA;AAsEA;AAaA;;;;;;;;;AChJA;AACA;AAsHA;;;;;;;;;;;;AAAA;AAYA;;;;;;;;;;AChGA;;;;;;;;AAAA;AAQA;AAkEA;;AAAA;AAEA;;;;;;AC1GA;;;;;;;;;;;;;;;;;;;;ACOA;;;;;AAAA;AAKA;AAEA;;;;;;;;;;;;AAAA;AAYA;AAEA;;;;;AAAA;AAKA;AAEA;;AAAA;AAEA;AAEA;;;;;;;AAAA;AAOA;AAEA;;AAAA;AAEA;AAEA;;;;;;;AAAA;AAOA;AAEA;;;;;;;;;;;;;;;AAAA;AAeA;AAEA;;;AAAA;AAGA;AAEA;;;;;;;;;;;AAAA;AAWA;AAEA;;;;;AAAA;AAKA;AAEA;;AAAA;AAEA;;;;;;;;;;AC9GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAyDA;AAEA;;AAAA;AAEA;;;;;;;;;ACpDA;;;AAAA;AAGA;;;;;;;;;;;;;;;;;;ACZA;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;;AAAA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;;;;;;;;;;AChDA;;;AAAA;AAGA;AAsBA;;;;;;;AAAA;AAOA;;;;;;AC7BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACzBA;;AAAA;AAEA;;;;;;AC0HA;;;;;;;;;;;AClIA;;;;AAAA;AAIA;AAEA;AAGA;;;AAGA;;;;;;;;;;;;ACzBA;AAMA;AACA;;AAAA;AAEA;AAEA;;AAAA;AAEA;;;;;;;;;;ACbA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAQA;;;;;;;;;ACGA;;;;;;ACGA;;;;;;;;;;;;;ACbA;;;;AAAA;AAIA;AAEA;AACA;AACA;AAqDA;AAAA;AAAA;;;;;;;;;;;;;AChEA;;;AAAA;AAGA;AAEA;;AAAA;AAEA;AAEA;;;;;AAAA;AAKA;AAEA;;AAAA;AAEA;AAMA;;AAAA;AAEA;;;;;;;;;;;;;ACpBA;;;;;;;;;;;;;;AAAA;AAcA;AAEA;;;;;;;;;;;;AAAA;AAYA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAAA;AAEA;AAEA;;;;;;;;;;AChCA;;AAAA;AAEA;AAEA;;;;;;;;;;;ACLA;AACA;;;;;;AAMA;;;;AAPA;AAWA;AAKA;AACA;;;;;;;;;;;;;;;;;;;;AC/BA;;;AAAA;AAGA;AAoBA;;;AAAA;AAGA;AAwEA;AAEA;AAAA;AAEA;;;;;;;;AAAA;AAQA;AAEA;;;;AAAA;AAIA;AAiBA;;;;AAAA;AAIA;AAIA;;;;;;;;;;;;;;;AAAA;AAeA;AAEA;;;AAAA;AAGA;AAuDA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAlBA;AAmBA;AAEA;;;;;AAAA;AAKA;AAEA;AACA;AACA;;;;;;AAAA;AAMA;;;;;;;;;AC/PA;;;;;;;;;;;;;;;;AAAA;AAgBA;;;;;;;;;;;;;;;;ACdA;;;AAAA;AAGA;AAEA;;;;;;;;;;;;AAAA;AAYA;AAEA;;;;;;AAMA;;;;;;;AANA;AAaA;AAgCA;AACA;AAEA;;AAAA;AAEA;AAEA;AACA;;;;;;;;AAAA;AAWA;AAEA;;;;AAAA;AAIA;;;;;;;;;;AC5FA;AAMA;;;AAAA;AAGA;;;;;;;;;;ACTA;AAgDA;;;;;;;;;;;AC5CA;;;;AAAA;AAIA;AAEA;;;;;;;;;;;;;;AAAA;AAcA;AA2LA;AAGA;AACA;;;;;;;;;;;;ACvNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAmLA;AAkDA;AAGA;AACA;AAEA;AAGA;AAKA;AAgFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7UA;;;;;AAAA;AAKA;;;;;;;;;;;;;ACCA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;;;;AAAA;AAIA;;;;;;;;;;ACXA;AAEA;;;;;;;;;;;;;;;ACnBA;;;AAAA;AAGA;AAoBA;AAEA;AASA;AAGA;AAGA;;;;;;;;AAAA;AAQA;AAEA;AAIA;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3DA;AAGA;AA8BA;AAQA;AAsDA;;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAgCA;;;AAAA;AAGA;;;;;;;;;ACpJA;;;;;;;;;AAAA;AASA"}