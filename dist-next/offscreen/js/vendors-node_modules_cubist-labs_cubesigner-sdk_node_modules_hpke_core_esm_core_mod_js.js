"use strict";
(globalThis["webpackChunk_core_offscreen"] = globalThis["webpackChunk_core_offscreen"] || []).push([["vendors-node_modules_cubist-labs_cubesigner-sdk_node_modules_hpke_core_esm_core_mod_js"], {
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/_dnt.shims.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  dntGlobalThis: () => (dntGlobalThis)
});
const dntGlobals = {};
const dntGlobalThis = createMergeProxy(globalThis, dntGlobals);
function createMergeProxy(baseObj, extObj) {
    return new Proxy(baseObj, {
        get(_target, prop, _receiver) {
            if (prop in extObj) {
                return extObj[prop];
            }
            else {
                return baseObj[prop];
            }
        },
        set(_target, prop, value) {
            if (prop in extObj) {
                delete extObj[prop];
            }
            baseObj[prop] = value;
            return true;
        },
        deleteProperty(_target, prop) {
            let success = false;
            if (prop in extObj) {
                delete extObj[prop];
                success = true;
            }
            if (prop in baseObj) {
                delete baseObj[prop];
                success = true;
            }
            return success;
        },
        ownKeys(_target) {
            const baseKeys = Reflect.ownKeys(baseObj);
            const extKeys = Reflect.ownKeys(extObj);
            const extKeysSet = new Set(extKeys);
            return [...baseKeys.filter((k) => !extKeysSet.has(k)), ...extKeys];
        },
        defineProperty(_target, prop, desc) {
            if (prop in extObj) {
                delete extObj[prop];
            }
            Reflect.defineProperty(baseObj, prop, desc);
            return true;
        },
        getOwnPropertyDescriptor(_target, prop) {
            if (prop in extObj) {
                return Reflect.getOwnPropertyDescriptor(extObj, prop);
            }
            else {
                return Reflect.getOwnPropertyDescriptor(baseObj, prop);
            }
        },
        has(_target, prop) {
            return prop in extObj || prop in baseObj;
        },
    });
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/core/mod.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  AeadId: () => (/* reexport safe */ _src_identifiers_js__WEBPACK_IMPORTED_MODULE_3__.AeadId),
  Aes128Gcm: () => (/* reexport safe */ _src_aeads_aesGcm_js__WEBPACK_IMPORTED_MODULE_0__.Aes128Gcm),
  Aes256Gcm: () => (/* reexport safe */ _src_aeads_aesGcm_js__WEBPACK_IMPORTED_MODULE_0__.Aes256Gcm),
  BaseError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError),
  CipherSuite: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.CipherSuite),
  DecapError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.DecapError),
  DeriveKeyPairError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.DeriveKeyPairError),
  DeserializeError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.DeserializeError),
  DhkemP256HkdfSha256: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.DhkemP256HkdfSha256),
  DhkemP384HkdfSha384: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.DhkemP384HkdfSha384),
  DhkemP521HkdfSha512: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.DhkemP521HkdfSha512),
  EncapError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.EncapError),
  ExportError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.ExportError),
  ExportOnly: () => (/* reexport safe */ _src_aeads_exportOnly_js__WEBPACK_IMPORTED_MODULE_1__.ExportOnly),
  HkdfSha256: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.HkdfSha256),
  HkdfSha384: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.HkdfSha384),
  HkdfSha512: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.HkdfSha512),
  HpkeError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.HpkeError),
  InvalidParamError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError),
  KdfId: () => (/* reexport safe */ _src_identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KdfId),
  KemId: () => (/* reexport safe */ _src_identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KemId),
  MessageLimitReachedError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.MessageLimitReachedError),
  NotSupportedError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.NotSupportedError),
  OpenError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.OpenError),
  SealError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.SealError),
  SerializeError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.SerializeError),
  ValidationError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.ValidationError)
});
/* ESM import */var _src_aeads_aesGcm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/aeads/aesGcm.js");
/* ESM import */var _src_aeads_exportOnly_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/aeads/exportOnly.js");
/* ESM import */var _src_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _src_identifiers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");
/* ESM import */var _src_native_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/core/src/native.js");







}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/core/src/native.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  CipherSuite: () => (CipherSuite),
  DhkemP256HkdfSha256: () => (DhkemP256HkdfSha256),
  DhkemP384HkdfSha384: () => (DhkemP384HkdfSha384),
  DhkemP521HkdfSha512: () => (DhkemP521HkdfSha512),
  HkdfSha256: () => (HkdfSha256),
  HkdfSha384: () => (HkdfSha384),
  HkdfSha512: () => (HkdfSha512)
});
/* ESM import */var _src_cipherSuiteNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/cipherSuiteNative.js");
/* ESM import */var _src_kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kdfs/hkdf.js");
/* ESM import */var _src_kems_dhkemNative_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkemNative.js");



/**
 * The Hybrid Public Key Encryption (HPKE) ciphersuite,
 * which is implemented using only
 * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.
 *
 * This class is the same as
 * {@link https://deno.land/x/hpke/mod.ts?s=CipherSuiteNative | @hpke/core#CipherSuiteNative },
 * which supports only the ciphersuites that can be implemented on the native
 * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.
 * Therefore, the following cryptographic algorithms are not supported for now:
 * - `DHKEM(X25519, HKDF-SHA256)`
 * - `DHKEM(X448, HKDF-SHA512)`
 * - `ChaCha20Poly1305`
 *
 * In addtion, the HKDF functions contained in this `CipherSuiteNative`
 * class can only derive keys of the same length as the `hashSize`.
 *
 * If you want to use the unsupported cryptographic algorithms
 * above or derive keys longer than the `hashSize`,
 * please use {@link https://deno.land/x/hpke/mod.ts?s=CipherSuite | hpke-js#CipherSuite}.
 *
 * This class provides following functions:
 *
 * - Creates encryption contexts both for senders and recipients.
 *     - {@link createSenderContext}
 *     - {@link createRecipientContext}
 * - Provides single-shot encryption API.
 *     - {@link seal}
 *     - {@link open}
 *
 * The calling of the constructor of this class is the starting
 * point for HPKE operations for both senders and recipients.
 *
 * @example Use only ciphersuites supported by Web Cryptography API.
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   DhkemP256HkdfSha256,
 *   HkdfSha256,
 *   CipherSuite,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 *
 * @example Use a ciphersuite which is currently not supported by Web Cryptography API.
 *
 * ```ts
 * import { Aes128Gcm, HkdfSha256, CipherSuite } from "http://deno.land/x/hpke/core/mod.ts";
 * import { DhkemX25519HkdfSha256 } from "https://deno.land/x/hpke/x/dhkem-x25519/mod.ts";
 * const suite = new CipherSuite({
 *   kem: new DhkemX25519HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class CipherSuite extends _src_cipherSuiteNative_js__WEBPACK_IMPORTED_MODULE_0__.CipherSuiteNative {
}
/**
 * The DHKEM(P-256, HKDF-SHA256) for HPKE KEM implementing {@link KemInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP256HkdfSha256`
 * as follows:
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   CipherSuite,
 *   DhkemP256HkdfSha256,
 *   HkdfSha256,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class DhkemP256HkdfSha256 extends _src_kems_dhkemNative_js__WEBPACK_IMPORTED_MODULE_2__.DhkemP256HkdfSha256Native {
}
/**
 * The DHKEM(P-384, HKDF-SHA384) for HPKE KEM implementing {@link KemInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP384HkdfSha384`
 * as follows:
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   CipherSuite,
 *   DhkemP384HkdfSha384,
 *   HkdfSha384,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP384HkdfSha384(),
 *   kdf: new HkdfSha384(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class DhkemP384HkdfSha384 extends _src_kems_dhkemNative_js__WEBPACK_IMPORTED_MODULE_2__.DhkemP384HkdfSha384Native {
}
/**
 * The DHKEM(P-521, HKDF-SHA512) for HPKE KEM implementing {@link KemInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP521HkdfSha512`
 * as follows:
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes256Gcm,
 *   CipherSuite,
 *   DhkemP521HkdfSha512,
 *   HkdfSha512,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP521HkdfSha512(),
 *   kdf: new HkdfSha512(),
 *   aead: new Aes256Gcm(),
 * });
 * ```
 */
class DhkemP521HkdfSha512 extends _src_kems_dhkemNative_js__WEBPACK_IMPORTED_MODULE_2__.DhkemP521HkdfSha512Native {
}
/**
 * The HKDF-SHA256 for HPKE KDF implementing {@link KdfInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha256`.
 *
 * The KDF class can only derive keys of the same length as the `hashSize`.
 * If you want to derive keys longer than the `hashSize`,
 * please use {@link https://deno.land/x/hpke/mod.ts?s=CipherSuite | hpke-js#CipherSuite}.
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   CipherSuite,
 *   DhkemP256HkdfSha256,
 *   HkdfSha256,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class HkdfSha256 extends _src_kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__.HkdfSha256Native {
}
/**
 * The HKDF-SHA384 for HPKE KDF implementing {@link KdfInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha384`.
 *
 * The KDF class can only derive keys of the same length as the `hashSize`.
 * If you want to derive keys longer than the `hashSize`,
 * please use {@link https://deno.land/x/hpke/mod.ts?s=CipherSuite | hpke-js#CipherSuite}.
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   CipherSuite,
 *   DhkemP384HkdfSha384,
 *   HkdfSha384,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP384HkdfSha384(),
 *   kdf: new HkdfSha384(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class HkdfSha384 extends _src_kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__.HkdfSha384Native {
}
/**
 * The HKDF-SHA512 for HPKE KDF implementing {@link KdfInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha512`.
 *
 * The KDF class can only derive keys of the same length as the `hashSize`.
 * If you want to derive keys longer than the `hashSize`,
 * please use {@link https://deno.land/x/hpke/mod.ts?s=CipherSuite | hpke-js#CipherSuite}.
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes256Gcm,
 *   CipherSuite,
 *   DhkemP521HkdfSha512,
 *   HkdfSha512,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP521HkdfSha512(),
 *   kdf: new HkdfSha512(),
 *   aead: new Aes256Gcm(),
 * });
 * ```
 */
class HkdfSha512 extends _src_kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__.HkdfSha512Native {
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/aeads/aesGcm.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Aes128Gcm: () => (Aes128Gcm),
  Aes256Gcm: () => (Aes256Gcm),
  AesGcmContext: () => (AesGcmContext)
});
/* ESM import */var _algorithm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/algorithm.js");
/* ESM import */var _identifiers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");
/* ESM import */var _interfaces_aeadEncryptionContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/aeadEncryptionContext.js");



class AesGcmContext extends _algorithm_js__WEBPACK_IMPORTED_MODULE_0__.NativeAlgorithm {
    constructor(key) {
        super();
        Object.defineProperty(this, "_rawKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_key", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        this._rawKey = key;
    }
    async seal(iv, data, aad) {
        await this._setupKey();
        const alg = {
            name: "AES-GCM",
            iv: iv,
            additionalData: aad,
        };
        const ct = await this._api.encrypt(alg, this._key, data);
        return ct;
    }
    async open(iv, data, aad) {
        await this._setupKey();
        const alg = {
            name: "AES-GCM",
            iv: iv,
            additionalData: aad,
        };
        const pt = await this._api.decrypt(alg, this._key, data);
        return pt;
    }
    async _setupKey() {
        if (this._key !== undefined) {
            return;
        }
        await this._setup();
        const key = await this._importKey(this._rawKey);
        (new Uint8Array(this._rawKey)).fill(0);
        this._key = key;
        return;
    }
    async _importKey(key) {
        return await this._api.importKey("raw", key, { name: "AES-GCM" }, true, _interfaces_aeadEncryptionContext_js__WEBPACK_IMPORTED_MODULE_2__.AEAD_USAGES);
    }
}
/**
 * The AES-128-GCM for HPKE AEAD implementing {@link AeadInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `aead` parameter of {@link CipherSuiteParams} instead of `AeadId.Aes128Gcm`.
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   CipherSuite,
 *   DhkemP256HkdfSha256,
 *   HkdfSha256,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class Aes128Gcm {
    constructor() {
        /** AeadId.Aes128Gcm (0x0001) */
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_1__.AeadId.Aes128Gcm
        });
        /** 16 */
        Object.defineProperty(this, "keySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 16
        });
        /** 12 */
        Object.defineProperty(this, "nonceSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 12
        });
        /** 16 */
        Object.defineProperty(this, "tagSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 16
        });
    }
    createEncryptionContext(key) {
        return new AesGcmContext(key);
    }
}
/**
 * The AES-256-GCM for HPKE AEAD implementing {@link AeadInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `aead` parameter of {@link CipherSuiteParams} instead of `AeadId.Aes256Gcm`
 * as follows:
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes256Gcm,
 *   CipherSuite,
 *   DhkemP256HkdfSha256,
 *   HkdfSha256,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes256Gcm(),
 * });
 * ```
 */
class Aes256Gcm extends Aes128Gcm {
    constructor() {
        super(...arguments);
        /** AeadId.Aes256Gcm (0x0002) */
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_1__.AeadId.Aes256Gcm
        });
        /** 32 */
        Object.defineProperty(this, "keySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 32
        });
        /** 12 */
        Object.defineProperty(this, "nonceSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 12
        });
        /** 16 */
        Object.defineProperty(this, "tagSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 16
        });
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/aeads/exportOnly.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  ExportOnly: () => (ExportOnly)
});
/* ESM import */var _identifiers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");


/**
 * The ExportOnly mode for HPKE AEAD implementing {@link AeadInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `aead` parameter of {@link CipherSuiteParams} instead of `AeadId.ExportOnly`
 * as follows:
 *
 * @example
 *
 * ```ts
 * import {
 *   CipherSuite,
 *   DhkemP256HkdfSha256,
 *   ExportOnly,
 *   HkdfSha256,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new ExportOnly(),
 * });
 * ```
 */
class ExportOnly {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_0__.AeadId.ExportOnly
        });
        Object.defineProperty(this, "keySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "nonceSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "tagSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    createEncryptionContext(_key) {
        throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.NotSupportedError("Export only");
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/algorithm.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  NativeAlgorithm: () => (NativeAlgorithm)
});
/* ESM import */var _dnt_shims_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/_dnt.shims.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");


async function loadSubtleCrypto() {
    if (_dnt_shims_js__WEBPACK_IMPORTED_MODULE_0__.dntGlobalThis !== undefined && globalThis.crypto !== undefined) {
        // Browsers, Node.js >= v19, Cloudflare Workers, Bun, etc.
        return globalThis.crypto.subtle;
    }
    // Node.js <= v18
    try {
        // @ts-ignore: to ignore "crypto"
        const { webcrypto } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, "../../node_modules/crypto-browserify/index.js", 19)); // node:crypto
        return webcrypto.subtle;
    }
    catch (e) {
        throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.NotSupportedError(e);
    }
}
class NativeAlgorithm {
    constructor() {
        Object.defineProperty(this, "_api", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
    }
    async _setup() {
        if (this._api !== undefined) {
            return;
        }
        this._api = await loadSubtleCrypto();
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/cipherSuiteNative.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  CipherSuiteNative: () => (CipherSuiteNative)
});
/* ESM import */var _algorithm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/algorithm.js");
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _exporterContext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/exporterContext.js");
/* ESM import */var _identifiers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");
/* ESM import */var _recipientContext_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/recipientContext.js");
/* ESM import */var _senderContext_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/senderContext.js");
/* ESM import */var _utils_misc_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/misc.js");








// b"base_nonce"
// deno-fmt-ignore
const LABEL_BASE_NONCE = new Uint8Array([
    98, 97, 115, 101, 95, 110, 111, 110, 99, 101,
]);
// b"exp"
const LABEL_EXP = new Uint8Array([101, 120, 112]);
// b"info_hash"
// deno-fmt-ignore
const LABEL_INFO_HASH = new Uint8Array([
    105, 110, 102, 111, 95, 104, 97, 115, 104,
]);
// b"key"
const LABEL_KEY = new Uint8Array([107, 101, 121]);
// b"psk_id_hash"
// deno-fmt-ignore
const LABEL_PSK_ID_HASH = new Uint8Array([
    112, 115, 107, 95, 105, 100, 95, 104, 97, 115, 104,
]);
// b"secret"
const LABEL_SECRET = new Uint8Array([115, 101, 99, 114, 101, 116]);
// b"HPKE"
// deno-fmt-ignore
const SUITE_ID_HEADER_HPKE = new Uint8Array([
    72, 80, 75, 69, 0, 0, 0, 0, 0, 0,
]);
/**
 * The Hybrid Public Key Encryption (HPKE) ciphersuite,
 * which is implemented using only
 * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.
 *
 * This is the super class of {@link CipherSuite} and the same as
 * {@link https://deno.land/x/hpke/core/mod.ts?s=CipherSuite | @hpke/core#CipherSuite },
 * which supports only the ciphersuites that can be implemented on the native
 * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.
 * Therefore, the following cryptographic algorithms are not supported for now:
 *   - DHKEM(X25519, HKDF-SHA256)
 *   - DHKEM(X448, HKDF-SHA512)
 *   - ChaCha20Poly1305
 *
 * In addtion, the HKDF functions contained in this class can only derive
 * keys of the same length as the `hashSize`.
 *
 * If you want to use the unsupported cryptographic algorithms
 * above or derive keys longer than the `hashSize`,
 * please use {@link CipherSuite}.
 *
 * This class provides following functions:
 *
 * - Creates encryption contexts both for senders and recipients.
 *   - {@link createSenderContext}
 *   - {@link createRecipientContext}
 * - Provides single-shot encryption API.
 *   - {@link seal}
 *   - {@link open}
 *
 * The calling of the constructor of this class is the starting
 * point for HPKE operations for both senders and recipients.
 *
 * @example Use only ciphersuites supported by Web Cryptography API.
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   DhkemP256HkdfSha256,
 *   HkdfSha256,
 *   CipherSuite,
 * } from "http://deno.land/x/hpke/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 *
 * @example Use a ciphersuite which is currently not supported by Web Cryptography API.
 *
 * ```ts
 * import { Aes128Gcm, HkdfSha256, CipherSuite } from "http://deno.land/x/hpke/mod.ts";
 * // Use an extension module.
 * import { DhkemX25519HkdfSha256 } from "https://deno.land/x/hpke/x/dhkem-x25519/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemX25519HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class CipherSuiteNative extends _algorithm_js__WEBPACK_IMPORTED_MODULE_0__.NativeAlgorithm {
    /**
     * @param params A set of parameters for building a cipher suite.
     *
     * If the error occurred, throws {@link InvalidParamError}.
     *
     * @throws {@link InvalidParamError}
     */
    constructor(params) {
        super();
        Object.defineProperty(this, "_kem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_kdf", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_aead", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_suiteId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // KEM
        if (typeof params.kem === "number") {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("KemId cannot be used");
        }
        this._kem = params.kem;
        // KDF
        if (typeof params.kdf === "number") {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("KdfId cannot be used");
        }
        this._kdf = params.kdf;
        // AEAD
        if (typeof params.aead === "number") {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("AeadId cannot be used");
        }
        this._aead = params.aead;
        this._suiteId = new Uint8Array(SUITE_ID_HEADER_HPKE);
        this._suiteId.set((0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_7__.i2Osp)(this._kem.id, 2), 4);
        this._suiteId.set((0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_7__.i2Osp)(this._kdf.id, 2), 6);
        this._suiteId.set((0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_7__.i2Osp)(this._aead.id, 2), 8);
        this._kdf.init(this._suiteId);
    }
    /**
     * Gets the KEM context of the ciphersuite.
     */
    get kem() {
        return this._kem;
    }
    /**
     * Gets the KDF context of the ciphersuite.
     */
    get kdf() {
        return this._kdf;
    }
    /**
     * Gets the AEAD context of the ciphersuite.
     */
    get aead() {
        return this._aead;
    }
    /**
     * Creates an encryption context for a sender.
     *
     * If the error occurred, throws {@link DecapError} | {@link ValidationError}.
     *
     * @param params A set of parameters for the sender encryption context.
     * @returns A sender encryption context.
     * @throws {@link EncapError}, {@link ValidationError}
     */
    async createSenderContext(params) {
        this._validateInputLength(params);
        await this._setup();
        const dh = await this._kem.encap(params);
        let mode;
        if (params.psk !== undefined) {
            mode = params.senderKey !== undefined ? _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.AuthPsk : _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.Psk;
        }
        else {
            mode = params.senderKey !== undefined ? _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.Auth : _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.Base;
        }
        return await this._keyScheduleS(mode, dh.sharedSecret, dh.enc, params);
    }
    /**
     * Creates an encryption context for a recipient.
     *
     * If the error occurred, throws {@link DecapError}
     * | {@link DeserializeError} | {@link ValidationError}.
     *
     * @param params A set of parameters for the recipient encryption context.
     * @returns A recipient encryption context.
     * @throws {@link DecapError}, {@link DeserializeError}, {@link ValidationError}
     */
    async createRecipientContext(params) {
        this._validateInputLength(params);
        await this._setup();
        const sharedSecret = await this._kem.decap(params);
        let mode;
        if (params.psk !== undefined) {
            mode = params.senderPublicKey !== undefined ? _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.AuthPsk : _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.Psk;
        }
        else {
            mode = params.senderPublicKey !== undefined ? _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.Auth : _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.Base;
        }
        return await this._keyScheduleR(mode, sharedSecret, params);
    }
    /**
     * Encrypts a message to a recipient.
     *
     * If the error occurred, throws `EncapError` | `MessageLimitReachedError` | `SealError` | `ValidationError`.
     *
     * @param params A set of parameters for building a sender encryption context.
     * @param pt A plain text as bytes to be encrypted.
     * @param aad Additional authenticated data as bytes fed by an application.
     * @returns A cipher text and an encapsulated key as bytes.
     * @throws {@link EncapError}, {@link MessageLimitReachedError}, {@link SealError}, {@link ValidationError}
     */
    async seal(params, pt, aad = _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY) {
        const ctx = await this.createSenderContext(params);
        return {
            ct: await ctx.seal(pt, aad),
            enc: ctx.enc,
        };
    }
    /**
     * Decrypts a message from a sender.
     *
     * If the error occurred, throws `DecapError` | `DeserializeError` | `OpenError` | `ValidationError`.
     *
     * @param params A set of parameters for building a recipient encryption context.
     * @param ct An encrypted text as bytes to be decrypted.
     * @param aad Additional authenticated data as bytes fed by an application.
     * @returns A decrypted plain text as bytes.
     * @throws {@link DecapError}, {@link DeserializeError}, {@link OpenError}, {@link ValidationError}
     */
    async open(params, ct, aad = _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY) {
        const ctx = await this.createRecipientContext(params);
        return await ctx.open(ct, aad);
    }
    // private verifyPskInputs(mode: Mode, params: KeyScheduleParams) {
    //   const gotPsk = (params.psk !== undefined);
    //   const gotPskId = (params.psk !== undefined && params.psk.id.byteLength > 0);
    //   if (gotPsk !== gotPskId) {
    //     throw new Error('Inconsistent PSK inputs');
    //   }
    //   if (gotPsk && (mode === Mode.Base || mode === Mode.Auth)) {
    //     throw new Error('PSK input provided when not needed');
    //   }
    //   if (!gotPsk && (mode === Mode.Psk || mode === Mode.AuthPsk)) {
    //     throw new Error('Missing required PSK input');
    //   }
    //   return;
    // }
    async _keySchedule(mode, sharedSecret, params) {
        // Currently, there is no point in executing this function
        // because this hpke library does not allow users to explicitly specify the mode.
        //
        // this.verifyPskInputs(mode, params);
        const pskId = params.psk === undefined
            ? _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY
            : new Uint8Array(params.psk.id);
        const pskIdHash = await this._kdf.labeledExtract(_consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY, LABEL_PSK_ID_HASH, pskId);
        const info = params.info === undefined
            ? _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY
            : new Uint8Array(params.info);
        const infoHash = await this._kdf.labeledExtract(_consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY, LABEL_INFO_HASH, info);
        const keyScheduleContext = new Uint8Array(1 + pskIdHash.byteLength + infoHash.byteLength);
        keyScheduleContext.set(new Uint8Array([mode]), 0);
        keyScheduleContext.set(new Uint8Array(pskIdHash), 1);
        keyScheduleContext.set(new Uint8Array(infoHash), 1 + pskIdHash.byteLength);
        const psk = params.psk === undefined
            ? _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY
            : new Uint8Array(params.psk.key);
        const ikm = this._kdf.buildLabeledIkm(LABEL_SECRET, psk);
        const exporterSecretInfo = this._kdf.buildLabeledInfo(LABEL_EXP, keyScheduleContext, this._kdf.hashSize);
        const exporterSecret = await this._kdf.extractAndExpand(sharedSecret, ikm, exporterSecretInfo, this._kdf.hashSize);
        if (this._aead.id === _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.AeadId.ExportOnly) {
            return { aead: this._aead, exporterSecret: exporterSecret };
        }
        const keyInfo = this._kdf.buildLabeledInfo(LABEL_KEY, keyScheduleContext, this._aead.keySize);
        const key = await this._kdf.extractAndExpand(sharedSecret, ikm, keyInfo, this._aead.keySize);
        const baseNonceInfo = this._kdf.buildLabeledInfo(LABEL_BASE_NONCE, keyScheduleContext, this._aead.nonceSize);
        const baseNonce = await this._kdf.extractAndExpand(sharedSecret, ikm, baseNonceInfo, this._aead.nonceSize);
        return {
            aead: this._aead,
            exporterSecret: exporterSecret,
            key: key,
            baseNonce: new Uint8Array(baseNonce),
            seq: 0,
        };
    }
    async _keyScheduleS(mode, sharedSecret, enc, params) {
        const res = await this._keySchedule(mode, sharedSecret, params);
        if (res.key === undefined) {
            return new _exporterContext_js__WEBPACK_IMPORTED_MODULE_3__.SenderExporterContextImpl(this._api, this._kdf, res.exporterSecret, enc);
        }
        return new _senderContext_js__WEBPACK_IMPORTED_MODULE_6__.SenderContextImpl(this._api, this._kdf, res, enc);
    }
    async _keyScheduleR(mode, sharedSecret, params) {
        const res = await this._keySchedule(mode, sharedSecret, params);
        if (res.key === undefined) {
            return new _exporterContext_js__WEBPACK_IMPORTED_MODULE_3__.RecipientExporterContextImpl(this._api, this._kdf, res.exporterSecret);
        }
        return new _recipientContext_js__WEBPACK_IMPORTED_MODULE_5__.RecipientContextImpl(this._api, this._kdf, res);
    }
    _validateInputLength(params) {
        if (params.info !== undefined &&
            params.info.byteLength > _consts_js__WEBPACK_IMPORTED_MODULE_1__.INPUT_LENGTH_LIMIT) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("Too long info");
        }
        if (params.psk !== undefined) {
            if (params.psk.key.byteLength < _consts_js__WEBPACK_IMPORTED_MODULE_1__.MINIMUM_PSK_LENGTH) {
                throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError(`PSK must have at least ${_consts_js__WEBPACK_IMPORTED_MODULE_1__.MINIMUM_PSK_LENGTH} bytes`);
            }
            if (params.psk.key.byteLength > _consts_js__WEBPACK_IMPORTED_MODULE_1__.INPUT_LENGTH_LIMIT) {
                throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("Too long psk.key");
            }
            if (params.psk.id.byteLength > _consts_js__WEBPACK_IMPORTED_MODULE_1__.INPUT_LENGTH_LIMIT) {
                throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("Too long psk.id");
            }
        }
        return;
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  EMPTY: () => (EMPTY),
  INPUT_LENGTH_LIMIT: () => (INPUT_LENGTH_LIMIT),
  MINIMUM_PSK_LENGTH: () => (MINIMUM_PSK_LENGTH)
});
// The input length limit (psk, psk_id, info, exporter_context, ikm).
const INPUT_LENGTH_LIMIT = 8192;
// The minimum length of a PSK.
const MINIMUM_PSK_LENGTH = 32;
// b""
const EMPTY = new Uint8Array(0);


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/encryptionContext.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  EncryptionContextImpl: () => (EncryptionContextImpl),
  xor: () => (xor)
});
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _exporterContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/exporterContext.js");
/* ESM import */var _utils_misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/misc.js");



function xor(a, b) {
    if (a.byteLength !== b.byteLength) {
        throw new Error("xor: different length inputs");
    }
    const buf = new Uint8Array(a.byteLength);
    for (let i = 0; i < a.byteLength; i++) {
        buf[i] = a[i] ^ b[i];
    }
    return buf;
}
class EncryptionContextImpl extends _exporterContext_js__WEBPACK_IMPORTED_MODULE_1__.ExporterContextImpl {
    constructor(api, kdf, params) {
        super(api, kdf, params.exporterSecret);
        // AEAD id.
        Object.defineProperty(this, "_aead", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // The length in bytes of a key for the algorithm.
        Object.defineProperty(this, "_nK", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // The length in bytes of a nonce for the algorithm.
        Object.defineProperty(this, "_nN", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // The length in bytes of an authentication tag for the algorithm.
        Object.defineProperty(this, "_nT", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // The end-to-end encryption key information.
        Object.defineProperty(this, "_ctx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (params.key === undefined || params.baseNonce === undefined ||
            params.seq === undefined) {
            throw new Error("Required parameters are missing");
        }
        this._aead = params.aead;
        this._nK = this._aead.keySize;
        this._nN = this._aead.nonceSize;
        this._nT = this._aead.tagSize;
        const key = this._aead.createEncryptionContext(params.key);
        this._ctx = {
            key: key,
            baseNonce: params.baseNonce,
            seq: params.seq,
        };
    }
    computeNonce(k) {
        const seqBytes = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_2__.i2Osp)(k.seq, k.baseNonce.byteLength);
        return xor(k.baseNonce, seqBytes);
    }
    incrementSeq(k) {
        // if (this.seq >= (1 << (8 * this.baseNonce.byteLength)) - 1) {
        if (k.seq > Number.MAX_SAFE_INTEGER) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.MessageLimitReachedError("Message limit reached");
        }
        k.seq += 1;
        return;
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  BaseError: () => (BaseError),
  DecapError: () => (DecapError),
  DeriveKeyPairError: () => (DeriveKeyPairError),
  DeserializeError: () => (DeserializeError),
  EncapError: () => (EncapError),
  ExportError: () => (ExportError),
  HpkeError: () => (HpkeError),
  InvalidParamError: () => (InvalidParamError),
  MessageLimitReachedError: () => (MessageLimitReachedError),
  NotSupportedError: () => (NotSupportedError),
  OpenError: () => (OpenError),
  SealError: () => (SealError),
  SerializeError: () => (SerializeError),
  ValidationError: () => (ValidationError)
});
/**
 * The base error class of hpke-js.
 */
class BaseError extends Error {
    constructor(e) {
        let message;
        if (e instanceof Error) {
            message = e.message;
        }
        else if (typeof e === "string") {
            message = e;
        }
        else {
            message = "";
        }
        super(message);
        this.name = this.constructor.name;
    }
}
/**
 * The base error class of hpke-js.
 */
class HpkeError extends BaseError {
}
/**
 * Invalid parameter.
 */
class InvalidParamError extends HpkeError {
}
/**
 * KEM input or output validation failure.
 */
class ValidationError extends HpkeError {
}
/**
 * Public or private key serialization failure.
 */
class SerializeError extends HpkeError {
}
/**
 * Public or private key deserialization failure.
 */
class DeserializeError extends HpkeError {
}
/**
 * encap() failure.
 */
class EncapError extends HpkeError {
}
/**
 * decap() failure.
 */
class DecapError extends HpkeError {
}
/**
 * Secret export failure.
 */
class ExportError extends HpkeError {
}
/**
 * seal() failure.
 */
class SealError extends HpkeError {
}
/**
 * open() failure.
 */
class OpenError extends HpkeError {
}
/**
 * Sequence number overflow on the encryption context.
 */
class MessageLimitReachedError extends HpkeError {
}
/**
 * Key pair derivation failure.
 */
class DeriveKeyPairError extends HpkeError {
}
/**
 * Not supported failure.
 */
class NotSupportedError extends HpkeError {
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/exporterContext.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  ExporterContextImpl: () => (ExporterContextImpl),
  RecipientExporterContextImpl: () => (RecipientExporterContextImpl),
  SenderExporterContextImpl: () => (SenderExporterContextImpl)
});
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _utils_emitNotSupported_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/emitNotSupported.js");



// b"sec"
const LABEL_SEC = new Uint8Array([115, 101, 99]);
class ExporterContextImpl {
    constructor(api, kdf, exporterSecret) {
        Object.defineProperty(this, "_api", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "exporterSecret", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_kdf", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._api = api;
        this._kdf = kdf;
        this.exporterSecret = exporterSecret;
    }
    async seal(_data, _aad) {
        return await (0,_utils_emitNotSupported_js__WEBPACK_IMPORTED_MODULE_2__.emitNotSupported)();
    }
    async open(_data, _aad) {
        return await (0,_utils_emitNotSupported_js__WEBPACK_IMPORTED_MODULE_2__.emitNotSupported)();
    }
    async export(exporterContext, len) {
        if (exporterContext.byteLength > _consts_js__WEBPACK_IMPORTED_MODULE_0__.INPUT_LENGTH_LIMIT) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidParamError("Too long exporter context");
        }
        try {
            return await this._kdf.labeledExpand(this.exporterSecret, LABEL_SEC, new Uint8Array(exporterContext), len);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.ExportError(e);
        }
    }
}
class RecipientExporterContextImpl extends ExporterContextImpl {
}
class SenderExporterContextImpl extends ExporterContextImpl {
    constructor(api, kdf, exporterSecret, enc) {
        super(api, kdf, exporterSecret);
        Object.defineProperty(this, "enc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.enc = enc;
        return;
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Aead: () => (Aead),
  AeadId: () => (AeadId),
  Kdf: () => (Kdf),
  KdfId: () => (KdfId),
  Kem: () => (Kem),
  KemId: () => (KemId),
  Mode: () => (Mode)
});
/**
 * The supported HPKE modes.
 */
const Mode = {
    Base: 0x00,
    Psk: 0x01,
    Auth: 0x02,
    AuthPsk: 0x03,
};
/**
 * The supported Key Encapsulation Mechanism (KEM) identifiers.
 *
 * @deprecated Use {@link KdfId} instead.
 */
const Kem = {
    NotAssigned: 0x0000,
    DhkemP256HkdfSha256: 0x0010,
    DhkemP384HkdfSha384: 0x0011,
    DhkemP521HkdfSha512: 0x0012,
    DhkemSecp256k1HkdfSha256: 0x0013,
    DhkemX25519HkdfSha256: 0x0020,
    DhkemX448HkdfSha512: 0x0021,
    HybridkemX25519Kyber768: 0x0030,
};
/**
 * The supported Key Encapsulation Mechanism (KEM) identifiers.
 */
const KemId = Kem;
/**
 * The supported Key Derivation Function (KDF) identifiers.
 *
 * @deprecated Use {@link KdfId} instead.
 */
const Kdf = {
    HkdfSha256: 0x0001,
    HkdfSha384: 0x0002,
    HkdfSha512: 0x0003,
};
/**
 * The supported Key Derivation Function (KDF) identifiers.
 */
const KdfId = Kdf;
/**
 * The supported Authenticated Encryption with Associated Data (AEAD) identifiers.
 *
 * @deprecated Use {@link AeadId} instead.
 */
const Aead = {
    Aes128Gcm: 0x0001,
    Aes256Gcm: 0x0002,
    Chacha20Poly1305: 0x0003,
    ExportOnly: 0xFFFF,
};
/**
 * The supported Authenticated Encryption with Associated Data (AEAD) identifiers.
 */
const AeadId = Aead;


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/aeadEncryptionContext.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  AEAD_USAGES: () => (AEAD_USAGES)
});
// The key usages for AEAD.
const AEAD_USAGES = ["encrypt", "decrypt"];


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/dhkemPrimitives.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  KEM_USAGES: () => (KEM_USAGES),
  LABEL_DKP_PRK: () => (LABEL_DKP_PRK),
  LABEL_SK: () => (LABEL_SK)
});
// The key usages for KEM.
const KEM_USAGES = ["deriveBits"];
// b"dkp_prk"
const LABEL_DKP_PRK = new Uint8Array([100, 107, 112, 95, 112, 114, 107]);
// b"sk"
const LABEL_SK = new Uint8Array([115, 107]);


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/kemInterface.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  SUITE_ID_HEADER_KEM: () => (SUITE_ID_HEADER_KEM)
});
// b"KEM"
const SUITE_ID_HEADER_KEM = new Uint8Array([75, 69, 77, 0, 0]);


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kdfs/hkdf.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  HkdfNative: () => (HkdfNative),
  HkdfSha256Native: () => (HkdfSha256Native),
  HkdfSha384Native: () => (HkdfSha384Native),
  HkdfSha512Native: () => (HkdfSha512Native)
});
/* ESM import */var _algorithm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/algorithm.js");
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _identifiers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");




// b"HPKE-v1"
const HPKE_VERSION = new Uint8Array([72, 80, 75, 69, 45, 118, 49]);
class HkdfNative extends _algorithm_js__WEBPACK_IMPORTED_MODULE_0__.NativeAlgorithm {
    constructor() {
        super();
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KdfId.HkdfSha256
        });
        Object.defineProperty(this, "hashSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_suiteId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY
        });
        Object.defineProperty(this, "algHash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                name: "HMAC",
                hash: "SHA-256",
                length: 256,
            }
        });
    }
    init(suiteId) {
        this._suiteId = suiteId;
    }
    buildLabeledIkm(label, ikm) {
        this._checkInit();
        const ret = new Uint8Array(7 + this._suiteId.byteLength + label.byteLength + ikm.byteLength);
        ret.set(HPKE_VERSION, 0);
        ret.set(this._suiteId, 7);
        ret.set(label, 7 + this._suiteId.byteLength);
        ret.set(ikm, 7 + this._suiteId.byteLength + label.byteLength);
        return ret;
    }
    buildLabeledInfo(label, info, len) {
        this._checkInit();
        const ret = new Uint8Array(9 + this._suiteId.byteLength + label.byteLength + info.byteLength);
        ret.set(new Uint8Array([0, len]), 0);
        ret.set(HPKE_VERSION, 2);
        ret.set(this._suiteId, 9);
        ret.set(label, 9 + this._suiteId.byteLength);
        ret.set(info, 9 + this._suiteId.byteLength + label.byteLength);
        return ret;
    }
    async extract(salt, ikm) {
        await this._setup();
        if (salt.byteLength === 0) {
            salt = new ArrayBuffer(this.hashSize);
        }
        if (salt.byteLength !== this.hashSize) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("The salt length must be the same as the hashSize");
        }
        const key = await this._api.importKey("raw", salt, this.algHash, false, [
            "sign",
        ]);
        return await this._api.sign("HMAC", key, ikm);
    }
    async expand(prk, info, len) {
        await this._setup();
        const key = await this._api.importKey("raw", prk, this.algHash, false, [
            "sign",
        ]);
        const okm = new ArrayBuffer(len);
        const p = new Uint8Array(okm);
        let prev = _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY;
        const mid = new Uint8Array(info);
        const tail = new Uint8Array(1);
        if (len > 255 * this.hashSize) {
            throw new Error("Entropy limit reached");
        }
        const tmp = new Uint8Array(this.hashSize + mid.length + 1);
        for (let i = 1, cur = 0; cur < p.length; i++) {
            tail[0] = i;
            tmp.set(prev, 0);
            tmp.set(mid, prev.length);
            tmp.set(tail, prev.length + mid.length);
            prev = new Uint8Array(await this._api.sign("HMAC", key, tmp.slice(0, prev.length + mid.length + 1)));
            if (p.length - cur >= prev.length) {
                p.set(prev, cur);
                cur += prev.length;
            }
            else {
                p.set(prev.slice(0, p.length - cur), cur);
                cur += p.length - cur;
            }
        }
        return okm;
    }
    async extractAndExpand(salt, ikm, info, len) {
        await this._setup();
        const baseKey = await this._api.importKey("raw", ikm, "HKDF", false, ["deriveBits"]);
        return await this._api.deriveBits({
            name: "HKDF",
            hash: this.algHash.hash,
            salt: salt,
            info: info,
        }, baseKey, len * 8);
    }
    async labeledExtract(salt, label, ikm) {
        return await this.extract(salt, this.buildLabeledIkm(label, ikm));
    }
    async labeledExpand(prk, label, info, len) {
        return await this.expand(prk, this.buildLabeledInfo(label, info, len), len);
    }
    _checkInit() {
        if (this._suiteId === _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY) {
            throw new Error("Not initialized. Call init()");
        }
    }
}
class HkdfSha256Native extends HkdfNative {
    constructor() {
        super(...arguments);
        /** KdfId.HkdfSha256 (0x0001) */
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KdfId.HkdfSha256
        });
        /** 32 */
        Object.defineProperty(this, "hashSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 32
        });
        /** The parameters for Web Cryptography API */
        Object.defineProperty(this, "algHash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                name: "HMAC",
                hash: "SHA-256",
                length: 256,
            }
        });
    }
}
class HkdfSha384Native extends HkdfNative {
    constructor() {
        super(...arguments);
        /** KdfId.HkdfSha384 (0x0002) */
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KdfId.HkdfSha384
        });
        /** 48 */
        Object.defineProperty(this, "hashSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 48
        });
        /** The parameters for Web Cryptography API */
        Object.defineProperty(this, "algHash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                name: "HMAC",
                hash: "SHA-384",
                length: 384,
            }
        });
    }
}
class HkdfSha512Native extends HkdfNative {
    constructor() {
        super(...arguments);
        /** KdfId.HkdfSha512 (0x0003) */
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KdfId.HkdfSha512
        });
        /** 64 */
        Object.defineProperty(this, "hashSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 64
        });
        /** The parameters for Web Cryptography API */
        Object.defineProperty(this, "algHash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                name: "HMAC",
                hash: "SHA-512",
                length: 512,
            }
        });
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkem.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Dhkem: () => (Dhkem)
});
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _interfaces_kemInterface_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/kemInterface.js");
/* ESM import */var _utils_misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/misc.js");




// b"eae_prk"
const LABEL_EAE_PRK = new Uint8Array([101, 97, 101, 95, 112, 114, 107]);
// b"shared_secret"
// deno-fmt-ignore
const LABEL_SHARED_SECRET = new Uint8Array([
    115, 104, 97, 114, 101, 100, 95, 115, 101, 99,
    114, 101, 116,
]);
function concat3(a, b, c) {
    const ret = new Uint8Array(a.length + b.length + c.length);
    ret.set(a, 0);
    ret.set(b, a.length);
    ret.set(c, a.length + b.length);
    return ret;
}
class Dhkem {
    constructor(id, prim, kdf) {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "secretSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "encSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "publicKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "privateKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_prim", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_kdf", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.id = id;
        this._prim = prim;
        this._kdf = kdf;
        const suiteId = new Uint8Array(_interfaces_kemInterface_js__WEBPACK_IMPORTED_MODULE_2__.SUITE_ID_HEADER_KEM);
        suiteId.set((0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.i2Osp)(this.id, 2), 3);
        this._kdf.init(suiteId);
    }
    async serializePublicKey(key) {
        return await this._prim.serializePublicKey(key);
    }
    async deserializePublicKey(key) {
        return await this._prim.deserializePublicKey(key);
    }
    async serializePrivateKey(key) {
        return await this._prim.serializePrivateKey(key);
    }
    async deserializePrivateKey(key) {
        return await this._prim.deserializePrivateKey(key);
    }
    async importKey(format, key, isPublic = true) {
        return await this._prim.importKey(format, key, isPublic);
    }
    async generateKeyPair() {
        return await this._prim.generateKeyPair();
    }
    async deriveKeyPair(ikm) {
        if (ikm.byteLength > _consts_js__WEBPACK_IMPORTED_MODULE_0__.INPUT_LENGTH_LIMIT) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidParamError("Too long ikm");
        }
        return await this._prim.deriveKeyPair(ikm);
    }
    async encap(params) {
        let ke;
        if (params.ekm === undefined) {
            ke = await this.generateKeyPair();
        }
        else if ((0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.isCryptoKeyPair)(params.ekm)) {
            // params.ekm is only used for testing.
            ke = params.ekm;
        }
        else {
            // params.ekm is only used for testing.
            ke = await this.deriveKeyPair(params.ekm);
        }
        const enc = await this._prim.serializePublicKey(ke.publicKey);
        const pkrm = await this._prim.serializePublicKey(params.recipientPublicKey);
        try {
            let dh;
            if (params.senderKey === undefined) {
                dh = new Uint8Array(await this._prim.dh(ke.privateKey, params.recipientPublicKey));
            }
            else {
                const sks = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.isCryptoKeyPair)(params.senderKey)
                    ? params.senderKey.privateKey
                    : params.senderKey;
                const dh1 = new Uint8Array(await this._prim.dh(ke.privateKey, params.recipientPublicKey));
                const dh2 = new Uint8Array(await this._prim.dh(sks, params.recipientPublicKey));
                dh = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.concat)(dh1, dh2);
            }
            let kemContext;
            if (params.senderKey === undefined) {
                kemContext = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.concat)(new Uint8Array(enc), new Uint8Array(pkrm));
            }
            else {
                const pks = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.isCryptoKeyPair)(params.senderKey)
                    ? params.senderKey.publicKey
                    : await this._prim.derivePublicKey(params.senderKey);
                const pksm = await this._prim.serializePublicKey(pks);
                kemContext = concat3(new Uint8Array(enc), new Uint8Array(pkrm), new Uint8Array(pksm));
            }
            const sharedSecret = await this._generateSharedSecret(dh, kemContext);
            return {
                enc: enc,
                sharedSecret: sharedSecret,
            };
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.EncapError(e);
        }
    }
    async decap(params) {
        const pke = await this._prim.deserializePublicKey(params.enc);
        const skr = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.isCryptoKeyPair)(params.recipientKey)
            ? params.recipientKey.privateKey
            : params.recipientKey;
        const pkr = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.isCryptoKeyPair)(params.recipientKey)
            ? params.recipientKey.publicKey
            : await this._prim.derivePublicKey(params.recipientKey);
        const pkrm = await this._prim.serializePublicKey(pkr);
        try {
            let dh;
            if (params.senderPublicKey === undefined) {
                dh = new Uint8Array(await this._prim.dh(skr, pke));
            }
            else {
                const dh1 = new Uint8Array(await this._prim.dh(skr, pke));
                const dh2 = new Uint8Array(await this._prim.dh(skr, params.senderPublicKey));
                dh = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.concat)(dh1, dh2);
            }
            let kemContext;
            if (params.senderPublicKey === undefined) {
                kemContext = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.concat)(new Uint8Array(params.enc), new Uint8Array(pkrm));
            }
            else {
                const pksm = await this._prim.serializePublicKey(params.senderPublicKey);
                kemContext = new Uint8Array(params.enc.byteLength + pkrm.byteLength + pksm.byteLength);
                kemContext.set(new Uint8Array(params.enc), 0);
                kemContext.set(new Uint8Array(pkrm), params.enc.byteLength);
                kemContext.set(new Uint8Array(pksm), params.enc.byteLength + pkrm.byteLength);
            }
            return await this._generateSharedSecret(dh, kemContext);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.DecapError(e);
        }
    }
    async _generateSharedSecret(dh, kemContext) {
        const labeledIkm = this._kdf.buildLabeledIkm(LABEL_EAE_PRK, dh);
        const labeledInfo = this._kdf.buildLabeledInfo(LABEL_SHARED_SECRET, kemContext, this.secretSize);
        return await this._kdf.extractAndExpand(_consts_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY, labeledIkm, labeledInfo, this.secretSize);
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkemNative.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  DhkemP256HkdfSha256Native: () => (DhkemP256HkdfSha256Native),
  DhkemP384HkdfSha384Native: () => (DhkemP384HkdfSha384Native),
  DhkemP521HkdfSha512Native: () => (DhkemP521HkdfSha512Native)
});
/* ESM import */var _identifiers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");
/* ESM import */var _kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kdfs/hkdf.js");
/* ESM import */var _dhkem_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkem.js");
/* ESM import */var _dhkemPrimitives_ec_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkemPrimitives/ec.js");




class DhkemP256HkdfSha256Native extends _dhkem_js__WEBPACK_IMPORTED_MODULE_2__.Dhkem {
    constructor() {
        const kdf = new _kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__.HkdfSha256Native();
        const prim = new _dhkemPrimitives_ec_js__WEBPACK_IMPORTED_MODULE_3__.Ec(_identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP256HkdfSha256, kdf);
        super(_identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP256HkdfSha256, prim, kdf);
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP256HkdfSha256
        });
        Object.defineProperty(this, "secretSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 32
        });
        Object.defineProperty(this, "encSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 65
        });
        Object.defineProperty(this, "publicKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 65
        });
        Object.defineProperty(this, "privateKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 32
        });
    }
}
class DhkemP384HkdfSha384Native extends _dhkem_js__WEBPACK_IMPORTED_MODULE_2__.Dhkem {
    constructor() {
        const kdf = new _kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__.HkdfSha384Native();
        const prim = new _dhkemPrimitives_ec_js__WEBPACK_IMPORTED_MODULE_3__.Ec(_identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP384HkdfSha384, kdf);
        super(_identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP384HkdfSha384, prim, kdf);
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP384HkdfSha384
        });
        Object.defineProperty(this, "secretSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 48
        });
        Object.defineProperty(this, "encSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 97
        });
        Object.defineProperty(this, "publicKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 97
        });
        Object.defineProperty(this, "privateKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 48
        });
    }
}
class DhkemP521HkdfSha512Native extends _dhkem_js__WEBPACK_IMPORTED_MODULE_2__.Dhkem {
    constructor() {
        const kdf = new _kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__.HkdfSha512Native();
        const prim = new _dhkemPrimitives_ec_js__WEBPACK_IMPORTED_MODULE_3__.Ec(_identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP521HkdfSha512, kdf);
        super(_identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP521HkdfSha512, prim, kdf);
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP521HkdfSha512
        });
        Object.defineProperty(this, "secretSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 64
        });
        Object.defineProperty(this, "encSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 133
        });
        Object.defineProperty(this, "publicKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 133
        });
        Object.defineProperty(this, "privateKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 64
        });
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkemPrimitives/ec.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Ec: () => (Ec)
});
/* ESM import */var _algorithm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/algorithm.js");
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _identifiers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");
/* ESM import */var _interfaces_dhkemPrimitives_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/dhkemPrimitives.js");
/* ESM import */var _utils_bignum_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/bignum.js");
/* ESM import */var _utils_misc_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/misc.js");







// b"candidate"
// deno-fmt-ignore
const LABEL_CANDIDATE = new Uint8Array([
    99, 97, 110, 100, 105, 100, 97, 116, 101,
]);
// the order of the curve being used.
// deno-fmt-ignore
const ORDER_P_256 = new Uint8Array([
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84,
    0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51,
]);
// deno-fmt-ignore
const ORDER_P_384 = new Uint8Array([
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
    0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a,
    0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73,
]);
// deno-fmt-ignore
const ORDER_P_521 = new Uint8Array([
    0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xfa, 0x51, 0x86, 0x87, 0x83, 0xbf, 0x2f,
    0x96, 0x6b, 0x7f, 0xcc, 0x01, 0x48, 0xf7, 0x09,
    0xa5, 0xd0, 0x3b, 0xb5, 0xc9, 0xb8, 0x89, 0x9c,
    0x47, 0xae, 0xbb, 0x6f, 0xb7, 0x1e, 0x91, 0x38,
    0x64, 0x09,
]);
// deno-fmt-ignore
const PKCS8_ALG_ID_P_256 = new Uint8Array([
    48, 65, 2, 1, 0, 48, 19, 6, 7, 42,
    134, 72, 206, 61, 2, 1, 6, 8, 42, 134,
    72, 206, 61, 3, 1, 7, 4, 39, 48, 37,
    2, 1, 1, 4, 32,
]);
// deno-fmt-ignore
const PKCS8_ALG_ID_P_384 = new Uint8Array([
    48, 78, 2, 1, 0, 48, 16, 6, 7, 42,
    134, 72, 206, 61, 2, 1, 6, 5, 43, 129,
    4, 0, 34, 4, 55, 48, 53, 2, 1, 1,
    4, 48,
]);
// deno-fmt-ignore
const PKCS8_ALG_ID_P_521 = new Uint8Array([
    48, 96, 2, 1, 0, 48, 16, 6, 7, 42,
    134, 72, 206, 61, 2, 1, 6, 5, 43, 129,
    4, 0, 35, 4, 73, 48, 71, 2, 1, 1,
    4, 66,
]);
class Ec extends _algorithm_js__WEBPACK_IMPORTED_MODULE_0__.NativeAlgorithm {
    constructor(kem, hkdf) {
        super();
        Object.defineProperty(this, "_hkdf", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_alg", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_nPk", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_nSk", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_nDh", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // EC specific arguments for deriving key pair.
        Object.defineProperty(this, "_order", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_bitmask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_pkcs8AlgId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._hkdf = hkdf;
        switch (kem) {
            case _identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KemId.DhkemP256HkdfSha256:
                this._alg = { name: "ECDH", namedCurve: "P-256" };
                this._nPk = 65;
                this._nSk = 32;
                this._nDh = 32;
                this._order = ORDER_P_256;
                this._bitmask = 0xFF;
                this._pkcs8AlgId = PKCS8_ALG_ID_P_256;
                break;
            case _identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KemId.DhkemP384HkdfSha384:
                this._alg = { name: "ECDH", namedCurve: "P-384" };
                this._nPk = 97;
                this._nSk = 48;
                this._nDh = 48;
                this._order = ORDER_P_384;
                this._bitmask = 0xFF;
                this._pkcs8AlgId = PKCS8_ALG_ID_P_384;
                break;
            default:
                // case KemId.DhkemP521HkdfSha512:
                this._alg = { name: "ECDH", namedCurve: "P-521" };
                this._nPk = 133;
                this._nSk = 66;
                this._nDh = 66;
                this._order = ORDER_P_521;
                this._bitmask = 0x01;
                this._pkcs8AlgId = PKCS8_ALG_ID_P_521;
                break;
        }
    }
    async serializePublicKey(key) {
        await this._setup();
        try {
            return await this._api.exportKey("raw", key);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.SerializeError(e);
        }
    }
    async deserializePublicKey(key) {
        await this._setup();
        try {
            return await this._importRawKey(key, true);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.DeserializeError(e);
        }
    }
    async serializePrivateKey(key) {
        await this._setup();
        try {
            const jwk = await this._api.exportKey("jwk", key);
            if (!("d" in jwk)) {
                throw new Error("Not private key");
            }
            return (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_6__.base64UrlToBytes)(jwk["d"]);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.SerializeError(e);
        }
    }
    async deserializePrivateKey(key) {
        await this._setup();
        try {
            return await this._importRawKey(key, false);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.DeserializeError(e);
        }
    }
    async importKey(format, key, isPublic) {
        await this._setup();
        try {
            if (format === "raw") {
                return await this._importRawKey(key, isPublic);
            }
            // jwk
            if (key instanceof ArrayBuffer) {
                throw new Error("Invalid jwk key format");
            }
            return await this._importJWK(key, isPublic);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.DeserializeError(e);
        }
    }
    async generateKeyPair() {
        await this._setup();
        try {
            return await this._api.generateKey(this._alg, true, _interfaces_dhkemPrimitives_js__WEBPACK_IMPORTED_MODULE_4__.KEM_USAGES);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.NotSupportedError(e);
        }
    }
    async deriveKeyPair(ikm) {
        await this._setup();
        try {
            const dkpPrk = await this._hkdf.labeledExtract(_consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY, _interfaces_dhkemPrimitives_js__WEBPACK_IMPORTED_MODULE_4__.LABEL_DKP_PRK, new Uint8Array(ikm));
            const bn = new _utils_bignum_js__WEBPACK_IMPORTED_MODULE_5__.Bignum(this._nSk);
            for (let counter = 0; bn.isZero() || !bn.lessThan(this._order); counter++) {
                if (counter > 255) {
                    throw new Error("Faild to derive a key pair");
                }
                const bytes = new Uint8Array(await this._hkdf.labeledExpand(dkpPrk, LABEL_CANDIDATE, (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_6__.i2Osp)(counter, 1), this._nSk));
                bytes[0] = bytes[0] & this._bitmask;
                bn.set(bytes);
            }
            const sk = await this._deserializePkcs8Key(bn.val());
            bn.reset();
            return {
                privateKey: sk,
                publicKey: await this.derivePublicKey(sk),
            };
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.DeriveKeyPairError(e);
        }
    }
    async derivePublicKey(key) {
        await this._setup();
        try {
            const jwk = await this._api.exportKey("jwk", key);
            delete jwk["d"];
            delete jwk["key_ops"];
            return await this._api.importKey("jwk", jwk, this._alg, true, []);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.DeserializeError(e);
        }
    }
    async dh(sk, pk) {
        try {
            await this._setup();
            const bits = await this._api.deriveBits({
                name: "ECDH",
                public: pk,
            }, sk, this._nDh * 8);
            return bits;
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.SerializeError(e);
        }
    }
    async _importRawKey(key, isPublic) {
        if (isPublic && key.byteLength !== this._nPk) {
            throw new Error("Invalid public key for the ciphersuite");
        }
        if (!isPublic && key.byteLength !== this._nSk) {
            throw new Error("Invalid private key for the ciphersuite");
        }
        if (isPublic) {
            return await this._api.importKey("raw", key, this._alg, true, []);
        }
        return await this._deserializePkcs8Key(new Uint8Array(key));
    }
    async _importJWK(key, isPublic) {
        if (typeof key.crv === "undefined" || key.crv !== this._alg.namedCurve) {
            throw new Error(`Invalid crv: ${key.crv}`);
        }
        if (isPublic) {
            if (typeof key.d !== "undefined") {
                throw new Error("Invalid key: `d` should not be set");
            }
            return await this._api.importKey("jwk", key, this._alg, true, []);
        }
        if (typeof key.d === "undefined") {
            throw new Error("Invalid key: `d` not found");
        }
        return await this._api.importKey("jwk", key, this._alg, true, _interfaces_dhkemPrimitives_js__WEBPACK_IMPORTED_MODULE_4__.KEM_USAGES);
    }
    async _deserializePkcs8Key(k) {
        const pkcs8Key = new Uint8Array(this._pkcs8AlgId.length + k.length);
        pkcs8Key.set(this._pkcs8AlgId, 0);
        pkcs8Key.set(k, this._pkcs8AlgId.length);
        return await this._api.importKey("pkcs8", pkcs8Key, this._alg, true, _interfaces_dhkemPrimitives_js__WEBPACK_IMPORTED_MODULE_4__.KEM_USAGES);
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/recipientContext.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  RecipientContextImpl: () => (RecipientContextImpl)
});
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _encryptionContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/encryptionContext.js");



class RecipientContextImpl extends _encryptionContext_js__WEBPACK_IMPORTED_MODULE_2__.EncryptionContextImpl {
    async open(data, aad = _consts_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY) {
        let pt;
        try {
            pt = await this._ctx.key.open(this.computeNonce(this._ctx), data, aad);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.OpenError(e);
        }
        this.incrementSeq(this._ctx);
        return pt;
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/senderContext.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  SenderContextImpl: () => (SenderContextImpl)
});
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _encryptionContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/encryptionContext.js");



class SenderContextImpl extends _encryptionContext_js__WEBPACK_IMPORTED_MODULE_2__.EncryptionContextImpl {
    constructor(api, kdf, params, enc) {
        super(api, kdf, params);
        Object.defineProperty(this, "enc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.enc = enc;
    }
    async seal(data, aad = _consts_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY) {
        let ct;
        try {
            ct = await this._ctx.key.seal(this.computeNonce(this._ctx), data, aad);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.SealError(e);
        }
        this.incrementSeq(this._ctx);
        return ct;
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/bignum.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Bignum: () => (Bignum)
});
/**
 * The minimum inplementation of bignum to derive an EC key pair.
 */
class Bignum {
    constructor(size) {
        Object.defineProperty(this, "_num", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._num = new Uint8Array(size);
    }
    val() {
        return this._num;
    }
    reset() {
        this._num.fill(0);
    }
    set(src) {
        if (src.length !== this._num.length) {
            throw new Error("Bignum.set: invalid argument");
        }
        this._num.set(src);
    }
    isZero() {
        for (let i = 0; i < this._num.length; i++) {
            if (this._num[i] !== 0) {
                return false;
            }
        }
        return true;
    }
    lessThan(v) {
        if (v.length !== this._num.length) {
            throw new Error("Bignum.lessThan: invalid argument");
        }
        for (let i = 0; i < this._num.length; i++) {
            if (this._num[i] < v[i]) {
                return true;
            }
            if (this._num[i] > v[i]) {
                return false;
            }
        }
        return false;
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/emitNotSupported.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  emitNotSupported: () => (emitNotSupported)
});
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");

function emitNotSupported() {
    return new Promise((_resolve, reject) => {
        reject(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.NotSupportedError("Not supported"));
    });
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/misc.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  base64UrlToBytes: () => (base64UrlToBytes),
  concat: () => (concat),
  i2Osp: () => (i2Osp),
  isCryptoKeyPair: () => (isCryptoKeyPair),
  isDeno: () => (isDeno)
});
/**
 * Checks whether the execution env is Deno or not.
 */
const isDeno = () => typeof Deno !== "undefined";
/**
 * Checks whetehr the type of input is CryptoKeyPair or not.
 */
const isCryptoKeyPair = (x) => typeof x === "object" &&
    x !== null &&
    typeof x.privateKey === "object" &&
    typeof x.publicKey === "object";
/**
 * Converts integer to octet string. I2OSP implementation.
 */
function i2Osp(n, w) {
    if (w <= 0) {
        throw new Error("i2Osp: too small size");
    }
    if (n >= 256 ** w) {
        throw new Error("i2Osp: too large integer");
    }
    const ret = new Uint8Array(w);
    for (let i = 0; i < w && n; i++) {
        ret[w - (i + 1)] = n % 256;
        n = n >> 8;
    }
    return ret;
}
/**
 * Concatenates two Uint8Arrays.
 */
function concat(a, b) {
    const ret = new Uint8Array(a.length + b.length);
    ret.set(a, 0);
    ret.set(b, a.length);
    return ret;
}
/**
 * Decodes Base64Url-encoded data.
 */
function base64UrlToBytes(v) {
    const base64 = v.replace(/-/g, "+").replace(/_/g, "/");
    const byteString = atob(base64);
    const ret = new Uint8Array(byteString.length);
    for (let i = 0; i < byteString.length; i++) {
        ret[i] = byteString.charCodeAt(i);
    }
    return ret;
}


}),

}]);
//# sourceMappingURL=vendors-node_modules_cubist-labs_cubesigner-sdk_node_modules_hpke_core_esm_core_mod_js.js.map