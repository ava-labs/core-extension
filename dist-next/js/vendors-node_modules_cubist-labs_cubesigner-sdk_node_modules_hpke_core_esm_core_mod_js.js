"use strict";
(globalThis["webpackChunk_core_ext_next"] = globalThis["webpackChunk_core_ext_next"] || []).push([["vendors-node_modules_cubist-labs_cubesigner-sdk_node_modules_hpke_core_esm_core_mod_js"], {
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/_dnt.shims.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  dntGlobalThis: () => (dntGlobalThis)
});
const dntGlobals = {};
const dntGlobalThis = createMergeProxy(globalThis, dntGlobals);
function createMergeProxy(baseObj, extObj) {
    return new Proxy(baseObj, {
        get(_target, prop, _receiver) {
            if (prop in extObj) {
                return extObj[prop];
            }
            else {
                return baseObj[prop];
            }
        },
        set(_target, prop, value) {
            if (prop in extObj) {
                delete extObj[prop];
            }
            baseObj[prop] = value;
            return true;
        },
        deleteProperty(_target, prop) {
            let success = false;
            if (prop in extObj) {
                delete extObj[prop];
                success = true;
            }
            if (prop in baseObj) {
                delete baseObj[prop];
                success = true;
            }
            return success;
        },
        ownKeys(_target) {
            const baseKeys = Reflect.ownKeys(baseObj);
            const extKeys = Reflect.ownKeys(extObj);
            const extKeysSet = new Set(extKeys);
            return [...baseKeys.filter((k) => !extKeysSet.has(k)), ...extKeys];
        },
        defineProperty(_target, prop, desc) {
            if (prop in extObj) {
                delete extObj[prop];
            }
            Reflect.defineProperty(baseObj, prop, desc);
            return true;
        },
        getOwnPropertyDescriptor(_target, prop) {
            if (prop in extObj) {
                return Reflect.getOwnPropertyDescriptor(extObj, prop);
            }
            else {
                return Reflect.getOwnPropertyDescriptor(baseObj, prop);
            }
        },
        has(_target, prop) {
            return prop in extObj || prop in baseObj;
        },
    });
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/core/mod.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  AeadId: () => (/* reexport safe */ _src_identifiers_js__WEBPACK_IMPORTED_MODULE_3__.AeadId),
  Aes128Gcm: () => (/* reexport safe */ _src_aeads_aesGcm_js__WEBPACK_IMPORTED_MODULE_0__.Aes128Gcm),
  Aes256Gcm: () => (/* reexport safe */ _src_aeads_aesGcm_js__WEBPACK_IMPORTED_MODULE_0__.Aes256Gcm),
  BaseError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError),
  CipherSuite: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.CipherSuite),
  DecapError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.DecapError),
  DeriveKeyPairError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.DeriveKeyPairError),
  DeserializeError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.DeserializeError),
  DhkemP256HkdfSha256: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.DhkemP256HkdfSha256),
  DhkemP384HkdfSha384: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.DhkemP384HkdfSha384),
  DhkemP521HkdfSha512: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.DhkemP521HkdfSha512),
  EncapError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.EncapError),
  ExportError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.ExportError),
  ExportOnly: () => (/* reexport safe */ _src_aeads_exportOnly_js__WEBPACK_IMPORTED_MODULE_1__.ExportOnly),
  HkdfSha256: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.HkdfSha256),
  HkdfSha384: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.HkdfSha384),
  HkdfSha512: () => (/* reexport safe */ _src_native_js__WEBPACK_IMPORTED_MODULE_4__.HkdfSha512),
  HpkeError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.HpkeError),
  InvalidParamError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError),
  KdfId: () => (/* reexport safe */ _src_identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KdfId),
  KemId: () => (/* reexport safe */ _src_identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KemId),
  MessageLimitReachedError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.MessageLimitReachedError),
  NotSupportedError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.NotSupportedError),
  OpenError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.OpenError),
  SealError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.SealError),
  SerializeError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.SerializeError),
  ValidationError: () => (/* reexport safe */ _src_errors_js__WEBPACK_IMPORTED_MODULE_2__.ValidationError)
});
/* ESM import */var _src_aeads_aesGcm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/aeads/aesGcm.js");
/* ESM import */var _src_aeads_exportOnly_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/aeads/exportOnly.js");
/* ESM import */var _src_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _src_identifiers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");
/* ESM import */var _src_native_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/core/src/native.js");







}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/core/src/native.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  CipherSuite: () => (CipherSuite),
  DhkemP256HkdfSha256: () => (DhkemP256HkdfSha256),
  DhkemP384HkdfSha384: () => (DhkemP384HkdfSha384),
  DhkemP521HkdfSha512: () => (DhkemP521HkdfSha512),
  HkdfSha256: () => (HkdfSha256),
  HkdfSha384: () => (HkdfSha384),
  HkdfSha512: () => (HkdfSha512)
});
/* ESM import */var _src_cipherSuiteNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/cipherSuiteNative.js");
/* ESM import */var _src_kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kdfs/hkdf.js");
/* ESM import */var _src_kems_dhkemNative_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkemNative.js");



/**
 * The Hybrid Public Key Encryption (HPKE) ciphersuite,
 * which is implemented using only
 * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.
 *
 * This class is the same as
 * {@link https://deno.land/x/hpke/mod.ts?s=CipherSuiteNative | @hpke/core#CipherSuiteNative },
 * which supports only the ciphersuites that can be implemented on the native
 * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.
 * Therefore, the following cryptographic algorithms are not supported for now:
 * - `DHKEM(X25519, HKDF-SHA256)`
 * - `DHKEM(X448, HKDF-SHA512)`
 * - `ChaCha20Poly1305`
 *
 * In addtion, the HKDF functions contained in this `CipherSuiteNative`
 * class can only derive keys of the same length as the `hashSize`.
 *
 * If you want to use the unsupported cryptographic algorithms
 * above or derive keys longer than the `hashSize`,
 * please use {@link https://deno.land/x/hpke/mod.ts?s=CipherSuite | hpke-js#CipherSuite}.
 *
 * This class provides following functions:
 *
 * - Creates encryption contexts both for senders and recipients.
 *     - {@link createSenderContext}
 *     - {@link createRecipientContext}
 * - Provides single-shot encryption API.
 *     - {@link seal}
 *     - {@link open}
 *
 * The calling of the constructor of this class is the starting
 * point for HPKE operations for both senders and recipients.
 *
 * @example Use only ciphersuites supported by Web Cryptography API.
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   DhkemP256HkdfSha256,
 *   HkdfSha256,
 *   CipherSuite,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 *
 * @example Use a ciphersuite which is currently not supported by Web Cryptography API.
 *
 * ```ts
 * import { Aes128Gcm, HkdfSha256, CipherSuite } from "http://deno.land/x/hpke/core/mod.ts";
 * import { DhkemX25519HkdfSha256 } from "https://deno.land/x/hpke/x/dhkem-x25519/mod.ts";
 * const suite = new CipherSuite({
 *   kem: new DhkemX25519HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class CipherSuite extends _src_cipherSuiteNative_js__WEBPACK_IMPORTED_MODULE_0__.CipherSuiteNative {
}
/**
 * The DHKEM(P-256, HKDF-SHA256) for HPKE KEM implementing {@link KemInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP256HkdfSha256`
 * as follows:
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   CipherSuite,
 *   DhkemP256HkdfSha256,
 *   HkdfSha256,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class DhkemP256HkdfSha256 extends _src_kems_dhkemNative_js__WEBPACK_IMPORTED_MODULE_2__.DhkemP256HkdfSha256Native {
}
/**
 * The DHKEM(P-384, HKDF-SHA384) for HPKE KEM implementing {@link KemInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP384HkdfSha384`
 * as follows:
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   CipherSuite,
 *   DhkemP384HkdfSha384,
 *   HkdfSha384,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP384HkdfSha384(),
 *   kdf: new HkdfSha384(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class DhkemP384HkdfSha384 extends _src_kems_dhkemNative_js__WEBPACK_IMPORTED_MODULE_2__.DhkemP384HkdfSha384Native {
}
/**
 * The DHKEM(P-521, HKDF-SHA512) for HPKE KEM implementing {@link KemInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP521HkdfSha512`
 * as follows:
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes256Gcm,
 *   CipherSuite,
 *   DhkemP521HkdfSha512,
 *   HkdfSha512,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP521HkdfSha512(),
 *   kdf: new HkdfSha512(),
 *   aead: new Aes256Gcm(),
 * });
 * ```
 */
class DhkemP521HkdfSha512 extends _src_kems_dhkemNative_js__WEBPACK_IMPORTED_MODULE_2__.DhkemP521HkdfSha512Native {
}
/**
 * The HKDF-SHA256 for HPKE KDF implementing {@link KdfInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha256`.
 *
 * The KDF class can only derive keys of the same length as the `hashSize`.
 * If you want to derive keys longer than the `hashSize`,
 * please use {@link https://deno.land/x/hpke/mod.ts?s=CipherSuite | hpke-js#CipherSuite}.
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   CipherSuite,
 *   DhkemP256HkdfSha256,
 *   HkdfSha256,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class HkdfSha256 extends _src_kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__.HkdfSha256Native {
}
/**
 * The HKDF-SHA384 for HPKE KDF implementing {@link KdfInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha384`.
 *
 * The KDF class can only derive keys of the same length as the `hashSize`.
 * If you want to derive keys longer than the `hashSize`,
 * please use {@link https://deno.land/x/hpke/mod.ts?s=CipherSuite | hpke-js#CipherSuite}.
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   CipherSuite,
 *   DhkemP384HkdfSha384,
 *   HkdfSha384,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP384HkdfSha384(),
 *   kdf: new HkdfSha384(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class HkdfSha384 extends _src_kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__.HkdfSha384Native {
}
/**
 * The HKDF-SHA512 for HPKE KDF implementing {@link KdfInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha512`.
 *
 * The KDF class can only derive keys of the same length as the `hashSize`.
 * If you want to derive keys longer than the `hashSize`,
 * please use {@link https://deno.land/x/hpke/mod.ts?s=CipherSuite | hpke-js#CipherSuite}.
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes256Gcm,
 *   CipherSuite,
 *   DhkemP521HkdfSha512,
 *   HkdfSha512,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP521HkdfSha512(),
 *   kdf: new HkdfSha512(),
 *   aead: new Aes256Gcm(),
 * });
 * ```
 */
class HkdfSha512 extends _src_kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__.HkdfSha512Native {
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/aeads/aesGcm.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Aes128Gcm: () => (Aes128Gcm),
  Aes256Gcm: () => (Aes256Gcm),
  AesGcmContext: () => (AesGcmContext)
});
/* ESM import */var _algorithm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/algorithm.js");
/* ESM import */var _identifiers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");
/* ESM import */var _interfaces_aeadEncryptionContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/aeadEncryptionContext.js");



class AesGcmContext extends _algorithm_js__WEBPACK_IMPORTED_MODULE_0__.NativeAlgorithm {
    constructor(key) {
        super();
        Object.defineProperty(this, "_rawKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_key", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        this._rawKey = key;
    }
    async seal(iv, data, aad) {
        await this._setupKey();
        const alg = {
            name: "AES-GCM",
            iv: iv,
            additionalData: aad,
        };
        const ct = await this._api.encrypt(alg, this._key, data);
        return ct;
    }
    async open(iv, data, aad) {
        await this._setupKey();
        const alg = {
            name: "AES-GCM",
            iv: iv,
            additionalData: aad,
        };
        const pt = await this._api.decrypt(alg, this._key, data);
        return pt;
    }
    async _setupKey() {
        if (this._key !== undefined) {
            return;
        }
        await this._setup();
        const key = await this._importKey(this._rawKey);
        (new Uint8Array(this._rawKey)).fill(0);
        this._key = key;
        return;
    }
    async _importKey(key) {
        return await this._api.importKey("raw", key, { name: "AES-GCM" }, true, _interfaces_aeadEncryptionContext_js__WEBPACK_IMPORTED_MODULE_2__.AEAD_USAGES);
    }
}
/**
 * The AES-128-GCM for HPKE AEAD implementing {@link AeadInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `aead` parameter of {@link CipherSuiteParams} instead of `AeadId.Aes128Gcm`.
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   CipherSuite,
 *   DhkemP256HkdfSha256,
 *   HkdfSha256,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class Aes128Gcm {
    constructor() {
        /** AeadId.Aes128Gcm (0x0001) */
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_1__.AeadId.Aes128Gcm
        });
        /** 16 */
        Object.defineProperty(this, "keySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 16
        });
        /** 12 */
        Object.defineProperty(this, "nonceSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 12
        });
        /** 16 */
        Object.defineProperty(this, "tagSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 16
        });
    }
    createEncryptionContext(key) {
        return new AesGcmContext(key);
    }
}
/**
 * The AES-256-GCM for HPKE AEAD implementing {@link AeadInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `aead` parameter of {@link CipherSuiteParams} instead of `AeadId.Aes256Gcm`
 * as follows:
 *
 * @example
 *
 * ```ts
 * import {
 *   Aes256Gcm,
 *   CipherSuite,
 *   DhkemP256HkdfSha256,
 *   HkdfSha256,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes256Gcm(),
 * });
 * ```
 */
class Aes256Gcm extends Aes128Gcm {
    constructor() {
        super(...arguments);
        /** AeadId.Aes256Gcm (0x0002) */
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_1__.AeadId.Aes256Gcm
        });
        /** 32 */
        Object.defineProperty(this, "keySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 32
        });
        /** 12 */
        Object.defineProperty(this, "nonceSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 12
        });
        /** 16 */
        Object.defineProperty(this, "tagSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 16
        });
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/aeads/exportOnly.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  ExportOnly: () => (ExportOnly)
});
/* ESM import */var _identifiers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");


/**
 * The ExportOnly mode for HPKE AEAD implementing {@link AeadInterface}.
 *
 * When using `@hpke/core`, the instance of this class must be specified
 * to the `aead` parameter of {@link CipherSuiteParams} instead of `AeadId.ExportOnly`
 * as follows:
 *
 * @example
 *
 * ```ts
 * import {
 *   CipherSuite,
 *   DhkemP256HkdfSha256,
 *   ExportOnly,
 *   HkdfSha256,
 * } from "http://deno.land/x/hpke/core/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new ExportOnly(),
 * });
 * ```
 */
class ExportOnly {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_0__.AeadId.ExportOnly
        });
        Object.defineProperty(this, "keySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "nonceSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "tagSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    createEncryptionContext(_key) {
        throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.NotSupportedError("Export only");
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/algorithm.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  NativeAlgorithm: () => (NativeAlgorithm)
});
/* ESM import */var _dnt_shims_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/_dnt.shims.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");


async function loadSubtleCrypto() {
    if (_dnt_shims_js__WEBPACK_IMPORTED_MODULE_0__.dntGlobalThis !== undefined && globalThis.crypto !== undefined) {
        // Browsers, Node.js >= v19, Cloudflare Workers, Bun, etc.
        return globalThis.crypto.subtle;
    }
    // Node.js <= v18
    try {
        // @ts-ignore: to ignore "crypto"
        const { webcrypto } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, "../../node_modules/crypto-browserify/index.js", 19)); // node:crypto
        return webcrypto.subtle;
    }
    catch (e) {
        throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.NotSupportedError(e);
    }
}
class NativeAlgorithm {
    constructor() {
        Object.defineProperty(this, "_api", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
    }
    async _setup() {
        if (this._api !== undefined) {
            return;
        }
        this._api = await loadSubtleCrypto();
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/cipherSuiteNative.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  CipherSuiteNative: () => (CipherSuiteNative)
});
/* ESM import */var _algorithm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/algorithm.js");
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _exporterContext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/exporterContext.js");
/* ESM import */var _identifiers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");
/* ESM import */var _recipientContext_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/recipientContext.js");
/* ESM import */var _senderContext_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/senderContext.js");
/* ESM import */var _utils_misc_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/misc.js");








// b"base_nonce"
// deno-fmt-ignore
const LABEL_BASE_NONCE = new Uint8Array([
    98, 97, 115, 101, 95, 110, 111, 110, 99, 101,
]);
// b"exp"
const LABEL_EXP = new Uint8Array([101, 120, 112]);
// b"info_hash"
// deno-fmt-ignore
const LABEL_INFO_HASH = new Uint8Array([
    105, 110, 102, 111, 95, 104, 97, 115, 104,
]);
// b"key"
const LABEL_KEY = new Uint8Array([107, 101, 121]);
// b"psk_id_hash"
// deno-fmt-ignore
const LABEL_PSK_ID_HASH = new Uint8Array([
    112, 115, 107, 95, 105, 100, 95, 104, 97, 115, 104,
]);
// b"secret"
const LABEL_SECRET = new Uint8Array([115, 101, 99, 114, 101, 116]);
// b"HPKE"
// deno-fmt-ignore
const SUITE_ID_HEADER_HPKE = new Uint8Array([
    72, 80, 75, 69, 0, 0, 0, 0, 0, 0,
]);
/**
 * The Hybrid Public Key Encryption (HPKE) ciphersuite,
 * which is implemented using only
 * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.
 *
 * This is the super class of {@link CipherSuite} and the same as
 * {@link https://deno.land/x/hpke/core/mod.ts?s=CipherSuite | @hpke/core#CipherSuite },
 * which supports only the ciphersuites that can be implemented on the native
 * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.
 * Therefore, the following cryptographic algorithms are not supported for now:
 *   - DHKEM(X25519, HKDF-SHA256)
 *   - DHKEM(X448, HKDF-SHA512)
 *   - ChaCha20Poly1305
 *
 * In addtion, the HKDF functions contained in this class can only derive
 * keys of the same length as the `hashSize`.
 *
 * If you want to use the unsupported cryptographic algorithms
 * above or derive keys longer than the `hashSize`,
 * please use {@link CipherSuite}.
 *
 * This class provides following functions:
 *
 * - Creates encryption contexts both for senders and recipients.
 *   - {@link createSenderContext}
 *   - {@link createRecipientContext}
 * - Provides single-shot encryption API.
 *   - {@link seal}
 *   - {@link open}
 *
 * The calling of the constructor of this class is the starting
 * point for HPKE operations for both senders and recipients.
 *
 * @example Use only ciphersuites supported by Web Cryptography API.
 *
 * ```ts
 * import {
 *   Aes128Gcm,
 *   DhkemP256HkdfSha256,
 *   HkdfSha256,
 *   CipherSuite,
 * } from "http://deno.land/x/hpke/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemP256HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 *
 * @example Use a ciphersuite which is currently not supported by Web Cryptography API.
 *
 * ```ts
 * import { Aes128Gcm, HkdfSha256, CipherSuite } from "http://deno.land/x/hpke/mod.ts";
 * // Use an extension module.
 * import { DhkemX25519HkdfSha256 } from "https://deno.land/x/hpke/x/dhkem-x25519/mod.ts";
 *
 * const suite = new CipherSuite({
 *   kem: new DhkemX25519HkdfSha256(),
 *   kdf: new HkdfSha256(),
 *   aead: new Aes128Gcm(),
 * });
 * ```
 */
class CipherSuiteNative extends _algorithm_js__WEBPACK_IMPORTED_MODULE_0__.NativeAlgorithm {
    /**
     * @param params A set of parameters for building a cipher suite.
     *
     * If the error occurred, throws {@link InvalidParamError}.
     *
     * @throws {@link InvalidParamError}
     */
    constructor(params) {
        super();
        Object.defineProperty(this, "_kem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_kdf", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_aead", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_suiteId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // KEM
        if (typeof params.kem === "number") {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("KemId cannot be used");
        }
        this._kem = params.kem;
        // KDF
        if (typeof params.kdf === "number") {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("KdfId cannot be used");
        }
        this._kdf = params.kdf;
        // AEAD
        if (typeof params.aead === "number") {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("AeadId cannot be used");
        }
        this._aead = params.aead;
        this._suiteId = new Uint8Array(SUITE_ID_HEADER_HPKE);
        this._suiteId.set((0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_7__.i2Osp)(this._kem.id, 2), 4);
        this._suiteId.set((0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_7__.i2Osp)(this._kdf.id, 2), 6);
        this._suiteId.set((0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_7__.i2Osp)(this._aead.id, 2), 8);
        this._kdf.init(this._suiteId);
    }
    /**
     * Gets the KEM context of the ciphersuite.
     */
    get kem() {
        return this._kem;
    }
    /**
     * Gets the KDF context of the ciphersuite.
     */
    get kdf() {
        return this._kdf;
    }
    /**
     * Gets the AEAD context of the ciphersuite.
     */
    get aead() {
        return this._aead;
    }
    /**
     * Creates an encryption context for a sender.
     *
     * If the error occurred, throws {@link DecapError} | {@link ValidationError}.
     *
     * @param params A set of parameters for the sender encryption context.
     * @returns A sender encryption context.
     * @throws {@link EncapError}, {@link ValidationError}
     */
    async createSenderContext(params) {
        this._validateInputLength(params);
        await this._setup();
        const dh = await this._kem.encap(params);
        let mode;
        if (params.psk !== undefined) {
            mode = params.senderKey !== undefined ? _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.AuthPsk : _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.Psk;
        }
        else {
            mode = params.senderKey !== undefined ? _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.Auth : _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.Base;
        }
        return await this._keyScheduleS(mode, dh.sharedSecret, dh.enc, params);
    }
    /**
     * Creates an encryption context for a recipient.
     *
     * If the error occurred, throws {@link DecapError}
     * | {@link DeserializeError} | {@link ValidationError}.
     *
     * @param params A set of parameters for the recipient encryption context.
     * @returns A recipient encryption context.
     * @throws {@link DecapError}, {@link DeserializeError}, {@link ValidationError}
     */
    async createRecipientContext(params) {
        this._validateInputLength(params);
        await this._setup();
        const sharedSecret = await this._kem.decap(params);
        let mode;
        if (params.psk !== undefined) {
            mode = params.senderPublicKey !== undefined ? _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.AuthPsk : _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.Psk;
        }
        else {
            mode = params.senderPublicKey !== undefined ? _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.Auth : _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.Mode.Base;
        }
        return await this._keyScheduleR(mode, sharedSecret, params);
    }
    /**
     * Encrypts a message to a recipient.
     *
     * If the error occurred, throws `EncapError` | `MessageLimitReachedError` | `SealError` | `ValidationError`.
     *
     * @param params A set of parameters for building a sender encryption context.
     * @param pt A plain text as bytes to be encrypted.
     * @param aad Additional authenticated data as bytes fed by an application.
     * @returns A cipher text and an encapsulated key as bytes.
     * @throws {@link EncapError}, {@link MessageLimitReachedError}, {@link SealError}, {@link ValidationError}
     */
    async seal(params, pt, aad = _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY) {
        const ctx = await this.createSenderContext(params);
        return {
            ct: await ctx.seal(pt, aad),
            enc: ctx.enc,
        };
    }
    /**
     * Decrypts a message from a sender.
     *
     * If the error occurred, throws `DecapError` | `DeserializeError` | `OpenError` | `ValidationError`.
     *
     * @param params A set of parameters for building a recipient encryption context.
     * @param ct An encrypted text as bytes to be decrypted.
     * @param aad Additional authenticated data as bytes fed by an application.
     * @returns A decrypted plain text as bytes.
     * @throws {@link DecapError}, {@link DeserializeError}, {@link OpenError}, {@link ValidationError}
     */
    async open(params, ct, aad = _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY) {
        const ctx = await this.createRecipientContext(params);
        return await ctx.open(ct, aad);
    }
    // private verifyPskInputs(mode: Mode, params: KeyScheduleParams) {
    //   const gotPsk = (params.psk !== undefined);
    //   const gotPskId = (params.psk !== undefined && params.psk.id.byteLength > 0);
    //   if (gotPsk !== gotPskId) {
    //     throw new Error('Inconsistent PSK inputs');
    //   }
    //   if (gotPsk && (mode === Mode.Base || mode === Mode.Auth)) {
    //     throw new Error('PSK input provided when not needed');
    //   }
    //   if (!gotPsk && (mode === Mode.Psk || mode === Mode.AuthPsk)) {
    //     throw new Error('Missing required PSK input');
    //   }
    //   return;
    // }
    async _keySchedule(mode, sharedSecret, params) {
        // Currently, there is no point in executing this function
        // because this hpke library does not allow users to explicitly specify the mode.
        //
        // this.verifyPskInputs(mode, params);
        const pskId = params.psk === undefined
            ? _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY
            : new Uint8Array(params.psk.id);
        const pskIdHash = await this._kdf.labeledExtract(_consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY, LABEL_PSK_ID_HASH, pskId);
        const info = params.info === undefined
            ? _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY
            : new Uint8Array(params.info);
        const infoHash = await this._kdf.labeledExtract(_consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY, LABEL_INFO_HASH, info);
        const keyScheduleContext = new Uint8Array(1 + pskIdHash.byteLength + infoHash.byteLength);
        keyScheduleContext.set(new Uint8Array([mode]), 0);
        keyScheduleContext.set(new Uint8Array(pskIdHash), 1);
        keyScheduleContext.set(new Uint8Array(infoHash), 1 + pskIdHash.byteLength);
        const psk = params.psk === undefined
            ? _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY
            : new Uint8Array(params.psk.key);
        const ikm = this._kdf.buildLabeledIkm(LABEL_SECRET, psk);
        const exporterSecretInfo = this._kdf.buildLabeledInfo(LABEL_EXP, keyScheduleContext, this._kdf.hashSize);
        const exporterSecret = await this._kdf.extractAndExpand(sharedSecret, ikm, exporterSecretInfo, this._kdf.hashSize);
        if (this._aead.id === _identifiers_js__WEBPACK_IMPORTED_MODULE_4__.AeadId.ExportOnly) {
            return { aead: this._aead, exporterSecret: exporterSecret };
        }
        const keyInfo = this._kdf.buildLabeledInfo(LABEL_KEY, keyScheduleContext, this._aead.keySize);
        const key = await this._kdf.extractAndExpand(sharedSecret, ikm, keyInfo, this._aead.keySize);
        const baseNonceInfo = this._kdf.buildLabeledInfo(LABEL_BASE_NONCE, keyScheduleContext, this._aead.nonceSize);
        const baseNonce = await this._kdf.extractAndExpand(sharedSecret, ikm, baseNonceInfo, this._aead.nonceSize);
        return {
            aead: this._aead,
            exporterSecret: exporterSecret,
            key: key,
            baseNonce: new Uint8Array(baseNonce),
            seq: 0,
        };
    }
    async _keyScheduleS(mode, sharedSecret, enc, params) {
        const res = await this._keySchedule(mode, sharedSecret, params);
        if (res.key === undefined) {
            return new _exporterContext_js__WEBPACK_IMPORTED_MODULE_3__.SenderExporterContextImpl(this._api, this._kdf, res.exporterSecret, enc);
        }
        return new _senderContext_js__WEBPACK_IMPORTED_MODULE_6__.SenderContextImpl(this._api, this._kdf, res, enc);
    }
    async _keyScheduleR(mode, sharedSecret, params) {
        const res = await this._keySchedule(mode, sharedSecret, params);
        if (res.key === undefined) {
            return new _exporterContext_js__WEBPACK_IMPORTED_MODULE_3__.RecipientExporterContextImpl(this._api, this._kdf, res.exporterSecret);
        }
        return new _recipientContext_js__WEBPACK_IMPORTED_MODULE_5__.RecipientContextImpl(this._api, this._kdf, res);
    }
    _validateInputLength(params) {
        if (params.info !== undefined &&
            params.info.byteLength > _consts_js__WEBPACK_IMPORTED_MODULE_1__.INPUT_LENGTH_LIMIT) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("Too long info");
        }
        if (params.psk !== undefined) {
            if (params.psk.key.byteLength < _consts_js__WEBPACK_IMPORTED_MODULE_1__.MINIMUM_PSK_LENGTH) {
                throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError(`PSK must have at least ${_consts_js__WEBPACK_IMPORTED_MODULE_1__.MINIMUM_PSK_LENGTH} bytes`);
            }
            if (params.psk.key.byteLength > _consts_js__WEBPACK_IMPORTED_MODULE_1__.INPUT_LENGTH_LIMIT) {
                throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("Too long psk.key");
            }
            if (params.psk.id.byteLength > _consts_js__WEBPACK_IMPORTED_MODULE_1__.INPUT_LENGTH_LIMIT) {
                throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("Too long psk.id");
            }
        }
        return;
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  EMPTY: () => (EMPTY),
  INPUT_LENGTH_LIMIT: () => (INPUT_LENGTH_LIMIT),
  MINIMUM_PSK_LENGTH: () => (MINIMUM_PSK_LENGTH)
});
// The input length limit (psk, psk_id, info, exporter_context, ikm).
const INPUT_LENGTH_LIMIT = 8192;
// The minimum length of a PSK.
const MINIMUM_PSK_LENGTH = 32;
// b""
const EMPTY = new Uint8Array(0);


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/encryptionContext.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  EncryptionContextImpl: () => (EncryptionContextImpl),
  xor: () => (xor)
});
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _exporterContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/exporterContext.js");
/* ESM import */var _utils_misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/misc.js");



function xor(a, b) {
    if (a.byteLength !== b.byteLength) {
        throw new Error("xor: different length inputs");
    }
    const buf = new Uint8Array(a.byteLength);
    for (let i = 0; i < a.byteLength; i++) {
        buf[i] = a[i] ^ b[i];
    }
    return buf;
}
class EncryptionContextImpl extends _exporterContext_js__WEBPACK_IMPORTED_MODULE_1__.ExporterContextImpl {
    constructor(api, kdf, params) {
        super(api, kdf, params.exporterSecret);
        // AEAD id.
        Object.defineProperty(this, "_aead", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // The length in bytes of a key for the algorithm.
        Object.defineProperty(this, "_nK", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // The length in bytes of a nonce for the algorithm.
        Object.defineProperty(this, "_nN", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // The length in bytes of an authentication tag for the algorithm.
        Object.defineProperty(this, "_nT", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // The end-to-end encryption key information.
        Object.defineProperty(this, "_ctx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (params.key === undefined || params.baseNonce === undefined ||
            params.seq === undefined) {
            throw new Error("Required parameters are missing");
        }
        this._aead = params.aead;
        this._nK = this._aead.keySize;
        this._nN = this._aead.nonceSize;
        this._nT = this._aead.tagSize;
        const key = this._aead.createEncryptionContext(params.key);
        this._ctx = {
            key: key,
            baseNonce: params.baseNonce,
            seq: params.seq,
        };
    }
    computeNonce(k) {
        const seqBytes = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_2__.i2Osp)(k.seq, k.baseNonce.byteLength);
        return xor(k.baseNonce, seqBytes);
    }
    incrementSeq(k) {
        // if (this.seq >= (1 << (8 * this.baseNonce.byteLength)) - 1) {
        if (k.seq > Number.MAX_SAFE_INTEGER) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_0__.MessageLimitReachedError("Message limit reached");
        }
        k.seq += 1;
        return;
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  BaseError: () => (BaseError),
  DecapError: () => (DecapError),
  DeriveKeyPairError: () => (DeriveKeyPairError),
  DeserializeError: () => (DeserializeError),
  EncapError: () => (EncapError),
  ExportError: () => (ExportError),
  HpkeError: () => (HpkeError),
  InvalidParamError: () => (InvalidParamError),
  MessageLimitReachedError: () => (MessageLimitReachedError),
  NotSupportedError: () => (NotSupportedError),
  OpenError: () => (OpenError),
  SealError: () => (SealError),
  SerializeError: () => (SerializeError),
  ValidationError: () => (ValidationError)
});
/**
 * The base error class of hpke-js.
 */
class BaseError extends Error {
    constructor(e) {
        let message;
        if (e instanceof Error) {
            message = e.message;
        }
        else if (typeof e === "string") {
            message = e;
        }
        else {
            message = "";
        }
        super(message);
        this.name = this.constructor.name;
    }
}
/**
 * The base error class of hpke-js.
 */
class HpkeError extends BaseError {
}
/**
 * Invalid parameter.
 */
class InvalidParamError extends HpkeError {
}
/**
 * KEM input or output validation failure.
 */
class ValidationError extends HpkeError {
}
/**
 * Public or private key serialization failure.
 */
class SerializeError extends HpkeError {
}
/**
 * Public or private key deserialization failure.
 */
class DeserializeError extends HpkeError {
}
/**
 * encap() failure.
 */
class EncapError extends HpkeError {
}
/**
 * decap() failure.
 */
class DecapError extends HpkeError {
}
/**
 * Secret export failure.
 */
class ExportError extends HpkeError {
}
/**
 * seal() failure.
 */
class SealError extends HpkeError {
}
/**
 * open() failure.
 */
class OpenError extends HpkeError {
}
/**
 * Sequence number overflow on the encryption context.
 */
class MessageLimitReachedError extends HpkeError {
}
/**
 * Key pair derivation failure.
 */
class DeriveKeyPairError extends HpkeError {
}
/**
 * Not supported failure.
 */
class NotSupportedError extends HpkeError {
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/exporterContext.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  ExporterContextImpl: () => (ExporterContextImpl),
  RecipientExporterContextImpl: () => (RecipientExporterContextImpl),
  SenderExporterContextImpl: () => (SenderExporterContextImpl)
});
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _utils_emitNotSupported_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/emitNotSupported.js");



// b"sec"
const LABEL_SEC = new Uint8Array([115, 101, 99]);
class ExporterContextImpl {
    constructor(api, kdf, exporterSecret) {
        Object.defineProperty(this, "_api", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "exporterSecret", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_kdf", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._api = api;
        this._kdf = kdf;
        this.exporterSecret = exporterSecret;
    }
    async seal(_data, _aad) {
        return await (0,_utils_emitNotSupported_js__WEBPACK_IMPORTED_MODULE_2__.emitNotSupported)();
    }
    async open(_data, _aad) {
        return await (0,_utils_emitNotSupported_js__WEBPACK_IMPORTED_MODULE_2__.emitNotSupported)();
    }
    async export(exporterContext, len) {
        if (exporterContext.byteLength > _consts_js__WEBPACK_IMPORTED_MODULE_0__.INPUT_LENGTH_LIMIT) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidParamError("Too long exporter context");
        }
        try {
            return await this._kdf.labeledExpand(this.exporterSecret, LABEL_SEC, new Uint8Array(exporterContext), len);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.ExportError(e);
        }
    }
}
class RecipientExporterContextImpl extends ExporterContextImpl {
}
class SenderExporterContextImpl extends ExporterContextImpl {
    constructor(api, kdf, exporterSecret, enc) {
        super(api, kdf, exporterSecret);
        Object.defineProperty(this, "enc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.enc = enc;
        return;
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Aead: () => (Aead),
  AeadId: () => (AeadId),
  Kdf: () => (Kdf),
  KdfId: () => (KdfId),
  Kem: () => (Kem),
  KemId: () => (KemId),
  Mode: () => (Mode)
});
/**
 * The supported HPKE modes.
 */
const Mode = {
    Base: 0x00,
    Psk: 0x01,
    Auth: 0x02,
    AuthPsk: 0x03,
};
/**
 * The supported Key Encapsulation Mechanism (KEM) identifiers.
 *
 * @deprecated Use {@link KdfId} instead.
 */
const Kem = {
    NotAssigned: 0x0000,
    DhkemP256HkdfSha256: 0x0010,
    DhkemP384HkdfSha384: 0x0011,
    DhkemP521HkdfSha512: 0x0012,
    DhkemSecp256k1HkdfSha256: 0x0013,
    DhkemX25519HkdfSha256: 0x0020,
    DhkemX448HkdfSha512: 0x0021,
    HybridkemX25519Kyber768: 0x0030,
};
/**
 * The supported Key Encapsulation Mechanism (KEM) identifiers.
 */
const KemId = Kem;
/**
 * The supported Key Derivation Function (KDF) identifiers.
 *
 * @deprecated Use {@link KdfId} instead.
 */
const Kdf = {
    HkdfSha256: 0x0001,
    HkdfSha384: 0x0002,
    HkdfSha512: 0x0003,
};
/**
 * The supported Key Derivation Function (KDF) identifiers.
 */
const KdfId = Kdf;
/**
 * The supported Authenticated Encryption with Associated Data (AEAD) identifiers.
 *
 * @deprecated Use {@link AeadId} instead.
 */
const Aead = {
    Aes128Gcm: 0x0001,
    Aes256Gcm: 0x0002,
    Chacha20Poly1305: 0x0003,
    ExportOnly: 0xFFFF,
};
/**
 * The supported Authenticated Encryption with Associated Data (AEAD) identifiers.
 */
const AeadId = Aead;


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/aeadEncryptionContext.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  AEAD_USAGES: () => (AEAD_USAGES)
});
// The key usages for AEAD.
const AEAD_USAGES = ["encrypt", "decrypt"];


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/dhkemPrimitives.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  KEM_USAGES: () => (KEM_USAGES),
  LABEL_DKP_PRK: () => (LABEL_DKP_PRK),
  LABEL_SK: () => (LABEL_SK)
});
// The key usages for KEM.
const KEM_USAGES = ["deriveBits"];
// b"dkp_prk"
const LABEL_DKP_PRK = new Uint8Array([100, 107, 112, 95, 112, 114, 107]);
// b"sk"
const LABEL_SK = new Uint8Array([115, 107]);


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/kemInterface.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  SUITE_ID_HEADER_KEM: () => (SUITE_ID_HEADER_KEM)
});
// b"KEM"
const SUITE_ID_HEADER_KEM = new Uint8Array([75, 69, 77, 0, 0]);


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kdfs/hkdf.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  HkdfNative: () => (HkdfNative),
  HkdfSha256Native: () => (HkdfSha256Native),
  HkdfSha384Native: () => (HkdfSha384Native),
  HkdfSha512Native: () => (HkdfSha512Native)
});
/* ESM import */var _algorithm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/algorithm.js");
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _identifiers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");




// b"HPKE-v1"
const HPKE_VERSION = new Uint8Array([72, 80, 75, 69, 45, 118, 49]);
class HkdfNative extends _algorithm_js__WEBPACK_IMPORTED_MODULE_0__.NativeAlgorithm {
    constructor() {
        super();
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KdfId.HkdfSha256
        });
        Object.defineProperty(this, "hashSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_suiteId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY
        });
        Object.defineProperty(this, "algHash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                name: "HMAC",
                hash: "SHA-256",
                length: 256,
            }
        });
    }
    init(suiteId) {
        this._suiteId = suiteId;
    }
    buildLabeledIkm(label, ikm) {
        this._checkInit();
        const ret = new Uint8Array(7 + this._suiteId.byteLength + label.byteLength + ikm.byteLength);
        ret.set(HPKE_VERSION, 0);
        ret.set(this._suiteId, 7);
        ret.set(label, 7 + this._suiteId.byteLength);
        ret.set(ikm, 7 + this._suiteId.byteLength + label.byteLength);
        return ret;
    }
    buildLabeledInfo(label, info, len) {
        this._checkInit();
        const ret = new Uint8Array(9 + this._suiteId.byteLength + label.byteLength + info.byteLength);
        ret.set(new Uint8Array([0, len]), 0);
        ret.set(HPKE_VERSION, 2);
        ret.set(this._suiteId, 9);
        ret.set(label, 9 + this._suiteId.byteLength);
        ret.set(info, 9 + this._suiteId.byteLength + label.byteLength);
        return ret;
    }
    async extract(salt, ikm) {
        await this._setup();
        if (salt.byteLength === 0) {
            salt = new ArrayBuffer(this.hashSize);
        }
        if (salt.byteLength !== this.hashSize) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidParamError("The salt length must be the same as the hashSize");
        }
        const key = await this._api.importKey("raw", salt, this.algHash, false, [
            "sign",
        ]);
        return await this._api.sign("HMAC", key, ikm);
    }
    async expand(prk, info, len) {
        await this._setup();
        const key = await this._api.importKey("raw", prk, this.algHash, false, [
            "sign",
        ]);
        const okm = new ArrayBuffer(len);
        const p = new Uint8Array(okm);
        let prev = _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY;
        const mid = new Uint8Array(info);
        const tail = new Uint8Array(1);
        if (len > 255 * this.hashSize) {
            throw new Error("Entropy limit reached");
        }
        const tmp = new Uint8Array(this.hashSize + mid.length + 1);
        for (let i = 1, cur = 0; cur < p.length; i++) {
            tail[0] = i;
            tmp.set(prev, 0);
            tmp.set(mid, prev.length);
            tmp.set(tail, prev.length + mid.length);
            prev = new Uint8Array(await this._api.sign("HMAC", key, tmp.slice(0, prev.length + mid.length + 1)));
            if (p.length - cur >= prev.length) {
                p.set(prev, cur);
                cur += prev.length;
            }
            else {
                p.set(prev.slice(0, p.length - cur), cur);
                cur += p.length - cur;
            }
        }
        return okm;
    }
    async extractAndExpand(salt, ikm, info, len) {
        await this._setup();
        const baseKey = await this._api.importKey("raw", ikm, "HKDF", false, ["deriveBits"]);
        return await this._api.deriveBits({
            name: "HKDF",
            hash: this.algHash.hash,
            salt: salt,
            info: info,
        }, baseKey, len * 8);
    }
    async labeledExtract(salt, label, ikm) {
        return await this.extract(salt, this.buildLabeledIkm(label, ikm));
    }
    async labeledExpand(prk, label, info, len) {
        return await this.expand(prk, this.buildLabeledInfo(label, info, len), len);
    }
    _checkInit() {
        if (this._suiteId === _consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY) {
            throw new Error("Not initialized. Call init()");
        }
    }
}
class HkdfSha256Native extends HkdfNative {
    constructor() {
        super(...arguments);
        /** KdfId.HkdfSha256 (0x0001) */
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KdfId.HkdfSha256
        });
        /** 32 */
        Object.defineProperty(this, "hashSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 32
        });
        /** The parameters for Web Cryptography API */
        Object.defineProperty(this, "algHash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                name: "HMAC",
                hash: "SHA-256",
                length: 256,
            }
        });
    }
}
class HkdfSha384Native extends HkdfNative {
    constructor() {
        super(...arguments);
        /** KdfId.HkdfSha384 (0x0002) */
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KdfId.HkdfSha384
        });
        /** 48 */
        Object.defineProperty(this, "hashSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 48
        });
        /** The parameters for Web Cryptography API */
        Object.defineProperty(this, "algHash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                name: "HMAC",
                hash: "SHA-384",
                length: 384,
            }
        });
    }
}
class HkdfSha512Native extends HkdfNative {
    constructor() {
        super(...arguments);
        /** KdfId.HkdfSha512 (0x0003) */
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KdfId.HkdfSha512
        });
        /** 64 */
        Object.defineProperty(this, "hashSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 64
        });
        /** The parameters for Web Cryptography API */
        Object.defineProperty(this, "algHash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                name: "HMAC",
                hash: "SHA-512",
                length: 512,
            }
        });
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkem.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Dhkem: () => (Dhkem)
});
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _interfaces_kemInterface_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/kemInterface.js");
/* ESM import */var _utils_misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/misc.js");




// b"eae_prk"
const LABEL_EAE_PRK = new Uint8Array([101, 97, 101, 95, 112, 114, 107]);
// b"shared_secret"
// deno-fmt-ignore
const LABEL_SHARED_SECRET = new Uint8Array([
    115, 104, 97, 114, 101, 100, 95, 115, 101, 99,
    114, 101, 116,
]);
function concat3(a, b, c) {
    const ret = new Uint8Array(a.length + b.length + c.length);
    ret.set(a, 0);
    ret.set(b, a.length);
    ret.set(c, a.length + b.length);
    return ret;
}
class Dhkem {
    constructor(id, prim, kdf) {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "secretSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "encSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "publicKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "privateKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_prim", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_kdf", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.id = id;
        this._prim = prim;
        this._kdf = kdf;
        const suiteId = new Uint8Array(_interfaces_kemInterface_js__WEBPACK_IMPORTED_MODULE_2__.SUITE_ID_HEADER_KEM);
        suiteId.set((0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.i2Osp)(this.id, 2), 3);
        this._kdf.init(suiteId);
    }
    async serializePublicKey(key) {
        return await this._prim.serializePublicKey(key);
    }
    async deserializePublicKey(key) {
        return await this._prim.deserializePublicKey(key);
    }
    async serializePrivateKey(key) {
        return await this._prim.serializePrivateKey(key);
    }
    async deserializePrivateKey(key) {
        return await this._prim.deserializePrivateKey(key);
    }
    async importKey(format, key, isPublic = true) {
        return await this._prim.importKey(format, key, isPublic);
    }
    async generateKeyPair() {
        return await this._prim.generateKeyPair();
    }
    async deriveKeyPair(ikm) {
        if (ikm.byteLength > _consts_js__WEBPACK_IMPORTED_MODULE_0__.INPUT_LENGTH_LIMIT) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidParamError("Too long ikm");
        }
        return await this._prim.deriveKeyPair(ikm);
    }
    async encap(params) {
        let ke;
        if (params.ekm === undefined) {
            ke = await this.generateKeyPair();
        }
        else if ((0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.isCryptoKeyPair)(params.ekm)) {
            // params.ekm is only used for testing.
            ke = params.ekm;
        }
        else {
            // params.ekm is only used for testing.
            ke = await this.deriveKeyPair(params.ekm);
        }
        const enc = await this._prim.serializePublicKey(ke.publicKey);
        const pkrm = await this._prim.serializePublicKey(params.recipientPublicKey);
        try {
            let dh;
            if (params.senderKey === undefined) {
                dh = new Uint8Array(await this._prim.dh(ke.privateKey, params.recipientPublicKey));
            }
            else {
                const sks = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.isCryptoKeyPair)(params.senderKey)
                    ? params.senderKey.privateKey
                    : params.senderKey;
                const dh1 = new Uint8Array(await this._prim.dh(ke.privateKey, params.recipientPublicKey));
                const dh2 = new Uint8Array(await this._prim.dh(sks, params.recipientPublicKey));
                dh = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.concat)(dh1, dh2);
            }
            let kemContext;
            if (params.senderKey === undefined) {
                kemContext = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.concat)(new Uint8Array(enc), new Uint8Array(pkrm));
            }
            else {
                const pks = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.isCryptoKeyPair)(params.senderKey)
                    ? params.senderKey.publicKey
                    : await this._prim.derivePublicKey(params.senderKey);
                const pksm = await this._prim.serializePublicKey(pks);
                kemContext = concat3(new Uint8Array(enc), new Uint8Array(pkrm), new Uint8Array(pksm));
            }
            const sharedSecret = await this._generateSharedSecret(dh, kemContext);
            return {
                enc: enc,
                sharedSecret: sharedSecret,
            };
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.EncapError(e);
        }
    }
    async decap(params) {
        const pke = await this._prim.deserializePublicKey(params.enc);
        const skr = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.isCryptoKeyPair)(params.recipientKey)
            ? params.recipientKey.privateKey
            : params.recipientKey;
        const pkr = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.isCryptoKeyPair)(params.recipientKey)
            ? params.recipientKey.publicKey
            : await this._prim.derivePublicKey(params.recipientKey);
        const pkrm = await this._prim.serializePublicKey(pkr);
        try {
            let dh;
            if (params.senderPublicKey === undefined) {
                dh = new Uint8Array(await this._prim.dh(skr, pke));
            }
            else {
                const dh1 = new Uint8Array(await this._prim.dh(skr, pke));
                const dh2 = new Uint8Array(await this._prim.dh(skr, params.senderPublicKey));
                dh = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.concat)(dh1, dh2);
            }
            let kemContext;
            if (params.senderPublicKey === undefined) {
                kemContext = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_3__.concat)(new Uint8Array(params.enc), new Uint8Array(pkrm));
            }
            else {
                const pksm = await this._prim.serializePublicKey(params.senderPublicKey);
                kemContext = new Uint8Array(params.enc.byteLength + pkrm.byteLength + pksm.byteLength);
                kemContext.set(new Uint8Array(params.enc), 0);
                kemContext.set(new Uint8Array(pkrm), params.enc.byteLength);
                kemContext.set(new Uint8Array(pksm), params.enc.byteLength + pkrm.byteLength);
            }
            return await this._generateSharedSecret(dh, kemContext);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.DecapError(e);
        }
    }
    async _generateSharedSecret(dh, kemContext) {
        const labeledIkm = this._kdf.buildLabeledIkm(LABEL_EAE_PRK, dh);
        const labeledInfo = this._kdf.buildLabeledInfo(LABEL_SHARED_SECRET, kemContext, this.secretSize);
        return await this._kdf.extractAndExpand(_consts_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY, labeledIkm, labeledInfo, this.secretSize);
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkemNative.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  DhkemP256HkdfSha256Native: () => (DhkemP256HkdfSha256Native),
  DhkemP384HkdfSha384Native: () => (DhkemP384HkdfSha384Native),
  DhkemP521HkdfSha512Native: () => (DhkemP521HkdfSha512Native)
});
/* ESM import */var _identifiers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");
/* ESM import */var _kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kdfs/hkdf.js");
/* ESM import */var _dhkem_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkem.js");
/* ESM import */var _dhkemPrimitives_ec_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkemPrimitives/ec.js");




class DhkemP256HkdfSha256Native extends _dhkem_js__WEBPACK_IMPORTED_MODULE_2__.Dhkem {
    constructor() {
        const kdf = new _kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__.HkdfSha256Native();
        const prim = new _dhkemPrimitives_ec_js__WEBPACK_IMPORTED_MODULE_3__.Ec(_identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP256HkdfSha256, kdf);
        super(_identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP256HkdfSha256, prim, kdf);
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP256HkdfSha256
        });
        Object.defineProperty(this, "secretSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 32
        });
        Object.defineProperty(this, "encSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 65
        });
        Object.defineProperty(this, "publicKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 65
        });
        Object.defineProperty(this, "privateKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 32
        });
    }
}
class DhkemP384HkdfSha384Native extends _dhkem_js__WEBPACK_IMPORTED_MODULE_2__.Dhkem {
    constructor() {
        const kdf = new _kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__.HkdfSha384Native();
        const prim = new _dhkemPrimitives_ec_js__WEBPACK_IMPORTED_MODULE_3__.Ec(_identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP384HkdfSha384, kdf);
        super(_identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP384HkdfSha384, prim, kdf);
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP384HkdfSha384
        });
        Object.defineProperty(this, "secretSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 48
        });
        Object.defineProperty(this, "encSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 97
        });
        Object.defineProperty(this, "publicKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 97
        });
        Object.defineProperty(this, "privateKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 48
        });
    }
}
class DhkemP521HkdfSha512Native extends _dhkem_js__WEBPACK_IMPORTED_MODULE_2__.Dhkem {
    constructor() {
        const kdf = new _kdfs_hkdf_js__WEBPACK_IMPORTED_MODULE_1__.HkdfSha512Native();
        const prim = new _dhkemPrimitives_ec_js__WEBPACK_IMPORTED_MODULE_3__.Ec(_identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP521HkdfSha512, kdf);
        super(_identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP521HkdfSha512, prim, kdf);
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _identifiers_js__WEBPACK_IMPORTED_MODULE_0__.KemId.DhkemP521HkdfSha512
        });
        Object.defineProperty(this, "secretSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 64
        });
        Object.defineProperty(this, "encSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 133
        });
        Object.defineProperty(this, "publicKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 133
        });
        Object.defineProperty(this, "privateKeySize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 64
        });
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/kems/dhkemPrimitives/ec.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Ec: () => (Ec)
});
/* ESM import */var _algorithm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/algorithm.js");
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _identifiers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/identifiers.js");
/* ESM import */var _interfaces_dhkemPrimitives_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/interfaces/dhkemPrimitives.js");
/* ESM import */var _utils_bignum_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/bignum.js");
/* ESM import */var _utils_misc_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/misc.js");







// b"candidate"
// deno-fmt-ignore
const LABEL_CANDIDATE = new Uint8Array([
    99, 97, 110, 100, 105, 100, 97, 116, 101,
]);
// the order of the curve being used.
// deno-fmt-ignore
const ORDER_P_256 = new Uint8Array([
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84,
    0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51,
]);
// deno-fmt-ignore
const ORDER_P_384 = new Uint8Array([
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
    0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a,
    0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73,
]);
// deno-fmt-ignore
const ORDER_P_521 = new Uint8Array([
    0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xfa, 0x51, 0x86, 0x87, 0x83, 0xbf, 0x2f,
    0x96, 0x6b, 0x7f, 0xcc, 0x01, 0x48, 0xf7, 0x09,
    0xa5, 0xd0, 0x3b, 0xb5, 0xc9, 0xb8, 0x89, 0x9c,
    0x47, 0xae, 0xbb, 0x6f, 0xb7, 0x1e, 0x91, 0x38,
    0x64, 0x09,
]);
// deno-fmt-ignore
const PKCS8_ALG_ID_P_256 = new Uint8Array([
    48, 65, 2, 1, 0, 48, 19, 6, 7, 42,
    134, 72, 206, 61, 2, 1, 6, 8, 42, 134,
    72, 206, 61, 3, 1, 7, 4, 39, 48, 37,
    2, 1, 1, 4, 32,
]);
// deno-fmt-ignore
const PKCS8_ALG_ID_P_384 = new Uint8Array([
    48, 78, 2, 1, 0, 48, 16, 6, 7, 42,
    134, 72, 206, 61, 2, 1, 6, 5, 43, 129,
    4, 0, 34, 4, 55, 48, 53, 2, 1, 1,
    4, 48,
]);
// deno-fmt-ignore
const PKCS8_ALG_ID_P_521 = new Uint8Array([
    48, 96, 2, 1, 0, 48, 16, 6, 7, 42,
    134, 72, 206, 61, 2, 1, 6, 5, 43, 129,
    4, 0, 35, 4, 73, 48, 71, 2, 1, 1,
    4, 66,
]);
class Ec extends _algorithm_js__WEBPACK_IMPORTED_MODULE_0__.NativeAlgorithm {
    constructor(kem, hkdf) {
        super();
        Object.defineProperty(this, "_hkdf", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_alg", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_nPk", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_nSk", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_nDh", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // EC specific arguments for deriving key pair.
        Object.defineProperty(this, "_order", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_bitmask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_pkcs8AlgId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._hkdf = hkdf;
        switch (kem) {
            case _identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KemId.DhkemP256HkdfSha256:
                this._alg = { name: "ECDH", namedCurve: "P-256" };
                this._nPk = 65;
                this._nSk = 32;
                this._nDh = 32;
                this._order = ORDER_P_256;
                this._bitmask = 0xFF;
                this._pkcs8AlgId = PKCS8_ALG_ID_P_256;
                break;
            case _identifiers_js__WEBPACK_IMPORTED_MODULE_3__.KemId.DhkemP384HkdfSha384:
                this._alg = { name: "ECDH", namedCurve: "P-384" };
                this._nPk = 97;
                this._nSk = 48;
                this._nDh = 48;
                this._order = ORDER_P_384;
                this._bitmask = 0xFF;
                this._pkcs8AlgId = PKCS8_ALG_ID_P_384;
                break;
            default:
                // case KemId.DhkemP521HkdfSha512:
                this._alg = { name: "ECDH", namedCurve: "P-521" };
                this._nPk = 133;
                this._nSk = 66;
                this._nDh = 66;
                this._order = ORDER_P_521;
                this._bitmask = 0x01;
                this._pkcs8AlgId = PKCS8_ALG_ID_P_521;
                break;
        }
    }
    async serializePublicKey(key) {
        await this._setup();
        try {
            return await this._api.exportKey("raw", key);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.SerializeError(e);
        }
    }
    async deserializePublicKey(key) {
        await this._setup();
        try {
            return await this._importRawKey(key, true);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.DeserializeError(e);
        }
    }
    async serializePrivateKey(key) {
        await this._setup();
        try {
            const jwk = await this._api.exportKey("jwk", key);
            if (!("d" in jwk)) {
                throw new Error("Not private key");
            }
            return (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_6__.base64UrlToBytes)(jwk["d"]);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.SerializeError(e);
        }
    }
    async deserializePrivateKey(key) {
        await this._setup();
        try {
            return await this._importRawKey(key, false);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.DeserializeError(e);
        }
    }
    async importKey(format, key, isPublic) {
        await this._setup();
        try {
            if (format === "raw") {
                return await this._importRawKey(key, isPublic);
            }
            // jwk
            if (key instanceof ArrayBuffer) {
                throw new Error("Invalid jwk key format");
            }
            return await this._importJWK(key, isPublic);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.DeserializeError(e);
        }
    }
    async generateKeyPair() {
        await this._setup();
        try {
            return await this._api.generateKey(this._alg, true, _interfaces_dhkemPrimitives_js__WEBPACK_IMPORTED_MODULE_4__.KEM_USAGES);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.NotSupportedError(e);
        }
    }
    async deriveKeyPair(ikm) {
        await this._setup();
        try {
            const dkpPrk = await this._hkdf.labeledExtract(_consts_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY, _interfaces_dhkemPrimitives_js__WEBPACK_IMPORTED_MODULE_4__.LABEL_DKP_PRK, new Uint8Array(ikm));
            const bn = new _utils_bignum_js__WEBPACK_IMPORTED_MODULE_5__.Bignum(this._nSk);
            for (let counter = 0; bn.isZero() || !bn.lessThan(this._order); counter++) {
                if (counter > 255) {
                    throw new Error("Faild to derive a key pair");
                }
                const bytes = new Uint8Array(await this._hkdf.labeledExpand(dkpPrk, LABEL_CANDIDATE, (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_6__.i2Osp)(counter, 1), this._nSk));
                bytes[0] = bytes[0] & this._bitmask;
                bn.set(bytes);
            }
            const sk = await this._deserializePkcs8Key(bn.val());
            bn.reset();
            return {
                privateKey: sk,
                publicKey: await this.derivePublicKey(sk),
            };
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.DeriveKeyPairError(e);
        }
    }
    async derivePublicKey(key) {
        await this._setup();
        try {
            const jwk = await this._api.exportKey("jwk", key);
            delete jwk["d"];
            delete jwk["key_ops"];
            return await this._api.importKey("jwk", jwk, this._alg, true, []);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.DeserializeError(e);
        }
    }
    async dh(sk, pk) {
        try {
            await this._setup();
            const bits = await this._api.deriveBits({
                name: "ECDH",
                public: pk,
            }, sk, this._nDh * 8);
            return bits;
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.SerializeError(e);
        }
    }
    async _importRawKey(key, isPublic) {
        if (isPublic && key.byteLength !== this._nPk) {
            throw new Error("Invalid public key for the ciphersuite");
        }
        if (!isPublic && key.byteLength !== this._nSk) {
            throw new Error("Invalid private key for the ciphersuite");
        }
        if (isPublic) {
            return await this._api.importKey("raw", key, this._alg, true, []);
        }
        return await this._deserializePkcs8Key(new Uint8Array(key));
    }
    async _importJWK(key, isPublic) {
        if (typeof key.crv === "undefined" || key.crv !== this._alg.namedCurve) {
            throw new Error(`Invalid crv: ${key.crv}`);
        }
        if (isPublic) {
            if (typeof key.d !== "undefined") {
                throw new Error("Invalid key: `d` should not be set");
            }
            return await this._api.importKey("jwk", key, this._alg, true, []);
        }
        if (typeof key.d === "undefined") {
            throw new Error("Invalid key: `d` not found");
        }
        return await this._api.importKey("jwk", key, this._alg, true, _interfaces_dhkemPrimitives_js__WEBPACK_IMPORTED_MODULE_4__.KEM_USAGES);
    }
    async _deserializePkcs8Key(k) {
        const pkcs8Key = new Uint8Array(this._pkcs8AlgId.length + k.length);
        pkcs8Key.set(this._pkcs8AlgId, 0);
        pkcs8Key.set(k, this._pkcs8AlgId.length);
        return await this._api.importKey("pkcs8", pkcs8Key, this._alg, true, _interfaces_dhkemPrimitives_js__WEBPACK_IMPORTED_MODULE_4__.KEM_USAGES);
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/recipientContext.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  RecipientContextImpl: () => (RecipientContextImpl)
});
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _encryptionContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/encryptionContext.js");



class RecipientContextImpl extends _encryptionContext_js__WEBPACK_IMPORTED_MODULE_2__.EncryptionContextImpl {
    async open(data, aad = _consts_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY) {
        let pt;
        try {
            pt = await this._ctx.key.open(this.computeNonce(this._ctx), data, aad);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.OpenError(e);
        }
        this.incrementSeq(this._ctx);
        return pt;
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/senderContext.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  SenderContextImpl: () => (SenderContextImpl)
});
/* ESM import */var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/consts.js");
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");
/* ESM import */var _encryptionContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/encryptionContext.js");



class SenderContextImpl extends _encryptionContext_js__WEBPACK_IMPORTED_MODULE_2__.EncryptionContextImpl {
    constructor(api, kdf, params, enc) {
        super(api, kdf, params);
        Object.defineProperty(this, "enc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.enc = enc;
    }
    async seal(data, aad = _consts_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY) {
        let ct;
        try {
            ct = await this._ctx.key.seal(this.computeNonce(this._ctx), data, aad);
        }
        catch (e) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.SealError(e);
        }
        this.incrementSeq(this._ctx);
        return ct;
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/bignum.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Bignum: () => (Bignum)
});
/**
 * The minimum inplementation of bignum to derive an EC key pair.
 */
class Bignum {
    constructor(size) {
        Object.defineProperty(this, "_num", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._num = new Uint8Array(size);
    }
    val() {
        return this._num;
    }
    reset() {
        this._num.fill(0);
    }
    set(src) {
        if (src.length !== this._num.length) {
            throw new Error("Bignum.set: invalid argument");
        }
        this._num.set(src);
    }
    isZero() {
        for (let i = 0; i < this._num.length; i++) {
            if (this._num[i] !== 0) {
                return false;
            }
        }
        return true;
    }
    lessThan(v) {
        if (v.length !== this._num.length) {
            throw new Error("Bignum.lessThan: invalid argument");
        }
        for (let i = 0; i < this._num.length; i++) {
            if (this._num[i] < v[i]) {
                return true;
            }
            if (this._num[i] > v[i]) {
                return false;
            }
        }
        return false;
    }
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/emitNotSupported.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  emitNotSupported: () => (emitNotSupported)
});
/* ESM import */var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/errors.js");

function emitNotSupported() {
    return new Promise((_resolve, reject) => {
        reject(new _errors_js__WEBPACK_IMPORTED_MODULE_0__.NotSupportedError("Not supported"));
    });
}


}),
"../../node_modules/@cubist-labs/cubesigner-sdk/node_modules/@hpke/core/esm/src/utils/misc.js": (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  base64UrlToBytes: () => (base64UrlToBytes),
  concat: () => (concat),
  i2Osp: () => (i2Osp),
  isCryptoKeyPair: () => (isCryptoKeyPair),
  isDeno: () => (isDeno)
});
/**
 * Checks whether the execution env is Deno or not.
 */
const isDeno = () => typeof Deno !== "undefined";
/**
 * Checks whetehr the type of input is CryptoKeyPair or not.
 */
const isCryptoKeyPair = (x) => typeof x === "object" &&
    x !== null &&
    typeof x.privateKey === "object" &&
    typeof x.publicKey === "object";
/**
 * Converts integer to octet string. I2OSP implementation.
 */
function i2Osp(n, w) {
    if (w <= 0) {
        throw new Error("i2Osp: too small size");
    }
    if (n >= 256 ** w) {
        throw new Error("i2Osp: too large integer");
    }
    const ret = new Uint8Array(w);
    for (let i = 0; i < w && n; i++) {
        ret[w - (i + 1)] = n % 256;
        n = n >> 8;
    }
    return ret;
}
/**
 * Concatenates two Uint8Arrays.
 */
function concat(a, b) {
    const ret = new Uint8Array(a.length + b.length);
    ret.set(a, 0);
    ret.set(b, a.length);
    return ret;
}
/**
 * Decodes Base64Url-encoded data.
 */
function base64UrlToBytes(v) {
    const base64 = v.replace(/-/g, "+").replace(/_/g, "/");
    const byteString = atob(base64);
    const ret = new Uint8Array(byteString.length);
    for (let i = 0; i < byteString.length; i++) {
        ret[i] = byteString.charCodeAt(i);
    }
    return ret;
}


}),

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianMvdmVuZG9ycy1ub2RlX21vZHVsZXNfY3ViaXN0LWxhYnNfY3ViZXNpZ25lci1zZGtfbm9kZV9tb2R1bGVzX2hwa2VfY29yZV9lc21fY29yZV9tb2RfanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AY29yZS1leHQvbmV4dC8uLi8uLi9ub2RlX21vZHVsZXMvQGN1YmlzdC1sYWJzL2N1YmVzaWduZXItc2RrL25vZGVfbW9kdWxlcy9AaHBrZS9jb3JlL2VzbS9fZG50LnNoaW1zLmpzIiwid2VicGFjazovL0Bjb3JlLWV4dC9uZXh0Ly4uLy4uL25vZGVfbW9kdWxlcy9AY3ViaXN0LWxhYnMvY3ViZXNpZ25lci1zZGsvbm9kZV9tb2R1bGVzL0BocGtlL2NvcmUvZXNtL2NvcmUvbW9kLmpzIiwid2VicGFjazovL0Bjb3JlLWV4dC9uZXh0Ly4uLy4uL25vZGVfbW9kdWxlcy9AY3ViaXN0LWxhYnMvY3ViZXNpZ25lci1zZGsvbm9kZV9tb2R1bGVzL0BocGtlL2NvcmUvZXNtL2NvcmUvc3JjL25hdGl2ZS5qcyIsIndlYnBhY2s6Ly9AY29yZS1leHQvbmV4dC8uLi8uLi9ub2RlX21vZHVsZXMvQGN1YmlzdC1sYWJzL2N1YmVzaWduZXItc2RrL25vZGVfbW9kdWxlcy9AaHBrZS9jb3JlL2VzbS9zcmMvYWVhZHMvYWVzR2NtLmpzIiwid2VicGFjazovL0Bjb3JlLWV4dC9uZXh0Ly4uLy4uL25vZGVfbW9kdWxlcy9AY3ViaXN0LWxhYnMvY3ViZXNpZ25lci1zZGsvbm9kZV9tb2R1bGVzL0BocGtlL2NvcmUvZXNtL3NyYy9hZWFkcy9leHBvcnRPbmx5LmpzIiwid2VicGFjazovL0Bjb3JlLWV4dC9uZXh0Ly4uLy4uL25vZGVfbW9kdWxlcy9AY3ViaXN0LWxhYnMvY3ViZXNpZ25lci1zZGsvbm9kZV9tb2R1bGVzL0BocGtlL2NvcmUvZXNtL3NyYy9hbGdvcml0aG0uanMiLCJ3ZWJwYWNrOi8vQGNvcmUtZXh0L25leHQvLi4vLi4vbm9kZV9tb2R1bGVzL0BjdWJpc3QtbGFicy9jdWJlc2lnbmVyLXNkay9ub2RlX21vZHVsZXMvQGhwa2UvY29yZS9lc20vc3JjL2NpcGhlclN1aXRlTmF0aXZlLmpzIiwid2VicGFjazovL0Bjb3JlLWV4dC9uZXh0Ly4uLy4uL25vZGVfbW9kdWxlcy9AY3ViaXN0LWxhYnMvY3ViZXNpZ25lci1zZGsvbm9kZV9tb2R1bGVzL0BocGtlL2NvcmUvZXNtL3NyYy9jb25zdHMuanMiLCJ3ZWJwYWNrOi8vQGNvcmUtZXh0L25leHQvLi4vLi4vbm9kZV9tb2R1bGVzL0BjdWJpc3QtbGFicy9jdWJlc2lnbmVyLXNkay9ub2RlX21vZHVsZXMvQGhwa2UvY29yZS9lc20vc3JjL2VuY3J5cHRpb25Db250ZXh0LmpzIiwid2VicGFjazovL0Bjb3JlLWV4dC9uZXh0Ly4uLy4uL25vZGVfbW9kdWxlcy9AY3ViaXN0LWxhYnMvY3ViZXNpZ25lci1zZGsvbm9kZV9tb2R1bGVzL0BocGtlL2NvcmUvZXNtL3NyYy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vQGNvcmUtZXh0L25leHQvLi4vLi4vbm9kZV9tb2R1bGVzL0BjdWJpc3QtbGFicy9jdWJlc2lnbmVyLXNkay9ub2RlX21vZHVsZXMvQGhwa2UvY29yZS9lc20vc3JjL2V4cG9ydGVyQ29udGV4dC5qcyIsIndlYnBhY2s6Ly9AY29yZS1leHQvbmV4dC8uLi8uLi9ub2RlX21vZHVsZXMvQGN1YmlzdC1sYWJzL2N1YmVzaWduZXItc2RrL25vZGVfbW9kdWxlcy9AaHBrZS9jb3JlL2VzbS9zcmMvaWRlbnRpZmllcnMuanMiLCJ3ZWJwYWNrOi8vQGNvcmUtZXh0L25leHQvLi4vLi4vbm9kZV9tb2R1bGVzL0BjdWJpc3QtbGFicy9jdWJlc2lnbmVyLXNkay9ub2RlX21vZHVsZXMvQGhwa2UvY29yZS9lc20vc3JjL2ludGVyZmFjZXMvYWVhZEVuY3J5cHRpb25Db250ZXh0LmpzIiwid2VicGFjazovL0Bjb3JlLWV4dC9uZXh0Ly4uLy4uL25vZGVfbW9kdWxlcy9AY3ViaXN0LWxhYnMvY3ViZXNpZ25lci1zZGsvbm9kZV9tb2R1bGVzL0BocGtlL2NvcmUvZXNtL3NyYy9pbnRlcmZhY2VzL2Roa2VtUHJpbWl0aXZlcy5qcyIsIndlYnBhY2s6Ly9AY29yZS1leHQvbmV4dC8uLi8uLi9ub2RlX21vZHVsZXMvQGN1YmlzdC1sYWJzL2N1YmVzaWduZXItc2RrL25vZGVfbW9kdWxlcy9AaHBrZS9jb3JlL2VzbS9zcmMvaW50ZXJmYWNlcy9rZW1JbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vQGNvcmUtZXh0L25leHQvLi4vLi4vbm9kZV9tb2R1bGVzL0BjdWJpc3QtbGFicy9jdWJlc2lnbmVyLXNkay9ub2RlX21vZHVsZXMvQGhwa2UvY29yZS9lc20vc3JjL2tkZnMvaGtkZi5qcyIsIndlYnBhY2s6Ly9AY29yZS1leHQvbmV4dC8uLi8uLi9ub2RlX21vZHVsZXMvQGN1YmlzdC1sYWJzL2N1YmVzaWduZXItc2RrL25vZGVfbW9kdWxlcy9AaHBrZS9jb3JlL2VzbS9zcmMva2Vtcy9kaGtlbS5qcyIsIndlYnBhY2s6Ly9AY29yZS1leHQvbmV4dC8uLi8uLi9ub2RlX21vZHVsZXMvQGN1YmlzdC1sYWJzL2N1YmVzaWduZXItc2RrL25vZGVfbW9kdWxlcy9AaHBrZS9jb3JlL2VzbS9zcmMva2Vtcy9kaGtlbU5hdGl2ZS5qcyIsIndlYnBhY2s6Ly9AY29yZS1leHQvbmV4dC8uLi8uLi9ub2RlX21vZHVsZXMvQGN1YmlzdC1sYWJzL2N1YmVzaWduZXItc2RrL25vZGVfbW9kdWxlcy9AaHBrZS9jb3JlL2VzbS9zcmMva2Vtcy9kaGtlbVByaW1pdGl2ZXMvZWMuanMiLCJ3ZWJwYWNrOi8vQGNvcmUtZXh0L25leHQvLi4vLi4vbm9kZV9tb2R1bGVzL0BjdWJpc3QtbGFicy9jdWJlc2lnbmVyLXNkay9ub2RlX21vZHVsZXMvQGhwa2UvY29yZS9lc20vc3JjL3JlY2lwaWVudENvbnRleHQuanMiLCJ3ZWJwYWNrOi8vQGNvcmUtZXh0L25leHQvLi4vLi4vbm9kZV9tb2R1bGVzL0BjdWJpc3QtbGFicy9jdWJlc2lnbmVyLXNkay9ub2RlX21vZHVsZXMvQGhwa2UvY29yZS9lc20vc3JjL3NlbmRlckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vQGNvcmUtZXh0L25leHQvLi4vLi4vbm9kZV9tb2R1bGVzL0BjdWJpc3QtbGFicy9jdWJlc2lnbmVyLXNkay9ub2RlX21vZHVsZXMvQGhwa2UvY29yZS9lc20vc3JjL3V0aWxzL2JpZ251bS5qcyIsIndlYnBhY2s6Ly9AY29yZS1leHQvbmV4dC8uLi8uLi9ub2RlX21vZHVsZXMvQGN1YmlzdC1sYWJzL2N1YmVzaWduZXItc2RrL25vZGVfbW9kdWxlcy9AaHBrZS9jb3JlL2VzbS9zcmMvdXRpbHMvZW1pdE5vdFN1cHBvcnRlZC5qcyIsIndlYnBhY2s6Ly9AY29yZS1leHQvbmV4dC8uLi8uLi9ub2RlX21vZHVsZXMvQGN1YmlzdC1sYWJzL2N1YmVzaWduZXItc2RrL25vZGVfbW9kdWxlcy9AaHBrZS9jb3JlL2VzbS9zcmMvdXRpbHMvbWlzYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkbnRHbG9iYWxzID0ge307XG5leHBvcnQgY29uc3QgZG50R2xvYmFsVGhpcyA9IGNyZWF0ZU1lcmdlUHJveHkoZ2xvYmFsVGhpcywgZG50R2xvYmFscyk7XG5mdW5jdGlvbiBjcmVhdGVNZXJnZVByb3h5KGJhc2VPYmosIGV4dE9iaikge1xuICAgIHJldHVybiBuZXcgUHJveHkoYmFzZU9iaiwge1xuICAgICAgICBnZXQoX3RhcmdldCwgcHJvcCwgX3JlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiBleHRPYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0T2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VPYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldChfdGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gZXh0T2JqKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGV4dE9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2VPYmpbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBkZWxldGVQcm9wZXJ0eShfdGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gZXh0T2JqKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGV4dE9ialtwcm9wXTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wIGluIGJhc2VPYmopIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgYmFzZU9ialtwcm9wXTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgICB9LFxuICAgICAgICBvd25LZXlzKF90YXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VLZXlzID0gUmVmbGVjdC5vd25LZXlzKGJhc2VPYmopO1xuICAgICAgICAgICAgY29uc3QgZXh0S2V5cyA9IFJlZmxlY3Qub3duS2V5cyhleHRPYmopO1xuICAgICAgICAgICAgY29uc3QgZXh0S2V5c1NldCA9IG5ldyBTZXQoZXh0S2V5cyk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmJhc2VLZXlzLmZpbHRlcigoaykgPT4gIWV4dEtleXNTZXQuaGFzKGspKSwgLi4uZXh0S2V5c107XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmluZVByb3BlcnR5KF90YXJnZXQsIHByb3AsIGRlc2MpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIGV4dE9iaikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBleHRPYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGJhc2VPYmosIHByb3AsIGRlc2MpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihfdGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiBleHRPYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZXh0T2JqLCBwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlT2JqLCBwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGFzKF90YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wIGluIGV4dE9iaiB8fCBwcm9wIGluIGJhc2VPYmo7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4iLCJleHBvcnQgeyBBZXMxMjhHY20sIEFlczI1NkdjbSB9IGZyb20gXCIuLi9zcmMvYWVhZHMvYWVzR2NtLmpzXCI7XG5leHBvcnQgeyBFeHBvcnRPbmx5IH0gZnJvbSBcIi4uL3NyYy9hZWFkcy9leHBvcnRPbmx5LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi4vc3JjL2Vycm9ycy5qc1wiO1xuZXhwb3J0IHsgQWVhZElkLCBLZGZJZCwgS2VtSWQgfSBmcm9tIFwiLi4vc3JjL2lkZW50aWZpZXJzLmpzXCI7XG5leHBvcnQgeyBDaXBoZXJTdWl0ZSwgRGhrZW1QMjU2SGtkZlNoYTI1NiwgRGhrZW1QMzg0SGtkZlNoYTM4NCwgRGhrZW1QNTIxSGtkZlNoYTUxMiwgSGtkZlNoYTI1NiwgSGtkZlNoYTM4NCwgSGtkZlNoYTUxMiwgfSBmcm9tIFwiLi9zcmMvbmF0aXZlLmpzXCI7XG4iLCJpbXBvcnQgeyBDaXBoZXJTdWl0ZU5hdGl2ZSB9IGZyb20gXCIuLi8uLi9zcmMvY2lwaGVyU3VpdGVOYXRpdmUuanNcIjtcbmltcG9ydCB7IEhrZGZTaGEyNTZOYXRpdmUsIEhrZGZTaGEzODROYXRpdmUsIEhrZGZTaGE1MTJOYXRpdmUsIH0gZnJvbSBcIi4uLy4uL3NyYy9rZGZzL2hrZGYuanNcIjtcbmltcG9ydCB7IERoa2VtUDI1NkhrZGZTaGEyNTZOYXRpdmUsIERoa2VtUDM4NEhrZGZTaGEzODROYXRpdmUsIERoa2VtUDUyMUhrZGZTaGE1MTJOYXRpdmUsIH0gZnJvbSBcIi4uLy4uL3NyYy9rZW1zL2Roa2VtTmF0aXZlLmpzXCI7XG4vKipcbiAqIFRoZSBIeWJyaWQgUHVibGljIEtleSBFbmNyeXB0aW9uIChIUEtFKSBjaXBoZXJzdWl0ZSxcbiAqIHdoaWNoIGlzIGltcGxlbWVudGVkIHVzaW5nIG9ubHlcbiAqIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvV2ViQ3J5cHRvQVBJLyB8IFdlYiBDcnlwdG9ncmFwaHkgQVBJfS5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIHRoZSBzYW1lIGFzXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZW5vLmxhbmQveC9ocGtlL21vZC50cz9zPUNpcGhlclN1aXRlTmF0aXZlIHwgQGhwa2UvY29yZSNDaXBoZXJTdWl0ZU5hdGl2ZSB9LFxuICogd2hpY2ggc3VwcG9ydHMgb25seSB0aGUgY2lwaGVyc3VpdGVzIHRoYXQgY2FuIGJlIGltcGxlbWVudGVkIG9uIHRoZSBuYXRpdmVcbiAqIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvV2ViQ3J5cHRvQVBJLyB8IFdlYiBDcnlwdG9ncmFwaHkgQVBJfS5cbiAqIFRoZXJlZm9yZSwgdGhlIGZvbGxvd2luZyBjcnlwdG9ncmFwaGljIGFsZ29yaXRobXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG5vdzpcbiAqIC0gYERIS0VNKFgyNTUxOSwgSEtERi1TSEEyNTYpYFxuICogLSBgREhLRU0oWDQ0OCwgSEtERi1TSEE1MTIpYFxuICogLSBgQ2hhQ2hhMjBQb2x5MTMwNWBcbiAqXG4gKiBJbiBhZGR0aW9uLCB0aGUgSEtERiBmdW5jdGlvbnMgY29udGFpbmVkIGluIHRoaXMgYENpcGhlclN1aXRlTmF0aXZlYFxuICogY2xhc3MgY2FuIG9ubHkgZGVyaXZlIGtleXMgb2YgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBgaGFzaFNpemVgLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSB0aGUgdW5zdXBwb3J0ZWQgY3J5cHRvZ3JhcGhpYyBhbGdvcml0aG1zXG4gKiBhYm92ZSBvciBkZXJpdmUga2V5cyBsb25nZXIgdGhhbiB0aGUgYGhhc2hTaXplYCxcbiAqIHBsZWFzZSB1c2Uge0BsaW5rIGh0dHBzOi8vZGVuby5sYW5kL3gvaHBrZS9tb2QudHM/cz1DaXBoZXJTdWl0ZSB8IGhwa2UtanMjQ2lwaGVyU3VpdGV9LlxuICpcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgZm9sbG93aW5nIGZ1bmN0aW9uczpcbiAqXG4gKiAtIENyZWF0ZXMgZW5jcnlwdGlvbiBjb250ZXh0cyBib3RoIGZvciBzZW5kZXJzIGFuZCByZWNpcGllbnRzLlxuICogICAgIC0ge0BsaW5rIGNyZWF0ZVNlbmRlckNvbnRleHR9XG4gKiAgICAgLSB7QGxpbmsgY3JlYXRlUmVjaXBpZW50Q29udGV4dH1cbiAqIC0gUHJvdmlkZXMgc2luZ2xlLXNob3QgZW5jcnlwdGlvbiBBUEkuXG4gKiAgICAgLSB7QGxpbmsgc2VhbH1cbiAqICAgICAtIHtAbGluayBvcGVufVxuICpcbiAqIFRoZSBjYWxsaW5nIG9mIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGlzIGNsYXNzIGlzIHRoZSBzdGFydGluZ1xuICogcG9pbnQgZm9yIEhQS0Ugb3BlcmF0aW9ucyBmb3IgYm90aCBzZW5kZXJzIGFuZCByZWNpcGllbnRzLlxuICpcbiAqIEBleGFtcGxlIFVzZSBvbmx5IGNpcGhlcnN1aXRlcyBzdXBwb3J0ZWQgYnkgV2ViIENyeXB0b2dyYXBoeSBBUEkuXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7XG4gKiAgIEFlczEyOEdjbSxcbiAqICAgRGhrZW1QMjU2SGtkZlNoYTI1NixcbiAqICAgSGtkZlNoYTI1NixcbiAqICAgQ2lwaGVyU3VpdGUsXG4gKiB9IGZyb20gXCJodHRwOi8vZGVuby5sYW5kL3gvaHBrZS9jb3JlL21vZC50c1wiO1xuICpcbiAqIGNvbnN0IHN1aXRlID0gbmV3IENpcGhlclN1aXRlKHtcbiAqICAga2VtOiBuZXcgRGhrZW1QMjU2SGtkZlNoYTI1NigpLFxuICogICBrZGY6IG5ldyBIa2RmU2hhMjU2KCksXG4gKiAgIGFlYWQ6IG5ldyBBZXMxMjhHY20oKSxcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGUgVXNlIGEgY2lwaGVyc3VpdGUgd2hpY2ggaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgYnkgV2ViIENyeXB0b2dyYXBoeSBBUEkuXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFlczEyOEdjbSwgSGtkZlNoYTI1NiwgQ2lwaGVyU3VpdGUgfSBmcm9tIFwiaHR0cDovL2Rlbm8ubGFuZC94L2hwa2UvY29yZS9tb2QudHNcIjtcbiAqIGltcG9ydCB7IERoa2VtWDI1NTE5SGtkZlNoYTI1NiB9IGZyb20gXCJodHRwczovL2Rlbm8ubGFuZC94L2hwa2UveC9kaGtlbS14MjU1MTkvbW9kLnRzXCI7XG4gKiBjb25zdCBzdWl0ZSA9IG5ldyBDaXBoZXJTdWl0ZSh7XG4gKiAgIGtlbTogbmV3IERoa2VtWDI1NTE5SGtkZlNoYTI1NigpLFxuICogICBrZGY6IG5ldyBIa2RmU2hhMjU2KCksXG4gKiAgIGFlYWQ6IG5ldyBBZXMxMjhHY20oKSxcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDaXBoZXJTdWl0ZSBleHRlbmRzIENpcGhlclN1aXRlTmF0aXZlIHtcbn1cbi8qKlxuICogVGhlIERIS0VNKFAtMjU2LCBIS0RGLVNIQTI1NikgZm9yIEhQS0UgS0VNIGltcGxlbWVudGluZyB7QGxpbmsgS2VtSW50ZXJmYWNlfS5cbiAqXG4gKiBXaGVuIHVzaW5nIGBAaHBrZS9jb3JlYCwgdGhlIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgbXVzdCBiZSBzcGVjaWZpZWRcbiAqIHRvIHRoZSBga2VtYCBwYXJhbWV0ZXIgb2Yge0BsaW5rIENpcGhlclN1aXRlUGFyYW1zfSBpbnN0ZWFkIG9mIGBLZW1JZC5EaGtlbVAyNTZIa2RmU2hhMjU2YFxuICogYXMgZm9sbG93czpcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge1xuICogICBBZXMxMjhHY20sXG4gKiAgIENpcGhlclN1aXRlLFxuICogICBEaGtlbVAyNTZIa2RmU2hhMjU2LFxuICogICBIa2RmU2hhMjU2LFxuICogfSBmcm9tIFwiaHR0cDovL2Rlbm8ubGFuZC94L2hwa2UvY29yZS9tb2QudHNcIjtcbiAqXG4gKiBjb25zdCBzdWl0ZSA9IG5ldyBDaXBoZXJTdWl0ZSh7XG4gKiAgIGtlbTogbmV3IERoa2VtUDI1NkhrZGZTaGEyNTYoKSxcbiAqICAga2RmOiBuZXcgSGtkZlNoYTI1NigpLFxuICogICBhZWFkOiBuZXcgQWVzMTI4R2NtKCksXG4gKiB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgRGhrZW1QMjU2SGtkZlNoYTI1NiBleHRlbmRzIERoa2VtUDI1NkhrZGZTaGEyNTZOYXRpdmUge1xufVxuLyoqXG4gKiBUaGUgREhLRU0oUC0zODQsIEhLREYtU0hBMzg0KSBmb3IgSFBLRSBLRU0gaW1wbGVtZW50aW5nIHtAbGluayBLZW1JbnRlcmZhY2V9LlxuICpcbiAqIFdoZW4gdXNpbmcgYEBocGtlL2NvcmVgLCB0aGUgaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBtdXN0IGJlIHNwZWNpZmllZFxuICogdG8gdGhlIGBrZW1gIHBhcmFtZXRlciBvZiB7QGxpbmsgQ2lwaGVyU3VpdGVQYXJhbXN9IGluc3RlYWQgb2YgYEtlbUlkLkRoa2VtUDM4NEhrZGZTaGEzODRgXG4gKiBhcyBmb2xsb3dzOlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7XG4gKiAgIEFlczEyOEdjbSxcbiAqICAgQ2lwaGVyU3VpdGUsXG4gKiAgIERoa2VtUDM4NEhrZGZTaGEzODQsXG4gKiAgIEhrZGZTaGEzODQsXG4gKiB9IGZyb20gXCJodHRwOi8vZGVuby5sYW5kL3gvaHBrZS9jb3JlL21vZC50c1wiO1xuICpcbiAqIGNvbnN0IHN1aXRlID0gbmV3IENpcGhlclN1aXRlKHtcbiAqICAga2VtOiBuZXcgRGhrZW1QMzg0SGtkZlNoYTM4NCgpLFxuICogICBrZGY6IG5ldyBIa2RmU2hhMzg0KCksXG4gKiAgIGFlYWQ6IG5ldyBBZXMxMjhHY20oKSxcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBEaGtlbVAzODRIa2RmU2hhMzg0IGV4dGVuZHMgRGhrZW1QMzg0SGtkZlNoYTM4NE5hdGl2ZSB7XG59XG4vKipcbiAqIFRoZSBESEtFTShQLTUyMSwgSEtERi1TSEE1MTIpIGZvciBIUEtFIEtFTSBpbXBsZW1lbnRpbmcge0BsaW5rIEtlbUludGVyZmFjZX0uXG4gKlxuICogV2hlbiB1c2luZyBgQGhwa2UvY29yZWAsIHRoZSBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIG11c3QgYmUgc3BlY2lmaWVkXG4gKiB0byB0aGUgYGtlbWAgcGFyYW1ldGVyIG9mIHtAbGluayBDaXBoZXJTdWl0ZVBhcmFtc30gaW5zdGVhZCBvZiBgS2VtSWQuRGhrZW1QNTIxSGtkZlNoYTUxMmBcbiAqIGFzIGZvbGxvd3M6XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHtcbiAqICAgQWVzMjU2R2NtLFxuICogICBDaXBoZXJTdWl0ZSxcbiAqICAgRGhrZW1QNTIxSGtkZlNoYTUxMixcbiAqICAgSGtkZlNoYTUxMixcbiAqIH0gZnJvbSBcImh0dHA6Ly9kZW5vLmxhbmQveC9ocGtlL2NvcmUvbW9kLnRzXCI7XG4gKlxuICogY29uc3Qgc3VpdGUgPSBuZXcgQ2lwaGVyU3VpdGUoe1xuICogICBrZW06IG5ldyBEaGtlbVA1MjFIa2RmU2hhNTEyKCksXG4gKiAgIGtkZjogbmV3IEhrZGZTaGE1MTIoKSxcbiAqICAgYWVhZDogbmV3IEFlczI1NkdjbSgpLFxuICogfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIERoa2VtUDUyMUhrZGZTaGE1MTIgZXh0ZW5kcyBEaGtlbVA1MjFIa2RmU2hhNTEyTmF0aXZlIHtcbn1cbi8qKlxuICogVGhlIEhLREYtU0hBMjU2IGZvciBIUEtFIEtERiBpbXBsZW1lbnRpbmcge0BsaW5rIEtkZkludGVyZmFjZX0uXG4gKlxuICogV2hlbiB1c2luZyBgQGhwa2UvY29yZWAsIHRoZSBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIG11c3QgYmUgc3BlY2lmaWVkXG4gKiB0byB0aGUgYGtlbWAgcGFyYW1ldGVyIG9mIHtAbGluayBDaXBoZXJTdWl0ZVBhcmFtc30gaW5zdGVhZCBvZiBgS2RmSWQuSGtkZlNoYTI1NmAuXG4gKlxuICogVGhlIEtERiBjbGFzcyBjYW4gb25seSBkZXJpdmUga2V5cyBvZiB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIGBoYXNoU2l6ZWAuXG4gKiBJZiB5b3Ugd2FudCB0byBkZXJpdmUga2V5cyBsb25nZXIgdGhhbiB0aGUgYGhhc2hTaXplYCxcbiAqIHBsZWFzZSB1c2Uge0BsaW5rIGh0dHBzOi8vZGVuby5sYW5kL3gvaHBrZS9tb2QudHM/cz1DaXBoZXJTdWl0ZSB8IGhwa2UtanMjQ2lwaGVyU3VpdGV9LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7XG4gKiAgIEFlczEyOEdjbSxcbiAqICAgQ2lwaGVyU3VpdGUsXG4gKiAgIERoa2VtUDI1NkhrZGZTaGEyNTYsXG4gKiAgIEhrZGZTaGEyNTYsXG4gKiB9IGZyb20gXCJodHRwOi8vZGVuby5sYW5kL3gvaHBrZS9jb3JlL21vZC50c1wiO1xuICpcbiAqIGNvbnN0IHN1aXRlID0gbmV3IENpcGhlclN1aXRlKHtcbiAqICAga2VtOiBuZXcgRGhrZW1QMjU2SGtkZlNoYTI1NigpLFxuICogICBrZGY6IG5ldyBIa2RmU2hhMjU2KCksXG4gKiAgIGFlYWQ6IG5ldyBBZXMxMjhHY20oKSxcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBIa2RmU2hhMjU2IGV4dGVuZHMgSGtkZlNoYTI1Nk5hdGl2ZSB7XG59XG4vKipcbiAqIFRoZSBIS0RGLVNIQTM4NCBmb3IgSFBLRSBLREYgaW1wbGVtZW50aW5nIHtAbGluayBLZGZJbnRlcmZhY2V9LlxuICpcbiAqIFdoZW4gdXNpbmcgYEBocGtlL2NvcmVgLCB0aGUgaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBtdXN0IGJlIHNwZWNpZmllZFxuICogdG8gdGhlIGBrZW1gIHBhcmFtZXRlciBvZiB7QGxpbmsgQ2lwaGVyU3VpdGVQYXJhbXN9IGluc3RlYWQgb2YgYEtkZklkLkhrZGZTaGEzODRgLlxuICpcbiAqIFRoZSBLREYgY2xhc3MgY2FuIG9ubHkgZGVyaXZlIGtleXMgb2YgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBgaGFzaFNpemVgLlxuICogSWYgeW91IHdhbnQgdG8gZGVyaXZlIGtleXMgbG9uZ2VyIHRoYW4gdGhlIGBoYXNoU2l6ZWAsXG4gKiBwbGVhc2UgdXNlIHtAbGluayBodHRwczovL2Rlbm8ubGFuZC94L2hwa2UvbW9kLnRzP3M9Q2lwaGVyU3VpdGUgfCBocGtlLWpzI0NpcGhlclN1aXRlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge1xuICogICBBZXMxMjhHY20sXG4gKiAgIENpcGhlclN1aXRlLFxuICogICBEaGtlbVAzODRIa2RmU2hhMzg0LFxuICogICBIa2RmU2hhMzg0LFxuICogfSBmcm9tIFwiaHR0cDovL2Rlbm8ubGFuZC94L2hwa2UvY29yZS9tb2QudHNcIjtcbiAqXG4gKiBjb25zdCBzdWl0ZSA9IG5ldyBDaXBoZXJTdWl0ZSh7XG4gKiAgIGtlbTogbmV3IERoa2VtUDM4NEhrZGZTaGEzODQoKSxcbiAqICAga2RmOiBuZXcgSGtkZlNoYTM4NCgpLFxuICogICBhZWFkOiBuZXcgQWVzMTI4R2NtKCksXG4gKiB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSGtkZlNoYTM4NCBleHRlbmRzIEhrZGZTaGEzODROYXRpdmUge1xufVxuLyoqXG4gKiBUaGUgSEtERi1TSEE1MTIgZm9yIEhQS0UgS0RGIGltcGxlbWVudGluZyB7QGxpbmsgS2RmSW50ZXJmYWNlfS5cbiAqXG4gKiBXaGVuIHVzaW5nIGBAaHBrZS9jb3JlYCwgdGhlIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgbXVzdCBiZSBzcGVjaWZpZWRcbiAqIHRvIHRoZSBga2VtYCBwYXJhbWV0ZXIgb2Yge0BsaW5rIENpcGhlclN1aXRlUGFyYW1zfSBpbnN0ZWFkIG9mIGBLZGZJZC5Ia2RmU2hhNTEyYC5cbiAqXG4gKiBUaGUgS0RGIGNsYXNzIGNhbiBvbmx5IGRlcml2ZSBrZXlzIG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgYGhhc2hTaXplYC5cbiAqIElmIHlvdSB3YW50IHRvIGRlcml2ZSBrZXlzIGxvbmdlciB0aGFuIHRoZSBgaGFzaFNpemVgLFxuICogcGxlYXNlIHVzZSB7QGxpbmsgaHR0cHM6Ly9kZW5vLmxhbmQveC9ocGtlL21vZC50cz9zPUNpcGhlclN1aXRlIHwgaHBrZS1qcyNDaXBoZXJTdWl0ZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHtcbiAqICAgQWVzMjU2R2NtLFxuICogICBDaXBoZXJTdWl0ZSxcbiAqICAgRGhrZW1QNTIxSGtkZlNoYTUxMixcbiAqICAgSGtkZlNoYTUxMixcbiAqIH0gZnJvbSBcImh0dHA6Ly9kZW5vLmxhbmQveC9ocGtlL2NvcmUvbW9kLnRzXCI7XG4gKlxuICogY29uc3Qgc3VpdGUgPSBuZXcgQ2lwaGVyU3VpdGUoe1xuICogICBrZW06IG5ldyBEaGtlbVA1MjFIa2RmU2hhNTEyKCksXG4gKiAgIGtkZjogbmV3IEhrZGZTaGE1MTIoKSxcbiAqICAgYWVhZDogbmV3IEFlczI1NkdjbSgpLFxuICogfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEhrZGZTaGE1MTIgZXh0ZW5kcyBIa2RmU2hhNTEyTmF0aXZlIHtcbn1cbiIsImltcG9ydCB7IE5hdGl2ZUFsZ29yaXRobSB9IGZyb20gXCIuLi9hbGdvcml0aG0uanNcIjtcbmltcG9ydCB7IEFlYWRJZCB9IGZyb20gXCIuLi9pZGVudGlmaWVycy5qc1wiO1xuaW1wb3J0IHsgQUVBRF9VU0FHRVMgfSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9hZWFkRW5jcnlwdGlvbkNvbnRleHQuanNcIjtcbmV4cG9ydCBjbGFzcyBBZXNHY21Db250ZXh0IGV4dGVuZHMgTmF0aXZlQWxnb3JpdGhtIHtcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Jhd0tleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfa2V5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Jhd0tleSA9IGtleTtcbiAgICB9XG4gICAgYXN5bmMgc2VhbChpdiwgZGF0YSwgYWFkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwS2V5KCk7XG4gICAgICAgIGNvbnN0IGFsZyA9IHtcbiAgICAgICAgICAgIG5hbWU6IFwiQUVTLUdDTVwiLFxuICAgICAgICAgICAgaXY6IGl2LFxuICAgICAgICAgICAgYWRkaXRpb25hbERhdGE6IGFhZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY3QgPSBhd2FpdCB0aGlzLl9hcGkuZW5jcnlwdChhbGcsIHRoaXMuX2tleSwgZGF0YSk7XG4gICAgICAgIHJldHVybiBjdDtcbiAgICB9XG4gICAgYXN5bmMgb3BlbihpdiwgZGF0YSwgYWFkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwS2V5KCk7XG4gICAgICAgIGNvbnN0IGFsZyA9IHtcbiAgICAgICAgICAgIG5hbWU6IFwiQUVTLUdDTVwiLFxuICAgICAgICAgICAgaXY6IGl2LFxuICAgICAgICAgICAgYWRkaXRpb25hbERhdGE6IGFhZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHQgPSBhd2FpdCB0aGlzLl9hcGkuZGVjcnlwdChhbGcsIHRoaXMuX2tleSwgZGF0YSk7XG4gICAgICAgIHJldHVybiBwdDtcbiAgICB9XG4gICAgYXN5bmMgX3NldHVwS2V5KCkge1xuICAgICAgICBpZiAodGhpcy5fa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cCgpO1xuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCB0aGlzLl9pbXBvcnRLZXkodGhpcy5fcmF3S2V5KTtcbiAgICAgICAgKG5ldyBVaW50OEFycmF5KHRoaXMuX3Jhd0tleSkpLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3luYyBfaW1wb3J0S2V5KGtleSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYXBpLmltcG9ydEtleShcInJhd1wiLCBrZXksIHsgbmFtZTogXCJBRVMtR0NNXCIgfSwgdHJ1ZSwgQUVBRF9VU0FHRVMpO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIEFFUy0xMjgtR0NNIGZvciBIUEtFIEFFQUQgaW1wbGVtZW50aW5nIHtAbGluayBBZWFkSW50ZXJmYWNlfS5cbiAqXG4gKiBXaGVuIHVzaW5nIGBAaHBrZS9jb3JlYCwgdGhlIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgbXVzdCBiZSBzcGVjaWZpZWRcbiAqIHRvIHRoZSBgYWVhZGAgcGFyYW1ldGVyIG9mIHtAbGluayBDaXBoZXJTdWl0ZVBhcmFtc30gaW5zdGVhZCBvZiBgQWVhZElkLkFlczEyOEdjbWAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHtcbiAqICAgQWVzMTI4R2NtLFxuICogICBDaXBoZXJTdWl0ZSxcbiAqICAgRGhrZW1QMjU2SGtkZlNoYTI1NixcbiAqICAgSGtkZlNoYTI1NixcbiAqIH0gZnJvbSBcImh0dHA6Ly9kZW5vLmxhbmQveC9ocGtlL2NvcmUvbW9kLnRzXCI7XG4gKlxuICogY29uc3Qgc3VpdGUgPSBuZXcgQ2lwaGVyU3VpdGUoe1xuICogICBrZW06IG5ldyBEaGtlbVAyNTZIa2RmU2hhMjU2KCksXG4gKiAgIGtkZjogbmV3IEhrZGZTaGEyNTYoKSxcbiAqICAgYWVhZDogbmV3IEFlczEyOEdjbSgpLFxuICogfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEFlczEyOEdjbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKiBBZWFkSWQuQWVzMTI4R2NtICgweDAwMDEpICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBBZWFkSWQuQWVzMTI4R2NtXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogMTYgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5U2l6ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMTZcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiAxMiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub25jZVNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDEyXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogMTYgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnU2l6ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMTZcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUVuY3J5cHRpb25Db250ZXh0KGtleSkge1xuICAgICAgICByZXR1cm4gbmV3IEFlc0djbUNvbnRleHQoa2V5KTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBBRVMtMjU2LUdDTSBmb3IgSFBLRSBBRUFEIGltcGxlbWVudGluZyB7QGxpbmsgQWVhZEludGVyZmFjZX0uXG4gKlxuICogV2hlbiB1c2luZyBgQGhwa2UvY29yZWAsIHRoZSBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIG11c3QgYmUgc3BlY2lmaWVkXG4gKiB0byB0aGUgYGFlYWRgIHBhcmFtZXRlciBvZiB7QGxpbmsgQ2lwaGVyU3VpdGVQYXJhbXN9IGluc3RlYWQgb2YgYEFlYWRJZC5BZXMyNTZHY21gXG4gKiBhcyBmb2xsb3dzOlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7XG4gKiAgIEFlczI1NkdjbSxcbiAqICAgQ2lwaGVyU3VpdGUsXG4gKiAgIERoa2VtUDI1NkhrZGZTaGEyNTYsXG4gKiAgIEhrZGZTaGEyNTYsXG4gKiB9IGZyb20gXCJodHRwOi8vZGVuby5sYW5kL3gvaHBrZS9jb3JlL21vZC50c1wiO1xuICpcbiAqIGNvbnN0IHN1aXRlID0gbmV3IENpcGhlclN1aXRlKHtcbiAqICAga2VtOiBuZXcgRGhrZW1QMjU2SGtkZlNoYTI1NigpLFxuICogICBrZGY6IG5ldyBIa2RmU2hhMjU2KCksXG4gKiAgIGFlYWQ6IG5ldyBBZXMyNTZHY20oKSxcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBZXMyNTZHY20gZXh0ZW5kcyBBZXMxMjhHY20ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKiogQWVhZElkLkFlczI1NkdjbSAoMHgwMDAyKSAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogQWVhZElkLkFlczI1NkdjbVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIDMyICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleVNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDMyXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogMTIgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibm9uY2VTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAxMlxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIDE2ICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ1NpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDE2XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEFlYWRJZCB9IGZyb20gXCIuLi9pZGVudGlmaWVycy5qc1wiO1xuaW1wb3J0IHsgTm90U3VwcG9ydGVkRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG4vKipcbiAqIFRoZSBFeHBvcnRPbmx5IG1vZGUgZm9yIEhQS0UgQUVBRCBpbXBsZW1lbnRpbmcge0BsaW5rIEFlYWRJbnRlcmZhY2V9LlxuICpcbiAqIFdoZW4gdXNpbmcgYEBocGtlL2NvcmVgLCB0aGUgaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBtdXN0IGJlIHNwZWNpZmllZFxuICogdG8gdGhlIGBhZWFkYCBwYXJhbWV0ZXIgb2Yge0BsaW5rIENpcGhlclN1aXRlUGFyYW1zfSBpbnN0ZWFkIG9mIGBBZWFkSWQuRXhwb3J0T25seWBcbiAqIGFzIGZvbGxvd3M6XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHtcbiAqICAgQ2lwaGVyU3VpdGUsXG4gKiAgIERoa2VtUDI1NkhrZGZTaGEyNTYsXG4gKiAgIEV4cG9ydE9ubHksXG4gKiAgIEhrZGZTaGEyNTYsXG4gKiB9IGZyb20gXCJodHRwOi8vZGVuby5sYW5kL3gvaHBrZS9jb3JlL21vZC50c1wiO1xuICpcbiAqIGNvbnN0IHN1aXRlID0gbmV3IENpcGhlclN1aXRlKHtcbiAqICAga2VtOiBuZXcgRGhrZW1QMjU2SGtkZlNoYTI1NigpLFxuICogICBrZGY6IG5ldyBIa2RmU2hhMjU2KCksXG4gKiAgIGFlYWQ6IG5ldyBFeHBvcnRPbmx5KCksXG4gKiB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgRXhwb3J0T25seSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBBZWFkSWQuRXhwb3J0T25seVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5U2l6ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibm9uY2VTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVFbmNyeXB0aW9uQ29udGV4dChfa2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcihcIkV4cG9ydCBvbmx5XCIpO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIGRudFNoaW0gZnJvbSBcIi4uL19kbnQuc2hpbXMuanNcIjtcbmltcG9ydCB7IE5vdFN1cHBvcnRlZEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5hc3luYyBmdW5jdGlvbiBsb2FkU3VidGxlQ3J5cHRvKCkge1xuICAgIGlmIChkbnRTaGltLmRudEdsb2JhbFRoaXMgIT09IHVuZGVmaW5lZCAmJiBnbG9iYWxUaGlzLmNyeXB0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEJyb3dzZXJzLCBOb2RlLmpzID49IHYxOSwgQ2xvdWRmbGFyZSBXb3JrZXJzLCBCdW4sIGV0Yy5cbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZTtcbiAgICB9XG4gICAgLy8gTm9kZS5qcyA8PSB2MThcbiAgICB0cnkge1xuICAgICAgICAvLyBAdHMtaWdub3JlOiB0byBpZ25vcmUgXCJjcnlwdG9cIlxuICAgICAgICBjb25zdCB7IHdlYmNyeXB0byB9ID0gYXdhaXQgaW1wb3J0KFwiY3J5cHRvXCIpOyAvLyBub2RlOmNyeXB0b1xuICAgICAgICByZXR1cm4gd2ViY3J5cHRvLnN1YnRsZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKGUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBOYXRpdmVBbGdvcml0aG0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYXBpXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9zZXR1cCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FwaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXBpID0gYXdhaXQgbG9hZFN1YnRsZUNyeXB0bygpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE5hdGl2ZUFsZ29yaXRobSB9IGZyb20gXCIuL2FsZ29yaXRobS5qc1wiO1xuaW1wb3J0IHsgRU1QVFksIElOUFVUX0xFTkdUSF9MSU1JVCwgTUlOSU1VTV9QU0tfTEVOR1RIIH0gZnJvbSBcIi4vY29uc3RzLmpzXCI7XG5pbXBvcnQgeyBJbnZhbGlkUGFyYW1FcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgUmVjaXBpZW50RXhwb3J0ZXJDb250ZXh0SW1wbCwgU2VuZGVyRXhwb3J0ZXJDb250ZXh0SW1wbCwgfSBmcm9tIFwiLi9leHBvcnRlckNvbnRleHQuanNcIjtcbmltcG9ydCB7IEFlYWRJZCwgTW9kZSB9IGZyb20gXCIuL2lkZW50aWZpZXJzLmpzXCI7XG5pbXBvcnQgeyBSZWNpcGllbnRDb250ZXh0SW1wbCB9IGZyb20gXCIuL3JlY2lwaWVudENvbnRleHQuanNcIjtcbmltcG9ydCB7IFNlbmRlckNvbnRleHRJbXBsIH0gZnJvbSBcIi4vc2VuZGVyQ29udGV4dC5qc1wiO1xuaW1wb3J0IHsgaTJPc3AgfSBmcm9tIFwiLi91dGlscy9taXNjLmpzXCI7XG4vLyBiXCJiYXNlX25vbmNlXCJcbi8vIGRlbm8tZm10LWlnbm9yZVxuY29uc3QgTEFCRUxfQkFTRV9OT05DRSA9IG5ldyBVaW50OEFycmF5KFtcbiAgICA5OCwgOTcsIDExNSwgMTAxLCA5NSwgMTEwLCAxMTEsIDExMCwgOTksIDEwMSxcbl0pO1xuLy8gYlwiZXhwXCJcbmNvbnN0IExBQkVMX0VYUCA9IG5ldyBVaW50OEFycmF5KFsxMDEsIDEyMCwgMTEyXSk7XG4vLyBiXCJpbmZvX2hhc2hcIlxuLy8gZGVuby1mbXQtaWdub3JlXG5jb25zdCBMQUJFTF9JTkZPX0hBU0ggPSBuZXcgVWludDhBcnJheShbXG4gICAgMTA1LCAxMTAsIDEwMiwgMTExLCA5NSwgMTA0LCA5NywgMTE1LCAxMDQsXG5dKTtcbi8vIGJcImtleVwiXG5jb25zdCBMQUJFTF9LRVkgPSBuZXcgVWludDhBcnJheShbMTA3LCAxMDEsIDEyMV0pO1xuLy8gYlwicHNrX2lkX2hhc2hcIlxuLy8gZGVuby1mbXQtaWdub3JlXG5jb25zdCBMQUJFTF9QU0tfSURfSEFTSCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAxMTIsIDExNSwgMTA3LCA5NSwgMTA1LCAxMDAsIDk1LCAxMDQsIDk3LCAxMTUsIDEwNCxcbl0pO1xuLy8gYlwic2VjcmV0XCJcbmNvbnN0IExBQkVMX1NFQ1JFVCA9IG5ldyBVaW50OEFycmF5KFsxMTUsIDEwMSwgOTksIDExNCwgMTAxLCAxMTZdKTtcbi8vIGJcIkhQS0VcIlxuLy8gZGVuby1mbXQtaWdub3JlXG5jb25zdCBTVUlURV9JRF9IRUFERVJfSFBLRSA9IG5ldyBVaW50OEFycmF5KFtcbiAgICA3MiwgODAsIDc1LCA2OSwgMCwgMCwgMCwgMCwgMCwgMCxcbl0pO1xuLyoqXG4gKiBUaGUgSHlicmlkIFB1YmxpYyBLZXkgRW5jcnlwdGlvbiAoSFBLRSkgY2lwaGVyc3VpdGUsXG4gKiB3aGljaCBpcyBpbXBsZW1lbnRlZCB1c2luZyBvbmx5XG4gKiB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL1dlYkNyeXB0b0FQSS8gfCBXZWIgQ3J5cHRvZ3JhcGh5IEFQSX0uXG4gKlxuICogVGhpcyBpcyB0aGUgc3VwZXIgY2xhc3Mgb2Yge0BsaW5rIENpcGhlclN1aXRlfSBhbmQgdGhlIHNhbWUgYXNcbiAqIHtAbGluayBodHRwczovL2Rlbm8ubGFuZC94L2hwa2UvY29yZS9tb2QudHM/cz1DaXBoZXJTdWl0ZSB8IEBocGtlL2NvcmUjQ2lwaGVyU3VpdGUgfSxcbiAqIHdoaWNoIHN1cHBvcnRzIG9ubHkgdGhlIGNpcGhlcnN1aXRlcyB0aGF0IGNhbiBiZSBpbXBsZW1lbnRlZCBvbiB0aGUgbmF0aXZlXG4gKiB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL1dlYkNyeXB0b0FQSS8gfCBXZWIgQ3J5cHRvZ3JhcGh5IEFQSX0uXG4gKiBUaGVyZWZvcmUsIHRoZSBmb2xsb3dpbmcgY3J5cHRvZ3JhcGhpYyBhbGdvcml0aG1zIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBub3c6XG4gKiAgIC0gREhLRU0oWDI1NTE5LCBIS0RGLVNIQTI1NilcbiAqICAgLSBESEtFTShYNDQ4LCBIS0RGLVNIQTUxMilcbiAqICAgLSBDaGFDaGEyMFBvbHkxMzA1XG4gKlxuICogSW4gYWRkdGlvbiwgdGhlIEhLREYgZnVuY3Rpb25zIGNvbnRhaW5lZCBpbiB0aGlzIGNsYXNzIGNhbiBvbmx5IGRlcml2ZVxuICoga2V5cyBvZiB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIGBoYXNoU2l6ZWAuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gdXNlIHRoZSB1bnN1cHBvcnRlZCBjcnlwdG9ncmFwaGljIGFsZ29yaXRobXNcbiAqIGFib3ZlIG9yIGRlcml2ZSBrZXlzIGxvbmdlciB0aGFuIHRoZSBgaGFzaFNpemVgLFxuICogcGxlYXNlIHVzZSB7QGxpbmsgQ2lwaGVyU3VpdGV9LlxuICpcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgZm9sbG93aW5nIGZ1bmN0aW9uczpcbiAqXG4gKiAtIENyZWF0ZXMgZW5jcnlwdGlvbiBjb250ZXh0cyBib3RoIGZvciBzZW5kZXJzIGFuZCByZWNpcGllbnRzLlxuICogICAtIHtAbGluayBjcmVhdGVTZW5kZXJDb250ZXh0fVxuICogICAtIHtAbGluayBjcmVhdGVSZWNpcGllbnRDb250ZXh0fVxuICogLSBQcm92aWRlcyBzaW5nbGUtc2hvdCBlbmNyeXB0aW9uIEFQSS5cbiAqICAgLSB7QGxpbmsgc2VhbH1cbiAqICAgLSB7QGxpbmsgb3Blbn1cbiAqXG4gKiBUaGUgY2FsbGluZyBvZiB0aGUgY29uc3RydWN0b3Igb2YgdGhpcyBjbGFzcyBpcyB0aGUgc3RhcnRpbmdcbiAqIHBvaW50IGZvciBIUEtFIG9wZXJhdGlvbnMgZm9yIGJvdGggc2VuZGVycyBhbmQgcmVjaXBpZW50cy5cbiAqXG4gKiBAZXhhbXBsZSBVc2Ugb25seSBjaXBoZXJzdWl0ZXMgc3VwcG9ydGVkIGJ5IFdlYiBDcnlwdG9ncmFwaHkgQVBJLlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge1xuICogICBBZXMxMjhHY20sXG4gKiAgIERoa2VtUDI1NkhrZGZTaGEyNTYsXG4gKiAgIEhrZGZTaGEyNTYsXG4gKiAgIENpcGhlclN1aXRlLFxuICogfSBmcm9tIFwiaHR0cDovL2Rlbm8ubGFuZC94L2hwa2UvbW9kLnRzXCI7XG4gKlxuICogY29uc3Qgc3VpdGUgPSBuZXcgQ2lwaGVyU3VpdGUoe1xuICogICBrZW06IG5ldyBEaGtlbVAyNTZIa2RmU2hhMjU2KCksXG4gKiAgIGtkZjogbmV3IEhrZGZTaGEyNTYoKSxcbiAqICAgYWVhZDogbmV3IEFlczEyOEdjbSgpLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZSBVc2UgYSBjaXBoZXJzdWl0ZSB3aGljaCBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBieSBXZWIgQ3J5cHRvZ3JhcGh5IEFQSS5cbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQWVzMTI4R2NtLCBIa2RmU2hhMjU2LCBDaXBoZXJTdWl0ZSB9IGZyb20gXCJodHRwOi8vZGVuby5sYW5kL3gvaHBrZS9tb2QudHNcIjtcbiAqIC8vIFVzZSBhbiBleHRlbnNpb24gbW9kdWxlLlxuICogaW1wb3J0IHsgRGhrZW1YMjU1MTlIa2RmU2hhMjU2IH0gZnJvbSBcImh0dHBzOi8vZGVuby5sYW5kL3gvaHBrZS94L2Roa2VtLXgyNTUxOS9tb2QudHNcIjtcbiAqXG4gKiBjb25zdCBzdWl0ZSA9IG5ldyBDaXBoZXJTdWl0ZSh7XG4gKiAgIGtlbTogbmV3IERoa2VtWDI1NTE5SGtkZlNoYTI1NigpLFxuICogICBrZGY6IG5ldyBIa2RmU2hhMjU2KCksXG4gKiAgIGFlYWQ6IG5ldyBBZXMxMjhHY20oKSxcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDaXBoZXJTdWl0ZU5hdGl2ZSBleHRlbmRzIE5hdGl2ZUFsZ29yaXRobSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBhcmFtcyBBIHNldCBvZiBwYXJhbWV0ZXJzIGZvciBidWlsZGluZyBhIGNpcGhlciBzdWl0ZS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBlcnJvciBvY2N1cnJlZCwgdGhyb3dzIHtAbGluayBJbnZhbGlkUGFyYW1FcnJvcn0uXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkUGFyYW1FcnJvcn1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2tlbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfa2RmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hZWFkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdWl0ZUlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEtFTVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5rZW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1FcnJvcihcIktlbUlkIGNhbm5vdCBiZSB1c2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2tlbSA9IHBhcmFtcy5rZW07XG4gICAgICAgIC8vIEtERlxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5rZGYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1FcnJvcihcIktkZklkIGNhbm5vdCBiZSB1c2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2tkZiA9IHBhcmFtcy5rZGY7XG4gICAgICAgIC8vIEFFQURcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuYWVhZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQYXJhbUVycm9yKFwiQWVhZElkIGNhbm5vdCBiZSB1c2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FlYWQgPSBwYXJhbXMuYWVhZDtcbiAgICAgICAgdGhpcy5fc3VpdGVJZCA9IG5ldyBVaW50OEFycmF5KFNVSVRFX0lEX0hFQURFUl9IUEtFKTtcbiAgICAgICAgdGhpcy5fc3VpdGVJZC5zZXQoaTJPc3AodGhpcy5fa2VtLmlkLCAyKSwgNCk7XG4gICAgICAgIHRoaXMuX3N1aXRlSWQuc2V0KGkyT3NwKHRoaXMuX2tkZi5pZCwgMiksIDYpO1xuICAgICAgICB0aGlzLl9zdWl0ZUlkLnNldChpMk9zcCh0aGlzLl9hZWFkLmlkLCAyKSwgOCk7XG4gICAgICAgIHRoaXMuX2tkZi5pbml0KHRoaXMuX3N1aXRlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBLRU0gY29udGV4dCBvZiB0aGUgY2lwaGVyc3VpdGUuXG4gICAgICovXG4gICAgZ2V0IGtlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tlbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgS0RGIGNvbnRleHQgb2YgdGhlIGNpcGhlcnN1aXRlLlxuICAgICAqL1xuICAgIGdldCBrZGYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZGY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEFFQUQgY29udGV4dCBvZiB0aGUgY2lwaGVyc3VpdGUuXG4gICAgICovXG4gICAgZ2V0IGFlYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZWFkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVuY3J5cHRpb24gY29udGV4dCBmb3IgYSBzZW5kZXIuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZXJyb3Igb2NjdXJyZWQsIHRocm93cyB7QGxpbmsgRGVjYXBFcnJvcn0gfCB7QGxpbmsgVmFsaWRhdGlvbkVycm9yfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQSBzZXQgb2YgcGFyYW1ldGVycyBmb3IgdGhlIHNlbmRlciBlbmNyeXB0aW9uIGNvbnRleHQuXG4gICAgICogQHJldHVybnMgQSBzZW5kZXIgZW5jcnlwdGlvbiBjb250ZXh0LlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEVuY2FwRXJyb3J9LCB7QGxpbmsgVmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVNlbmRlckNvbnRleHQocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlSW5wdXRMZW5ndGgocGFyYW1zKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXAoKTtcbiAgICAgICAgY29uc3QgZGggPSBhd2FpdCB0aGlzLl9rZW0uZW5jYXAocGFyYW1zKTtcbiAgICAgICAgbGV0IG1vZGU7XG4gICAgICAgIGlmIChwYXJhbXMucHNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1vZGUgPSBwYXJhbXMuc2VuZGVyS2V5ICE9PSB1bmRlZmluZWQgPyBNb2RlLkF1dGhQc2sgOiBNb2RlLlBzaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1vZGUgPSBwYXJhbXMuc2VuZGVyS2V5ICE9PSB1bmRlZmluZWQgPyBNb2RlLkF1dGggOiBNb2RlLkJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2tleVNjaGVkdWxlUyhtb2RlLCBkaC5zaGFyZWRTZWNyZXQsIGRoLmVuYywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlbmNyeXB0aW9uIGNvbnRleHQgZm9yIGEgcmVjaXBpZW50LlxuICAgICAqXG4gICAgICogSWYgdGhlIGVycm9yIG9jY3VycmVkLCB0aHJvd3Mge0BsaW5rIERlY2FwRXJyb3J9XG4gICAgICogfCB7QGxpbmsgRGVzZXJpYWxpemVFcnJvcn0gfCB7QGxpbmsgVmFsaWRhdGlvbkVycm9yfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQSBzZXQgb2YgcGFyYW1ldGVycyBmb3IgdGhlIHJlY2lwaWVudCBlbmNyeXB0aW9uIGNvbnRleHQuXG4gICAgICogQHJldHVybnMgQSByZWNpcGllbnQgZW5jcnlwdGlvbiBjb250ZXh0LlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIERlY2FwRXJyb3J9LCB7QGxpbmsgRGVzZXJpYWxpemVFcnJvcn0sIHtAbGluayBWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUmVjaXBpZW50Q29udGV4dChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVJbnB1dExlbmd0aChwYXJhbXMpO1xuICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cCgpO1xuICAgICAgICBjb25zdCBzaGFyZWRTZWNyZXQgPSBhd2FpdCB0aGlzLl9rZW0uZGVjYXAocGFyYW1zKTtcbiAgICAgICAgbGV0IG1vZGU7XG4gICAgICAgIGlmIChwYXJhbXMucHNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1vZGUgPSBwYXJhbXMuc2VuZGVyUHVibGljS2V5ICE9PSB1bmRlZmluZWQgPyBNb2RlLkF1dGhQc2sgOiBNb2RlLlBzaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1vZGUgPSBwYXJhbXMuc2VuZGVyUHVibGljS2V5ICE9PSB1bmRlZmluZWQgPyBNb2RlLkF1dGggOiBNb2RlLkJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2tleVNjaGVkdWxlUihtb2RlLCBzaGFyZWRTZWNyZXQsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZSB0byBhIHJlY2lwaWVudC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBlcnJvciBvY2N1cnJlZCwgdGhyb3dzIGBFbmNhcEVycm9yYCB8IGBNZXNzYWdlTGltaXRSZWFjaGVkRXJyb3JgIHwgYFNlYWxFcnJvcmAgfCBgVmFsaWRhdGlvbkVycm9yYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQSBzZXQgb2YgcGFyYW1ldGVycyBmb3IgYnVpbGRpbmcgYSBzZW5kZXIgZW5jcnlwdGlvbiBjb250ZXh0LlxuICAgICAqIEBwYXJhbSBwdCBBIHBsYWluIHRleHQgYXMgYnl0ZXMgdG8gYmUgZW5jcnlwdGVkLlxuICAgICAqIEBwYXJhbSBhYWQgQWRkaXRpb25hbCBhdXRoZW50aWNhdGVkIGRhdGEgYXMgYnl0ZXMgZmVkIGJ5IGFuIGFwcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgY2lwaGVyIHRleHQgYW5kIGFuIGVuY2Fwc3VsYXRlZCBrZXkgYXMgYnl0ZXMuXG4gICAgICogQHRocm93cyB7QGxpbmsgRW5jYXBFcnJvcn0sIHtAbGluayBNZXNzYWdlTGltaXRSZWFjaGVkRXJyb3J9LCB7QGxpbmsgU2VhbEVycm9yfSwge0BsaW5rIFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBhc3luYyBzZWFsKHBhcmFtcywgcHQsIGFhZCA9IEVNUFRZKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IGF3YWl0IHRoaXMuY3JlYXRlU2VuZGVyQ29udGV4dChwYXJhbXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3Q6IGF3YWl0IGN0eC5zZWFsKHB0LCBhYWQpLFxuICAgICAgICAgICAgZW5jOiBjdHguZW5jLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyeXB0cyBhIG1lc3NhZ2UgZnJvbSBhIHNlbmRlci5cbiAgICAgKlxuICAgICAqIElmIHRoZSBlcnJvciBvY2N1cnJlZCwgdGhyb3dzIGBEZWNhcEVycm9yYCB8IGBEZXNlcmlhbGl6ZUVycm9yYCB8IGBPcGVuRXJyb3JgIHwgYFZhbGlkYXRpb25FcnJvcmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIEEgc2V0IG9mIHBhcmFtZXRlcnMgZm9yIGJ1aWxkaW5nIGEgcmVjaXBpZW50IGVuY3J5cHRpb24gY29udGV4dC5cbiAgICAgKiBAcGFyYW0gY3QgQW4gZW5jcnlwdGVkIHRleHQgYXMgYnl0ZXMgdG8gYmUgZGVjcnlwdGVkLlxuICAgICAqIEBwYXJhbSBhYWQgQWRkaXRpb25hbCBhdXRoZW50aWNhdGVkIGRhdGEgYXMgYnl0ZXMgZmVkIGJ5IGFuIGFwcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgZGVjcnlwdGVkIHBsYWluIHRleHQgYXMgYnl0ZXMuXG4gICAgICogQHRocm93cyB7QGxpbmsgRGVjYXBFcnJvcn0sIHtAbGluayBEZXNlcmlhbGl6ZUVycm9yfSwge0BsaW5rIE9wZW5FcnJvcn0sIHtAbGluayBWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgYXN5bmMgb3BlbihwYXJhbXMsIGN0LCBhYWQgPSBFTVBUWSkge1xuICAgICAgICBjb25zdCBjdHggPSBhd2FpdCB0aGlzLmNyZWF0ZVJlY2lwaWVudENvbnRleHQocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGN0eC5vcGVuKGN0LCBhYWQpO1xuICAgIH1cbiAgICAvLyBwcml2YXRlIHZlcmlmeVBza0lucHV0cyhtb2RlOiBNb2RlLCBwYXJhbXM6IEtleVNjaGVkdWxlUGFyYW1zKSB7XG4gICAgLy8gICBjb25zdCBnb3RQc2sgPSAocGFyYW1zLnBzayAhPT0gdW5kZWZpbmVkKTtcbiAgICAvLyAgIGNvbnN0IGdvdFBza0lkID0gKHBhcmFtcy5wc2sgIT09IHVuZGVmaW5lZCAmJiBwYXJhbXMucHNrLmlkLmJ5dGVMZW5ndGggPiAwKTtcbiAgICAvLyAgIGlmIChnb3RQc2sgIT09IGdvdFBza0lkKSB7XG4gICAgLy8gICAgIHRocm93IG5ldyBFcnJvcignSW5jb25zaXN0ZW50IFBTSyBpbnB1dHMnKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIGlmIChnb3RQc2sgJiYgKG1vZGUgPT09IE1vZGUuQmFzZSB8fCBtb2RlID09PSBNb2RlLkF1dGgpKSB7XG4gICAgLy8gICAgIHRocm93IG5ldyBFcnJvcignUFNLIGlucHV0IHByb3ZpZGVkIHdoZW4gbm90IG5lZWRlZCcpO1xuICAgIC8vICAgfVxuICAgIC8vICAgaWYgKCFnb3RQc2sgJiYgKG1vZGUgPT09IE1vZGUuUHNrIHx8IG1vZGUgPT09IE1vZGUuQXV0aFBzaykpIHtcbiAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIFBTSyBpbnB1dCcpO1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuO1xuICAgIC8vIH1cbiAgICBhc3luYyBfa2V5U2NoZWR1bGUobW9kZSwgc2hhcmVkU2VjcmV0LCBwYXJhbXMpIHtcbiAgICAgICAgLy8gQ3VycmVudGx5LCB0aGVyZSBpcyBubyBwb2ludCBpbiBleGVjdXRpbmcgdGhpcyBmdW5jdGlvblxuICAgICAgICAvLyBiZWNhdXNlIHRoaXMgaHBrZSBsaWJyYXJ5IGRvZXMgbm90IGFsbG93IHVzZXJzIHRvIGV4cGxpY2l0bHkgc3BlY2lmeSB0aGUgbW9kZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhpcy52ZXJpZnlQc2tJbnB1dHMobW9kZSwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcHNrSWQgPSBwYXJhbXMucHNrID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gRU1QVFlcbiAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkocGFyYW1zLnBzay5pZCk7XG4gICAgICAgIGNvbnN0IHBza0lkSGFzaCA9IGF3YWl0IHRoaXMuX2tkZi5sYWJlbGVkRXh0cmFjdChFTVBUWSwgTEFCRUxfUFNLX0lEX0hBU0gsIHBza0lkKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IHBhcmFtcy5pbmZvID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gRU1QVFlcbiAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkocGFyYW1zLmluZm8pO1xuICAgICAgICBjb25zdCBpbmZvSGFzaCA9IGF3YWl0IHRoaXMuX2tkZi5sYWJlbGVkRXh0cmFjdChFTVBUWSwgTEFCRUxfSU5GT19IQVNILCBpbmZvKTtcbiAgICAgICAgY29uc3Qga2V5U2NoZWR1bGVDb250ZXh0ID0gbmV3IFVpbnQ4QXJyYXkoMSArIHBza0lkSGFzaC5ieXRlTGVuZ3RoICsgaW5mb0hhc2guYnl0ZUxlbmd0aCk7XG4gICAgICAgIGtleVNjaGVkdWxlQ29udGV4dC5zZXQobmV3IFVpbnQ4QXJyYXkoW21vZGVdKSwgMCk7XG4gICAgICAgIGtleVNjaGVkdWxlQ29udGV4dC5zZXQobmV3IFVpbnQ4QXJyYXkocHNrSWRIYXNoKSwgMSk7XG4gICAgICAgIGtleVNjaGVkdWxlQ29udGV4dC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5mb0hhc2gpLCAxICsgcHNrSWRIYXNoLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb25zdCBwc2sgPSBwYXJhbXMucHNrID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gRU1QVFlcbiAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkocGFyYW1zLnBzay5rZXkpO1xuICAgICAgICBjb25zdCBpa20gPSB0aGlzLl9rZGYuYnVpbGRMYWJlbGVkSWttKExBQkVMX1NFQ1JFVCwgcHNrKTtcbiAgICAgICAgY29uc3QgZXhwb3J0ZXJTZWNyZXRJbmZvID0gdGhpcy5fa2RmLmJ1aWxkTGFiZWxlZEluZm8oTEFCRUxfRVhQLCBrZXlTY2hlZHVsZUNvbnRleHQsIHRoaXMuX2tkZi5oYXNoU2l6ZSk7XG4gICAgICAgIGNvbnN0IGV4cG9ydGVyU2VjcmV0ID0gYXdhaXQgdGhpcy5fa2RmLmV4dHJhY3RBbmRFeHBhbmQoc2hhcmVkU2VjcmV0LCBpa20sIGV4cG9ydGVyU2VjcmV0SW5mbywgdGhpcy5fa2RmLmhhc2hTaXplKTtcbiAgICAgICAgaWYgKHRoaXMuX2FlYWQuaWQgPT09IEFlYWRJZC5FeHBvcnRPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm4geyBhZWFkOiB0aGlzLl9hZWFkLCBleHBvcnRlclNlY3JldDogZXhwb3J0ZXJTZWNyZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlJbmZvID0gdGhpcy5fa2RmLmJ1aWxkTGFiZWxlZEluZm8oTEFCRUxfS0VZLCBrZXlTY2hlZHVsZUNvbnRleHQsIHRoaXMuX2FlYWQua2V5U2l6ZSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHRoaXMuX2tkZi5leHRyYWN0QW5kRXhwYW5kKHNoYXJlZFNlY3JldCwgaWttLCBrZXlJbmZvLCB0aGlzLl9hZWFkLmtleVNpemUpO1xuICAgICAgICBjb25zdCBiYXNlTm9uY2VJbmZvID0gdGhpcy5fa2RmLmJ1aWxkTGFiZWxlZEluZm8oTEFCRUxfQkFTRV9OT05DRSwga2V5U2NoZWR1bGVDb250ZXh0LCB0aGlzLl9hZWFkLm5vbmNlU2l6ZSk7XG4gICAgICAgIGNvbnN0IGJhc2VOb25jZSA9IGF3YWl0IHRoaXMuX2tkZi5leHRyYWN0QW5kRXhwYW5kKHNoYXJlZFNlY3JldCwgaWttLCBiYXNlTm9uY2VJbmZvLCB0aGlzLl9hZWFkLm5vbmNlU2l6ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZWFkOiB0aGlzLl9hZWFkLFxuICAgICAgICAgICAgZXhwb3J0ZXJTZWNyZXQ6IGV4cG9ydGVyU2VjcmV0LFxuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICBiYXNlTm9uY2U6IG5ldyBVaW50OEFycmF5KGJhc2VOb25jZSksXG4gICAgICAgICAgICBzZXE6IDAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIF9rZXlTY2hlZHVsZVMobW9kZSwgc2hhcmVkU2VjcmV0LCBlbmMsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9rZXlTY2hlZHVsZShtb2RlLCBzaGFyZWRTZWNyZXQsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXMua2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VuZGVyRXhwb3J0ZXJDb250ZXh0SW1wbCh0aGlzLl9hcGksIHRoaXMuX2tkZiwgcmVzLmV4cG9ydGVyU2VjcmV0LCBlbmMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VuZGVyQ29udGV4dEltcGwodGhpcy5fYXBpLCB0aGlzLl9rZGYsIHJlcywgZW5jKTtcbiAgICB9XG4gICAgYXN5bmMgX2tleVNjaGVkdWxlUihtb2RlLCBzaGFyZWRTZWNyZXQsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9rZXlTY2hlZHVsZShtb2RlLCBzaGFyZWRTZWNyZXQsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXMua2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjaXBpZW50RXhwb3J0ZXJDb250ZXh0SW1wbCh0aGlzLl9hcGksIHRoaXMuX2tkZiwgcmVzLmV4cG9ydGVyU2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlY2lwaWVudENvbnRleHRJbXBsKHRoaXMuX2FwaSwgdGhpcy5fa2RmLCByZXMpO1xuICAgIH1cbiAgICBfdmFsaWRhdGVJbnB1dExlbmd0aChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5pbmZvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHBhcmFtcy5pbmZvLmJ5dGVMZW5ndGggPiBJTlBVVF9MRU5HVEhfTElNSVQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1FcnJvcihcIlRvbyBsb25nIGluZm9cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5wc2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5wc2sua2V5LmJ5dGVMZW5ndGggPCBNSU5JTVVNX1BTS19MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtRXJyb3IoYFBTSyBtdXN0IGhhdmUgYXQgbGVhc3QgJHtNSU5JTVVNX1BTS19MRU5HVEh9IGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLnBzay5rZXkuYnl0ZUxlbmd0aCA+IElOUFVUX0xFTkdUSF9MSU1JVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1FcnJvcihcIlRvbyBsb25nIHBzay5rZXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLnBzay5pZC5ieXRlTGVuZ3RoID4gSU5QVVRfTEVOR1RIX0xJTUlUKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQYXJhbUVycm9yKFwiVG9vIGxvbmcgcHNrLmlkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG4iLCIvLyBUaGUgaW5wdXQgbGVuZ3RoIGxpbWl0IChwc2ssIHBza19pZCwgaW5mbywgZXhwb3J0ZXJfY29udGV4dCwgaWttKS5cbmV4cG9ydCBjb25zdCBJTlBVVF9MRU5HVEhfTElNSVQgPSA4MTkyO1xuLy8gVGhlIG1pbmltdW0gbGVuZ3RoIG9mIGEgUFNLLlxuZXhwb3J0IGNvbnN0IE1JTklNVU1fUFNLX0xFTkdUSCA9IDMyO1xuLy8gYlwiXCJcbmV4cG9ydCBjb25zdCBFTVBUWSA9IG5ldyBVaW50OEFycmF5KDApO1xuIiwiaW1wb3J0IHsgTWVzc2FnZUxpbWl0UmVhY2hlZEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBFeHBvcnRlckNvbnRleHRJbXBsIH0gZnJvbSBcIi4vZXhwb3J0ZXJDb250ZXh0LmpzXCI7XG5pbXBvcnQgeyBpMk9zcCB9IGZyb20gXCIuL3V0aWxzL21pc2MuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB4b3IoYSwgYikge1xuICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4b3I6IGRpZmZlcmVudCBsZW5ndGggaW5wdXRzXCIpO1xuICAgIH1cbiAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShhLmJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnVmW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG5leHBvcnQgY2xhc3MgRW5jcnlwdGlvbkNvbnRleHRJbXBsIGV4dGVuZHMgRXhwb3J0ZXJDb250ZXh0SW1wbCB7XG4gICAgY29uc3RydWN0b3IoYXBpLCBrZGYsIHBhcmFtcykge1xuICAgICAgICBzdXBlcihhcGksIGtkZiwgcGFyYW1zLmV4cG9ydGVyU2VjcmV0KTtcbiAgICAgICAgLy8gQUVBRCBpZC5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2FlYWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIGxlbmd0aCBpbiBieXRlcyBvZiBhIGtleSBmb3IgdGhlIGFsZ29yaXRobS5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX25LXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBsZW5ndGggaW4gYnl0ZXMgb2YgYSBub25jZSBmb3IgdGhlIGFsZ29yaXRobS5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX25OXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBsZW5ndGggaW4gYnl0ZXMgb2YgYW4gYXV0aGVudGljYXRpb24gdGFnIGZvciB0aGUgYWxnb3JpdGhtLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfblRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIGVuZC10by1lbmQgZW5jcnlwdGlvbiBrZXkgaW5mb3JtYXRpb24uXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jdHhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcy5rZXkgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMuYmFzZU5vbmNlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHBhcmFtcy5zZXEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZWQgcGFyYW1ldGVycyBhcmUgbWlzc2luZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZWFkID0gcGFyYW1zLmFlYWQ7XG4gICAgICAgIHRoaXMuX25LID0gdGhpcy5fYWVhZC5rZXlTaXplO1xuICAgICAgICB0aGlzLl9uTiA9IHRoaXMuX2FlYWQubm9uY2VTaXplO1xuICAgICAgICB0aGlzLl9uVCA9IHRoaXMuX2FlYWQudGFnU2l6ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5fYWVhZC5jcmVhdGVFbmNyeXB0aW9uQ29udGV4dChwYXJhbXMua2V5KTtcbiAgICAgICAgdGhpcy5fY3R4ID0ge1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICBiYXNlTm9uY2U6IHBhcmFtcy5iYXNlTm9uY2UsXG4gICAgICAgICAgICBzZXE6IHBhcmFtcy5zZXEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXB1dGVOb25jZShrKSB7XG4gICAgICAgIGNvbnN0IHNlcUJ5dGVzID0gaTJPc3Aoay5zZXEsIGsuYmFzZU5vbmNlLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4geG9yKGsuYmFzZU5vbmNlLCBzZXFCeXRlcyk7XG4gICAgfVxuICAgIGluY3JlbWVudFNlcShrKSB7XG4gICAgICAgIC8vIGlmICh0aGlzLnNlcSA+PSAoMSA8PCAoOCAqIHRoaXMuYmFzZU5vbmNlLmJ5dGVMZW5ndGgpKSAtIDEpIHtcbiAgICAgICAgaWYgKGsuc2VxID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZXNzYWdlTGltaXRSZWFjaGVkRXJyb3IoXCJNZXNzYWdlIGxpbWl0IHJlYWNoZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgay5zZXEgKz0gMTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbiIsIi8qKlxuICogVGhlIGJhc2UgZXJyb3IgY2xhc3Mgb2YgaHBrZS1qcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZS5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgYmFzZSBlcnJvciBjbGFzcyBvZiBocGtlLWpzLlxuICovXG5leHBvcnQgY2xhc3MgSHBrZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbn1cbi8qKlxuICogSW52YWxpZCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkUGFyYW1FcnJvciBleHRlbmRzIEhwa2VFcnJvciB7XG59XG4vKipcbiAqIEtFTSBpbnB1dCBvciBvdXRwdXQgdmFsaWRhdGlvbiBmYWlsdXJlLlxuICovXG5leHBvcnQgY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgSHBrZUVycm9yIHtcbn1cbi8qKlxuICogUHVibGljIG9yIHByaXZhdGUga2V5IHNlcmlhbGl6YXRpb24gZmFpbHVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNlcmlhbGl6ZUVycm9yIGV4dGVuZHMgSHBrZUVycm9yIHtcbn1cbi8qKlxuICogUHVibGljIG9yIHByaXZhdGUga2V5IGRlc2VyaWFsaXphdGlvbiBmYWlsdXJlLlxuICovXG5leHBvcnQgY2xhc3MgRGVzZXJpYWxpemVFcnJvciBleHRlbmRzIEhwa2VFcnJvciB7XG59XG4vKipcbiAqIGVuY2FwKCkgZmFpbHVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuY2FwRXJyb3IgZXh0ZW5kcyBIcGtlRXJyb3Ige1xufVxuLyoqXG4gKiBkZWNhcCgpIGZhaWx1cmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWNhcEVycm9yIGV4dGVuZHMgSHBrZUVycm9yIHtcbn1cbi8qKlxuICogU2VjcmV0IGV4cG9ydCBmYWlsdXJlLlxuICovXG5leHBvcnQgY2xhc3MgRXhwb3J0RXJyb3IgZXh0ZW5kcyBIcGtlRXJyb3Ige1xufVxuLyoqXG4gKiBzZWFsKCkgZmFpbHVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNlYWxFcnJvciBleHRlbmRzIEhwa2VFcnJvciB7XG59XG4vKipcbiAqIG9wZW4oKSBmYWlsdXJlLlxuICovXG5leHBvcnQgY2xhc3MgT3BlbkVycm9yIGV4dGVuZHMgSHBrZUVycm9yIHtcbn1cbi8qKlxuICogU2VxdWVuY2UgbnVtYmVyIG92ZXJmbG93IG9uIHRoZSBlbmNyeXB0aW9uIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXNzYWdlTGltaXRSZWFjaGVkRXJyb3IgZXh0ZW5kcyBIcGtlRXJyb3Ige1xufVxuLyoqXG4gKiBLZXkgcGFpciBkZXJpdmF0aW9uIGZhaWx1cmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZXJpdmVLZXlQYWlyRXJyb3IgZXh0ZW5kcyBIcGtlRXJyb3Ige1xufVxuLyoqXG4gKiBOb3Qgc3VwcG9ydGVkIGZhaWx1cmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIEhwa2VFcnJvciB7XG59XG4iLCJpbXBvcnQgeyBJTlBVVF9MRU5HVEhfTElNSVQgfSBmcm9tIFwiLi9jb25zdHMuanNcIjtcbmltcG9ydCB7IEV4cG9ydEVycm9yLCBJbnZhbGlkUGFyYW1FcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZW1pdE5vdFN1cHBvcnRlZCB9IGZyb20gXCIuL3V0aWxzL2VtaXROb3RTdXBwb3J0ZWQuanNcIjtcbi8vIGJcInNlY1wiXG5jb25zdCBMQUJFTF9TRUMgPSBuZXcgVWludDhBcnJheShbMTE1LCAxMDEsIDk5XSk7XG5leHBvcnQgY2xhc3MgRXhwb3J0ZXJDb250ZXh0SW1wbCB7XG4gICAgY29uc3RydWN0b3IoYXBpLCBrZGYsIGV4cG9ydGVyU2VjcmV0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hcGlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhwb3J0ZXJTZWNyZXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2tkZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XG4gICAgICAgIHRoaXMuX2tkZiA9IGtkZjtcbiAgICAgICAgdGhpcy5leHBvcnRlclNlY3JldCA9IGV4cG9ydGVyU2VjcmV0O1xuICAgIH1cbiAgICBhc3luYyBzZWFsKF9kYXRhLCBfYWFkKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBlbWl0Tm90U3VwcG9ydGVkKCk7XG4gICAgfVxuICAgIGFzeW5jIG9wZW4oX2RhdGEsIF9hYWQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGVtaXROb3RTdXBwb3J0ZWQoKTtcbiAgICB9XG4gICAgYXN5bmMgZXhwb3J0KGV4cG9ydGVyQ29udGV4dCwgbGVuKSB7XG4gICAgICAgIGlmIChleHBvcnRlckNvbnRleHQuYnl0ZUxlbmd0aCA+IElOUFVUX0xFTkdUSF9MSU1JVCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQYXJhbUVycm9yKFwiVG9vIGxvbmcgZXhwb3J0ZXIgY29udGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2tkZi5sYWJlbGVkRXhwYW5kKHRoaXMuZXhwb3J0ZXJTZWNyZXQsIExBQkVMX1NFQywgbmV3IFVpbnQ4QXJyYXkoZXhwb3J0ZXJDb250ZXh0KSwgbGVuKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4cG9ydEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJlY2lwaWVudEV4cG9ydGVyQ29udGV4dEltcGwgZXh0ZW5kcyBFeHBvcnRlckNvbnRleHRJbXBsIHtcbn1cbmV4cG9ydCBjbGFzcyBTZW5kZXJFeHBvcnRlckNvbnRleHRJbXBsIGV4dGVuZHMgRXhwb3J0ZXJDb250ZXh0SW1wbCB7XG4gICAgY29uc3RydWN0b3IoYXBpLCBrZGYsIGV4cG9ydGVyU2VjcmV0LCBlbmMpIHtcbiAgICAgICAgc3VwZXIoYXBpLCBrZGYsIGV4cG9ydGVyU2VjcmV0KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5jXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW5jID0gZW5jO1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuIiwiLyoqXG4gKiBUaGUgc3VwcG9ydGVkIEhQS0UgbW9kZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBNb2RlID0ge1xuICAgIEJhc2U6IDB4MDAsXG4gICAgUHNrOiAweDAxLFxuICAgIEF1dGg6IDB4MDIsXG4gICAgQXV0aFBzazogMHgwMyxcbn07XG4vKipcbiAqIFRoZSBzdXBwb3J0ZWQgS2V5IEVuY2Fwc3VsYXRpb24gTWVjaGFuaXNtIChLRU0pIGlkZW50aWZpZXJzLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgS2RmSWR9IGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBLZW0gPSB7XG4gICAgTm90QXNzaWduZWQ6IDB4MDAwMCxcbiAgICBEaGtlbVAyNTZIa2RmU2hhMjU2OiAweDAwMTAsXG4gICAgRGhrZW1QMzg0SGtkZlNoYTM4NDogMHgwMDExLFxuICAgIERoa2VtUDUyMUhrZGZTaGE1MTI6IDB4MDAxMixcbiAgICBEaGtlbVNlY3AyNTZrMUhrZGZTaGEyNTY6IDB4MDAxMyxcbiAgICBEaGtlbVgyNTUxOUhrZGZTaGEyNTY6IDB4MDAyMCxcbiAgICBEaGtlbVg0NDhIa2RmU2hhNTEyOiAweDAwMjEsXG4gICAgSHlicmlka2VtWDI1NTE5S3liZXI3Njg6IDB4MDAzMCxcbn07XG4vKipcbiAqIFRoZSBzdXBwb3J0ZWQgS2V5IEVuY2Fwc3VsYXRpb24gTWVjaGFuaXNtIChLRU0pIGlkZW50aWZpZXJzLlxuICovXG5leHBvcnQgY29uc3QgS2VtSWQgPSBLZW07XG4vKipcbiAqIFRoZSBzdXBwb3J0ZWQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gKEtERikgaWRlbnRpZmllcnMuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBLZGZJZH0gaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNvbnN0IEtkZiA9IHtcbiAgICBIa2RmU2hhMjU2OiAweDAwMDEsXG4gICAgSGtkZlNoYTM4NDogMHgwMDAyLFxuICAgIEhrZGZTaGE1MTI6IDB4MDAwMyxcbn07XG4vKipcbiAqIFRoZSBzdXBwb3J0ZWQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gKEtERikgaWRlbnRpZmllcnMuXG4gKi9cbmV4cG9ydCBjb25zdCBLZGZJZCA9IEtkZjtcbi8qKlxuICogVGhlIHN1cHBvcnRlZCBBdXRoZW50aWNhdGVkIEVuY3J5cHRpb24gd2l0aCBBc3NvY2lhdGVkIERhdGEgKEFFQUQpIGlkZW50aWZpZXJzLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgQWVhZElkfSBpbnN0ZWFkLlxuICovXG5leHBvcnQgY29uc3QgQWVhZCA9IHtcbiAgICBBZXMxMjhHY206IDB4MDAwMSxcbiAgICBBZXMyNTZHY206IDB4MDAwMixcbiAgICBDaGFjaGEyMFBvbHkxMzA1OiAweDAwMDMsXG4gICAgRXhwb3J0T25seTogMHhGRkZGLFxufTtcbi8qKlxuICogVGhlIHN1cHBvcnRlZCBBdXRoZW50aWNhdGVkIEVuY3J5cHRpb24gd2l0aCBBc3NvY2lhdGVkIERhdGEgKEFFQUQpIGlkZW50aWZpZXJzLlxuICovXG5leHBvcnQgY29uc3QgQWVhZElkID0gQWVhZDtcbiIsIi8vIFRoZSBrZXkgdXNhZ2VzIGZvciBBRUFELlxuZXhwb3J0IGNvbnN0IEFFQURfVVNBR0VTID0gW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIl07XG4iLCIvLyBUaGUga2V5IHVzYWdlcyBmb3IgS0VNLlxuZXhwb3J0IGNvbnN0IEtFTV9VU0FHRVMgPSBbXCJkZXJpdmVCaXRzXCJdO1xuLy8gYlwiZGtwX3Bya1wiXG5leHBvcnQgY29uc3QgTEFCRUxfREtQX1BSSyA9IG5ldyBVaW50OEFycmF5KFsxMDAsIDEwNywgMTEyLCA5NSwgMTEyLCAxMTQsIDEwN10pO1xuLy8gYlwic2tcIlxuZXhwb3J0IGNvbnN0IExBQkVMX1NLID0gbmV3IFVpbnQ4QXJyYXkoWzExNSwgMTA3XSk7XG4iLCIvLyBiXCJLRU1cIlxuZXhwb3J0IGNvbnN0IFNVSVRFX0lEX0hFQURFUl9LRU0gPSBuZXcgVWludDhBcnJheShbNzUsIDY5LCA3NywgMCwgMF0pO1xuIiwiaW1wb3J0IHsgTmF0aXZlQWxnb3JpdGhtIH0gZnJvbSBcIi4uL2FsZ29yaXRobS5qc1wiO1xuaW1wb3J0IHsgRU1QVFkgfSBmcm9tIFwiLi4vY29uc3RzLmpzXCI7XG5pbXBvcnQgeyBJbnZhbGlkUGFyYW1FcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IEtkZklkIH0gZnJvbSBcIi4uL2lkZW50aWZpZXJzLmpzXCI7XG4vLyBiXCJIUEtFLXYxXCJcbmNvbnN0IEhQS0VfVkVSU0lPTiA9IG5ldyBVaW50OEFycmF5KFs3MiwgODAsIDc1LCA2OSwgNDUsIDExOCwgNDldKTtcbmV4cG9ydCBjbGFzcyBIa2RmTmF0aXZlIGV4dGVuZHMgTmF0aXZlQWxnb3JpdGhtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IEtkZklkLkhrZGZTaGEyNTZcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhc2hTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3VpdGVJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogRU1QVFlcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsZ0hhc2hcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkhNQUNcIixcbiAgICAgICAgICAgICAgICBoYXNoOiBcIlNIQS0yNTZcIixcbiAgICAgICAgICAgICAgICBsZW5ndGg6IDI1NixcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluaXQoc3VpdGVJZCkge1xuICAgICAgICB0aGlzLl9zdWl0ZUlkID0gc3VpdGVJZDtcbiAgICB9XG4gICAgYnVpbGRMYWJlbGVkSWttKGxhYmVsLCBpa20pIHtcbiAgICAgICAgdGhpcy5fY2hlY2tJbml0KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OEFycmF5KDcgKyB0aGlzLl9zdWl0ZUlkLmJ5dGVMZW5ndGggKyBsYWJlbC5ieXRlTGVuZ3RoICsgaWttLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXQuc2V0KEhQS0VfVkVSU0lPTiwgMCk7XG4gICAgICAgIHJldC5zZXQodGhpcy5fc3VpdGVJZCwgNyk7XG4gICAgICAgIHJldC5zZXQobGFiZWwsIDcgKyB0aGlzLl9zdWl0ZUlkLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXQuc2V0KGlrbSwgNyArIHRoaXMuX3N1aXRlSWQuYnl0ZUxlbmd0aCArIGxhYmVsLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBidWlsZExhYmVsZWRJbmZvKGxhYmVsLCBpbmZvLCBsZW4pIHtcbiAgICAgICAgdGhpcy5fY2hlY2tJbml0KCk7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OEFycmF5KDkgKyB0aGlzLl9zdWl0ZUlkLmJ5dGVMZW5ndGggKyBsYWJlbC5ieXRlTGVuZ3RoICsgaW5mby5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0LnNldChuZXcgVWludDhBcnJheShbMCwgbGVuXSksIDApO1xuICAgICAgICByZXQuc2V0KEhQS0VfVkVSU0lPTiwgMik7XG4gICAgICAgIHJldC5zZXQodGhpcy5fc3VpdGVJZCwgOSk7XG4gICAgICAgIHJldC5zZXQobGFiZWwsIDkgKyB0aGlzLl9zdWl0ZUlkLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXQuc2V0KGluZm8sIDkgKyB0aGlzLl9zdWl0ZUlkLmJ5dGVMZW5ndGggKyBsYWJlbC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgYXN5bmMgZXh0cmFjdChzYWx0LCBpa20pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXAoKTtcbiAgICAgICAgaWYgKHNhbHQuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2FsdCA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmhhc2hTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2FsdC5ieXRlTGVuZ3RoICE9PSB0aGlzLmhhc2hTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtRXJyb3IoXCJUaGUgc2FsdCBsZW5ndGggbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgaGFzaFNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgdGhpcy5fYXBpLmltcG9ydEtleShcInJhd1wiLCBzYWx0LCB0aGlzLmFsZ0hhc2gsIGZhbHNlLCBbXG4gICAgICAgICAgICBcInNpZ25cIixcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkuc2lnbihcIkhNQUNcIiwga2V5LCBpa20pO1xuICAgIH1cbiAgICBhc3luYyBleHBhbmQocHJrLCBpbmZvLCBsZW4pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXAoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgdGhpcy5fYXBpLmltcG9ydEtleShcInJhd1wiLCBwcmssIHRoaXMuYWxnSGFzaCwgZmFsc2UsIFtcbiAgICAgICAgICAgIFwic2lnblwiLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3Qgb2ttID0gbmV3IEFycmF5QnVmZmVyKGxlbik7XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgVWludDhBcnJheShva20pO1xuICAgICAgICBsZXQgcHJldiA9IEVNUFRZO1xuICAgICAgICBjb25zdCBtaWQgPSBuZXcgVWludDhBcnJheShpbmZvKTtcbiAgICAgICAgY29uc3QgdGFpbCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgICBpZiAobGVuID4gMjU1ICogdGhpcy5oYXNoU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW50cm9weSBsaW1pdCByZWFjaGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KHRoaXMuaGFzaFNpemUgKyBtaWQubGVuZ3RoICsgMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxLCBjdXIgPSAwOyBjdXIgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0YWlsWzBdID0gaTtcbiAgICAgICAgICAgIHRtcC5zZXQocHJldiwgMCk7XG4gICAgICAgICAgICB0bXAuc2V0KG1pZCwgcHJldi5sZW5ndGgpO1xuICAgICAgICAgICAgdG1wLnNldCh0YWlsLCBwcmV2Lmxlbmd0aCArIG1pZC5sZW5ndGgpO1xuICAgICAgICAgICAgcHJldiA9IG5ldyBVaW50OEFycmF5KGF3YWl0IHRoaXMuX2FwaS5zaWduKFwiSE1BQ1wiLCBrZXksIHRtcC5zbGljZSgwLCBwcmV2Lmxlbmd0aCArIG1pZC5sZW5ndGggKyAxKSkpO1xuICAgICAgICAgICAgaWYgKHAubGVuZ3RoIC0gY3VyID49IHByZXYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcC5zZXQocHJldiwgY3VyKTtcbiAgICAgICAgICAgICAgICBjdXIgKz0gcHJldi5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwLnNldChwcmV2LnNsaWNlKDAsIHAubGVuZ3RoIC0gY3VyKSwgY3VyKTtcbiAgICAgICAgICAgICAgICBjdXIgKz0gcC5sZW5ndGggLSBjdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9rbTtcbiAgICB9XG4gICAgYXN5bmMgZXh0cmFjdEFuZEV4cGFuZChzYWx0LCBpa20sIGluZm8sIGxlbikge1xuICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cCgpO1xuICAgICAgICBjb25zdCBiYXNlS2V5ID0gYXdhaXQgdGhpcy5fYXBpLmltcG9ydEtleShcInJhd1wiLCBpa20sIFwiSEtERlwiLCBmYWxzZSwgW1wiZGVyaXZlQml0c1wiXSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkuZGVyaXZlQml0cyh7XG4gICAgICAgICAgICBuYW1lOiBcIkhLREZcIixcbiAgICAgICAgICAgIGhhc2g6IHRoaXMuYWxnSGFzaC5oYXNoLFxuICAgICAgICAgICAgc2FsdDogc2FsdCxcbiAgICAgICAgICAgIGluZm86IGluZm8sXG4gICAgICAgIH0sIGJhc2VLZXksIGxlbiAqIDgpO1xuICAgIH1cbiAgICBhc3luYyBsYWJlbGVkRXh0cmFjdChzYWx0LCBsYWJlbCwgaWttKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV4dHJhY3Qoc2FsdCwgdGhpcy5idWlsZExhYmVsZWRJa20obGFiZWwsIGlrbSkpO1xuICAgIH1cbiAgICBhc3luYyBsYWJlbGVkRXhwYW5kKHByaywgbGFiZWwsIGluZm8sIGxlbikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5leHBhbmQocHJrLCB0aGlzLmJ1aWxkTGFiZWxlZEluZm8obGFiZWwsIGluZm8sIGxlbiksIGxlbik7XG4gICAgfVxuICAgIF9jaGVja0luaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWl0ZUlkID09PSBFTVBUWSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGluaXRpYWxpemVkLiBDYWxsIGluaXQoKVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBIa2RmU2hhMjU2TmF0aXZlIGV4dGVuZHMgSGtkZk5hdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKiBLZGZJZC5Ia2RmU2hhMjU2ICgweDAwMDEpICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBLZGZJZC5Ia2RmU2hhMjU2XG4gICAgICAgIH0pO1xuICAgICAgICAvKiogMzIgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFzaFNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDMyXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogVGhlIHBhcmFtZXRlcnMgZm9yIFdlYiBDcnlwdG9ncmFwaHkgQVBJICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsZ0hhc2hcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkhNQUNcIixcbiAgICAgICAgICAgICAgICBoYXNoOiBcIlNIQS0yNTZcIixcbiAgICAgICAgICAgICAgICBsZW5ndGg6IDI1NixcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEhrZGZTaGEzODROYXRpdmUgZXh0ZW5kcyBIa2RmTmF0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqIEtkZklkLkhrZGZTaGEzODQgKDB4MDAwMikgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IEtkZklkLkhrZGZTaGEzODRcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiA0OCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYXNoU2l6ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNDhcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgcGFyYW1ldGVycyBmb3IgV2ViIENyeXB0b2dyYXBoeSBBUEkgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWxnSGFzaFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiSE1BQ1wiLFxuICAgICAgICAgICAgICAgIGhhc2g6IFwiU0hBLTM4NFwiLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogMzg0LFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSGtkZlNoYTUxMk5hdGl2ZSBleHRlbmRzIEhrZGZOYXRpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKiogS2RmSWQuSGtkZlNoYTUxMiAoMHgwMDAzKSAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogS2RmSWQuSGtkZlNoYTUxMlxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIDY0ICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhc2hTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA2NFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFRoZSBwYXJhbWV0ZXJzIGZvciBXZWIgQ3J5cHRvZ3JhcGh5IEFQSSAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbGdIYXNoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJITUFDXCIsXG4gICAgICAgICAgICAgICAgaGFzaDogXCJTSEEtNTEyXCIsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiA1MTIsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEVNUFRZLCBJTlBVVF9MRU5HVEhfTElNSVQgfSBmcm9tIFwiLi4vY29uc3RzLmpzXCI7XG5pbXBvcnQgeyBEZWNhcEVycm9yLCBFbmNhcEVycm9yLCBJbnZhbGlkUGFyYW1FcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IFNVSVRFX0lEX0hFQURFUl9LRU0gfSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9rZW1JbnRlcmZhY2UuanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgaTJPc3AsIGlzQ3J5cHRvS2V5UGFpciB9IGZyb20gXCIuLi91dGlscy9taXNjLmpzXCI7XG4vLyBiXCJlYWVfcHJrXCJcbmNvbnN0IExBQkVMX0VBRV9QUksgPSBuZXcgVWludDhBcnJheShbMTAxLCA5NywgMTAxLCA5NSwgMTEyLCAxMTQsIDEwN10pO1xuLy8gYlwic2hhcmVkX3NlY3JldFwiXG4vLyBkZW5vLWZtdC1pZ25vcmVcbmNvbnN0IExBQkVMX1NIQVJFRF9TRUNSRVQgPSBuZXcgVWludDhBcnJheShbXG4gICAgMTE1LCAxMDQsIDk3LCAxMTQsIDEwMSwgMTAwLCA5NSwgMTE1LCAxMDEsIDk5LFxuICAgIDExNCwgMTAxLCAxMTYsXG5dKTtcbmZ1bmN0aW9uIGNvbmNhdDMoYSwgYiwgYykge1xuICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoICsgYi5sZW5ndGggKyBjLmxlbmd0aCk7XG4gICAgcmV0LnNldChhLCAwKTtcbiAgICByZXQuc2V0KGIsIGEubGVuZ3RoKTtcbiAgICByZXQuc2V0KGMsIGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICAgIHJldHVybiByZXQ7XG59XG5leHBvcnQgY2xhc3MgRGhrZW0ge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBwcmltLCBrZGYpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VjcmV0U2l6ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5jU2l6ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHVibGljS2V5U2l6ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJpdmF0ZUtleVNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wcmltXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9rZGZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLl9wcmltID0gcHJpbTtcbiAgICAgICAgdGhpcy5fa2RmID0ga2RmO1xuICAgICAgICBjb25zdCBzdWl0ZUlkID0gbmV3IFVpbnQ4QXJyYXkoU1VJVEVfSURfSEVBREVSX0tFTSk7XG4gICAgICAgIHN1aXRlSWQuc2V0KGkyT3NwKHRoaXMuaWQsIDIpLCAzKTtcbiAgICAgICAgdGhpcy5fa2RmLmluaXQoc3VpdGVJZCk7XG4gICAgfVxuICAgIGFzeW5jIHNlcmlhbGl6ZVB1YmxpY0tleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3ByaW0uc2VyaWFsaXplUHVibGljS2V5KGtleSk7XG4gICAgfVxuICAgIGFzeW5jIGRlc2VyaWFsaXplUHVibGljS2V5KGtleSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcHJpbS5kZXNlcmlhbGl6ZVB1YmxpY0tleShrZXkpO1xuICAgIH1cbiAgICBhc3luYyBzZXJpYWxpemVQcml2YXRlS2V5KGtleSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcHJpbS5zZXJpYWxpemVQcml2YXRlS2V5KGtleSk7XG4gICAgfVxuICAgIGFzeW5jIGRlc2VyaWFsaXplUHJpdmF0ZUtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3ByaW0uZGVzZXJpYWxpemVQcml2YXRlS2V5KGtleSk7XG4gICAgfVxuICAgIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleSwgaXNQdWJsaWMgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9wcmltLmltcG9ydEtleShmb3JtYXQsIGtleSwgaXNQdWJsaWMpO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUtleVBhaXIoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9wcmltLmdlbmVyYXRlS2V5UGFpcigpO1xuICAgIH1cbiAgICBhc3luYyBkZXJpdmVLZXlQYWlyKGlrbSkge1xuICAgICAgICBpZiAoaWttLmJ5dGVMZW5ndGggPiBJTlBVVF9MRU5HVEhfTElNSVQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1FcnJvcihcIlRvbyBsb25nIGlrbVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcHJpbS5kZXJpdmVLZXlQYWlyKGlrbSk7XG4gICAgfVxuICAgIGFzeW5jIGVuY2FwKHBhcmFtcykge1xuICAgICAgICBsZXQga2U7XG4gICAgICAgIGlmIChwYXJhbXMuZWttID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGtlID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUtleVBhaXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NyeXB0b0tleVBhaXIocGFyYW1zLmVrbSkpIHtcbiAgICAgICAgICAgIC8vIHBhcmFtcy5la20gaXMgb25seSB1c2VkIGZvciB0ZXN0aW5nLlxuICAgICAgICAgICAga2UgPSBwYXJhbXMuZWttO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyYW1zLmVrbSBpcyBvbmx5IHVzZWQgZm9yIHRlc3RpbmcuXG4gICAgICAgICAgICBrZSA9IGF3YWl0IHRoaXMuZGVyaXZlS2V5UGFpcihwYXJhbXMuZWttKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmMgPSBhd2FpdCB0aGlzLl9wcmltLnNlcmlhbGl6ZVB1YmxpY0tleShrZS5wdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBwa3JtID0gYXdhaXQgdGhpcy5fcHJpbS5zZXJpYWxpemVQdWJsaWNLZXkocGFyYW1zLnJlY2lwaWVudFB1YmxpY0tleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZGg7XG4gICAgICAgICAgICBpZiAocGFyYW1zLnNlbmRlcktleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGggPSBuZXcgVWludDhBcnJheShhd2FpdCB0aGlzLl9wcmltLmRoKGtlLnByaXZhdGVLZXksIHBhcmFtcy5yZWNpcGllbnRQdWJsaWNLZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNrcyA9IGlzQ3J5cHRvS2V5UGFpcihwYXJhbXMuc2VuZGVyS2V5KVxuICAgICAgICAgICAgICAgICAgICA/IHBhcmFtcy5zZW5kZXJLZXkucHJpdmF0ZUtleVxuICAgICAgICAgICAgICAgICAgICA6IHBhcmFtcy5zZW5kZXJLZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGgxID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdGhpcy5fcHJpbS5kaChrZS5wcml2YXRlS2V5LCBwYXJhbXMucmVjaXBpZW50UHVibGljS2V5KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGgyID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdGhpcy5fcHJpbS5kaChza3MsIHBhcmFtcy5yZWNpcGllbnRQdWJsaWNLZXkpKTtcbiAgICAgICAgICAgICAgICBkaCA9IGNvbmNhdChkaDEsIGRoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQga2VtQ29udGV4dDtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuc2VuZGVyS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBrZW1Db250ZXh0ID0gY29uY2F0KG5ldyBVaW50OEFycmF5KGVuYyksIG5ldyBVaW50OEFycmF5KHBrcm0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBrcyA9IGlzQ3J5cHRvS2V5UGFpcihwYXJhbXMuc2VuZGVyS2V5KVxuICAgICAgICAgICAgICAgICAgICA/IHBhcmFtcy5zZW5kZXJLZXkucHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIDogYXdhaXQgdGhpcy5fcHJpbS5kZXJpdmVQdWJsaWNLZXkocGFyYW1zLnNlbmRlcktleSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGtzbSA9IGF3YWl0IHRoaXMuX3ByaW0uc2VyaWFsaXplUHVibGljS2V5KHBrcyk7XG4gICAgICAgICAgICAgICAga2VtQ29udGV4dCA9IGNvbmNhdDMobmV3IFVpbnQ4QXJyYXkoZW5jKSwgbmV3IFVpbnQ4QXJyYXkocGtybSksIG5ldyBVaW50OEFycmF5KHBrc20pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFNlY3JldCA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlU2hhcmVkU2VjcmV0KGRoLCBrZW1Db250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW5jOiBlbmMsXG4gICAgICAgICAgICAgICAgc2hhcmVkU2VjcmV0OiBzaGFyZWRTZWNyZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRW5jYXBFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZWNhcChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcGtlID0gYXdhaXQgdGhpcy5fcHJpbS5kZXNlcmlhbGl6ZVB1YmxpY0tleShwYXJhbXMuZW5jKTtcbiAgICAgICAgY29uc3Qgc2tyID0gaXNDcnlwdG9LZXlQYWlyKHBhcmFtcy5yZWNpcGllbnRLZXkpXG4gICAgICAgICAgICA/IHBhcmFtcy5yZWNpcGllbnRLZXkucHJpdmF0ZUtleVxuICAgICAgICAgICAgOiBwYXJhbXMucmVjaXBpZW50S2V5O1xuICAgICAgICBjb25zdCBwa3IgPSBpc0NyeXB0b0tleVBhaXIocGFyYW1zLnJlY2lwaWVudEtleSlcbiAgICAgICAgICAgID8gcGFyYW1zLnJlY2lwaWVudEtleS5wdWJsaWNLZXlcbiAgICAgICAgICAgIDogYXdhaXQgdGhpcy5fcHJpbS5kZXJpdmVQdWJsaWNLZXkocGFyYW1zLnJlY2lwaWVudEtleSk7XG4gICAgICAgIGNvbnN0IHBrcm0gPSBhd2FpdCB0aGlzLl9wcmltLnNlcmlhbGl6ZVB1YmxpY0tleShwa3IpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGRoO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5zZW5kZXJQdWJsaWNLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRoID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdGhpcy5fcHJpbS5kaChza3IsIHBrZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGgxID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdGhpcy5fcHJpbS5kaChza3IsIHBrZSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRoMiA9IG5ldyBVaW50OEFycmF5KGF3YWl0IHRoaXMuX3ByaW0uZGgoc2tyLCBwYXJhbXMuc2VuZGVyUHVibGljS2V5KSk7XG4gICAgICAgICAgICAgICAgZGggPSBjb25jYXQoZGgxLCBkaDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGtlbUNvbnRleHQ7XG4gICAgICAgICAgICBpZiAocGFyYW1zLnNlbmRlclB1YmxpY0tleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAga2VtQ29udGV4dCA9IGNvbmNhdChuZXcgVWludDhBcnJheShwYXJhbXMuZW5jKSwgbmV3IFVpbnQ4QXJyYXkocGtybSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGtzbSA9IGF3YWl0IHRoaXMuX3ByaW0uc2VyaWFsaXplUHVibGljS2V5KHBhcmFtcy5zZW5kZXJQdWJsaWNLZXkpO1xuICAgICAgICAgICAgICAgIGtlbUNvbnRleHQgPSBuZXcgVWludDhBcnJheShwYXJhbXMuZW5jLmJ5dGVMZW5ndGggKyBwa3JtLmJ5dGVMZW5ndGggKyBwa3NtLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGtlbUNvbnRleHQuc2V0KG5ldyBVaW50OEFycmF5KHBhcmFtcy5lbmMpLCAwKTtcbiAgICAgICAgICAgICAgICBrZW1Db250ZXh0LnNldChuZXcgVWludDhBcnJheShwa3JtKSwgcGFyYW1zLmVuYy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBrZW1Db250ZXh0LnNldChuZXcgVWludDhBcnJheShwa3NtKSwgcGFyYW1zLmVuYy5ieXRlTGVuZ3RoICsgcGtybS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZW5lcmF0ZVNoYXJlZFNlY3JldChkaCwga2VtQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEZWNhcEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9nZW5lcmF0ZVNoYXJlZFNlY3JldChkaCwga2VtQ29udGV4dCkge1xuICAgICAgICBjb25zdCBsYWJlbGVkSWttID0gdGhpcy5fa2RmLmJ1aWxkTGFiZWxlZElrbShMQUJFTF9FQUVfUFJLLCBkaCk7XG4gICAgICAgIGNvbnN0IGxhYmVsZWRJbmZvID0gdGhpcy5fa2RmLmJ1aWxkTGFiZWxlZEluZm8oTEFCRUxfU0hBUkVEX1NFQ1JFVCwga2VtQ29udGV4dCwgdGhpcy5zZWNyZXRTaXplKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2tkZi5leHRyYWN0QW5kRXhwYW5kKEVNUFRZLCBsYWJlbGVkSWttLCBsYWJlbGVkSW5mbywgdGhpcy5zZWNyZXRTaXplKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBLZW1JZCB9IGZyb20gXCIuLi9pZGVudGlmaWVycy5qc1wiO1xuaW1wb3J0IHsgSGtkZlNoYTI1Nk5hdGl2ZSwgSGtkZlNoYTM4NE5hdGl2ZSwgSGtkZlNoYTUxMk5hdGl2ZSwgfSBmcm9tIFwiLi4va2Rmcy9oa2RmLmpzXCI7XG5pbXBvcnQgeyBEaGtlbSB9IGZyb20gXCIuL2Roa2VtLmpzXCI7XG5pbXBvcnQgeyBFYyB9IGZyb20gXCIuL2Roa2VtUHJpbWl0aXZlcy9lYy5qc1wiO1xuZXhwb3J0IGNsYXNzIERoa2VtUDI1NkhrZGZTaGEyNTZOYXRpdmUgZXh0ZW5kcyBEaGtlbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IGtkZiA9IG5ldyBIa2RmU2hhMjU2TmF0aXZlKCk7XG4gICAgICAgIGNvbnN0IHByaW0gPSBuZXcgRWMoS2VtSWQuRGhrZW1QMjU2SGtkZlNoYTI1Niwga2RmKTtcbiAgICAgICAgc3VwZXIoS2VtSWQuRGhrZW1QMjU2SGtkZlNoYTI1NiwgcHJpbSwga2RmKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IEtlbUlkLkRoa2VtUDI1NkhrZGZTaGEyNTZcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlY3JldFNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDMyXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmNTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA2NVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHVibGljS2V5U2l6ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNjVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByaXZhdGVLZXlTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAzMlxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGhrZW1QMzg0SGtkZlNoYTM4NE5hdGl2ZSBleHRlbmRzIERoa2VtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3Qga2RmID0gbmV3IEhrZGZTaGEzODROYXRpdmUoKTtcbiAgICAgICAgY29uc3QgcHJpbSA9IG5ldyBFYyhLZW1JZC5EaGtlbVAzODRIa2RmU2hhMzg0LCBrZGYpO1xuICAgICAgICBzdXBlcihLZW1JZC5EaGtlbVAzODRIa2RmU2hhMzg0LCBwcmltLCBrZGYpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogS2VtSWQuRGhrZW1QMzg0SGtkZlNoYTM4NFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VjcmV0U2l6ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNDhcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuY1NpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDk3XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwdWJsaWNLZXlTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA5N1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJpdmF0ZUtleVNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDQ4XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEaGtlbVA1MjFIa2RmU2hhNTEyTmF0aXZlIGV4dGVuZHMgRGhrZW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCBrZGYgPSBuZXcgSGtkZlNoYTUxMk5hdGl2ZSgpO1xuICAgICAgICBjb25zdCBwcmltID0gbmV3IEVjKEtlbUlkLkRoa2VtUDUyMUhrZGZTaGE1MTIsIGtkZik7XG4gICAgICAgIHN1cGVyKEtlbUlkLkRoa2VtUDUyMUhrZGZTaGE1MTIsIHByaW0sIGtkZik7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBLZW1JZC5EaGtlbVA1MjFIa2RmU2hhNTEyXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZWNyZXRTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA2NFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5jU2l6ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMTMzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwdWJsaWNLZXlTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAxMzNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByaXZhdGVLZXlTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA2NFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBOYXRpdmVBbGdvcml0aG0gfSBmcm9tIFwiLi4vLi4vYWxnb3JpdGhtLmpzXCI7XG5pbXBvcnQgeyBFTVBUWSB9IGZyb20gXCIuLi8uLi9jb25zdHMuanNcIjtcbmltcG9ydCB7IERlcml2ZUtleVBhaXJFcnJvciwgRGVzZXJpYWxpemVFcnJvciwgTm90U3VwcG9ydGVkRXJyb3IsIFNlcmlhbGl6ZUVycm9yLCB9IGZyb20gXCIuLi8uLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IEtlbUlkIH0gZnJvbSBcIi4uLy4uL2lkZW50aWZpZXJzLmpzXCI7XG5pbXBvcnQgeyBLRU1fVVNBR0VTLCBMQUJFTF9ES1BfUFJLIH0gZnJvbSBcIi4uLy4uL2ludGVyZmFjZXMvZGhrZW1QcmltaXRpdmVzLmpzXCI7XG5pbXBvcnQgeyBCaWdudW0gfSBmcm9tIFwiLi4vLi4vdXRpbHMvYmlnbnVtLmpzXCI7XG5pbXBvcnQgeyBiYXNlNjRVcmxUb0J5dGVzLCBpMk9zcCB9IGZyb20gXCIuLi8uLi91dGlscy9taXNjLmpzXCI7XG4vLyBiXCJjYW5kaWRhdGVcIlxuLy8gZGVuby1mbXQtaWdub3JlXG5jb25zdCBMQUJFTF9DQU5ESURBVEUgPSBuZXcgVWludDhBcnJheShbXG4gICAgOTksIDk3LCAxMTAsIDEwMCwgMTA1LCAxMDAsIDk3LCAxMTYsIDEwMSxcbl0pO1xuLy8gdGhlIG9yZGVyIG9mIHRoZSBjdXJ2ZSBiZWluZyB1c2VkLlxuLy8gZGVuby1mbXQtaWdub3JlXG5jb25zdCBPUkRFUl9QXzI1NiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gICAgMHhiYywgMHhlNiwgMHhmYSwgMHhhZCwgMHhhNywgMHgxNywgMHg5ZSwgMHg4NCxcbiAgICAweGYzLCAweGI5LCAweGNhLCAweGMyLCAweGZjLCAweDYzLCAweDI1LCAweDUxLFxuXSk7XG4vLyBkZW5vLWZtdC1pZ25vcmVcbmNvbnN0IE9SREVSX1BfMzg0ID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZixcbiAgICAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAgIDB4YzcsIDB4NjMsIDB4NGQsIDB4ODEsIDB4ZjQsIDB4MzcsIDB4MmQsIDB4ZGYsXG4gICAgMHg1OCwgMHgxYSwgMHgwZCwgMHhiMiwgMHg0OCwgMHhiMCwgMHhhNywgMHg3YSxcbiAgICAweGVjLCAweGVjLCAweDE5LCAweDZhLCAweGNjLCAweGM1LCAweDI5LCAweDczLFxuXSk7XG4vLyBkZW5vLWZtdC1pZ25vcmVcbmNvbnN0IE9SREVSX1BfNTIxID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDB4MDEsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZixcbiAgICAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gICAgMHhmZiwgMHhmYSwgMHg1MSwgMHg4NiwgMHg4NywgMHg4MywgMHhiZiwgMHgyZixcbiAgICAweDk2LCAweDZiLCAweDdmLCAweGNjLCAweDAxLCAweDQ4LCAweGY3LCAweDA5LFxuICAgIDB4YTUsIDB4ZDAsIDB4M2IsIDB4YjUsIDB4YzksIDB4YjgsIDB4ODksIDB4OWMsXG4gICAgMHg0NywgMHhhZSwgMHhiYiwgMHg2ZiwgMHhiNywgMHgxZSwgMHg5MSwgMHgzOCxcbiAgICAweDY0LCAweDA5LFxuXSk7XG4vLyBkZW5vLWZtdC1pZ25vcmVcbmNvbnN0IFBLQ1M4X0FMR19JRF9QXzI1NiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICA0OCwgNjUsIDIsIDEsIDAsIDQ4LCAxOSwgNiwgNywgNDIsXG4gICAgMTM0LCA3MiwgMjA2LCA2MSwgMiwgMSwgNiwgOCwgNDIsIDEzNCxcbiAgICA3MiwgMjA2LCA2MSwgMywgMSwgNywgNCwgMzksIDQ4LCAzNyxcbiAgICAyLCAxLCAxLCA0LCAzMixcbl0pO1xuLy8gZGVuby1mbXQtaWdub3JlXG5jb25zdCBQS0NTOF9BTEdfSURfUF8zODQgPSBuZXcgVWludDhBcnJheShbXG4gICAgNDgsIDc4LCAyLCAxLCAwLCA0OCwgMTYsIDYsIDcsIDQyLFxuICAgIDEzNCwgNzIsIDIwNiwgNjEsIDIsIDEsIDYsIDUsIDQzLCAxMjksXG4gICAgNCwgMCwgMzQsIDQsIDU1LCA0OCwgNTMsIDIsIDEsIDEsXG4gICAgNCwgNDgsXG5dKTtcbi8vIGRlbm8tZm10LWlnbm9yZVxuY29uc3QgUEtDUzhfQUxHX0lEX1BfNTIxID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDQ4LCA5NiwgMiwgMSwgMCwgNDgsIDE2LCA2LCA3LCA0MixcbiAgICAxMzQsIDcyLCAyMDYsIDYxLCAyLCAxLCA2LCA1LCA0MywgMTI5LFxuICAgIDQsIDAsIDM1LCA0LCA3MywgNDgsIDcxLCAyLCAxLCAxLFxuICAgIDQsIDY2LFxuXSk7XG5leHBvcnQgY2xhc3MgRWMgZXh0ZW5kcyBOYXRpdmVBbGdvcml0aG0ge1xuICAgIGNvbnN0cnVjdG9yKGtlbSwgaGtkZikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaGtkZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYWxnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uUGtcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX25Ta1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbkRoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEVDIHNwZWNpZmljIGFyZ3VtZW50cyBmb3IgZGVyaXZpbmcga2V5IHBhaXIuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vcmRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYml0bWFza1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGtjczhBbGdJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9oa2RmID0gaGtkZjtcbiAgICAgICAgc3dpdGNoIChrZW0pIHtcbiAgICAgICAgICAgIGNhc2UgS2VtSWQuRGhrZW1QMjU2SGtkZlNoYTI1NjpcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGcgPSB7IG5hbWU6IFwiRUNESFwiLCBuYW1lZEN1cnZlOiBcIlAtMjU2XCIgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9uUGsgPSA2NTtcbiAgICAgICAgICAgICAgICB0aGlzLl9uU2sgPSAzMjtcbiAgICAgICAgICAgICAgICB0aGlzLl9uRGggPSAzMjtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmRlciA9IE9SREVSX1BfMjU2O1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpdG1hc2sgPSAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BrY3M4QWxnSWQgPSBQS0NTOF9BTEdfSURfUF8yNTY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtlbUlkLkRoa2VtUDM4NEhrZGZTaGEzODQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxnID0geyBuYW1lOiBcIkVDREhcIiwgbmFtZWRDdXJ2ZTogXCJQLTM4NFwiIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fblBrID0gOTc7XG4gICAgICAgICAgICAgICAgdGhpcy5fblNrID0gNDg7XG4gICAgICAgICAgICAgICAgdGhpcy5fbkRoID0gNDg7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JkZXIgPSBPUkRFUl9QXzM4NDtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaXRtYXNrID0gMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLl9wa2NzOEFsZ0lkID0gUEtDUzhfQUxHX0lEX1BfMzg0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEtlbUlkLkRoa2VtUDUyMUhrZGZTaGE1MTI6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxnID0geyBuYW1lOiBcIkVDREhcIiwgbmFtZWRDdXJ2ZTogXCJQLTUyMVwiIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fblBrID0gMTMzO1xuICAgICAgICAgICAgICAgIHRoaXMuX25TayA9IDY2O1xuICAgICAgICAgICAgICAgIHRoaXMuX25EaCA9IDY2O1xuICAgICAgICAgICAgICAgIHRoaXMuX29yZGVyID0gT1JERVJfUF81MjE7XG4gICAgICAgICAgICAgICAgdGhpcy5fYml0bWFzayA9IDB4MDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGtjczhBbGdJZCA9IFBLQ1M4X0FMR19JRF9QXzUyMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZXJpYWxpemVQdWJsaWNLZXkoa2V5KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYXBpLmV4cG9ydEtleShcInJhd1wiLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2VyaWFsaXplRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVzZXJpYWxpemVQdWJsaWNLZXkoa2V5KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5faW1wb3J0UmF3S2V5KGtleSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXNlcmlhbGl6ZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNlcmlhbGl6ZVByaXZhdGVLZXkoa2V5KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBqd2sgPSBhd2FpdCB0aGlzLl9hcGkuZXhwb3J0S2V5KFwiandrXCIsIGtleSk7XG4gICAgICAgICAgICBpZiAoIShcImRcIiBpbiBqd2spKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHByaXZhdGUga2V5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFVybFRvQnl0ZXMoandrW1wiZFwiXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJpYWxpemVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZXNlcmlhbGl6ZVByaXZhdGVLZXkoa2V5KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5faW1wb3J0UmF3S2V5KGtleSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRGVzZXJpYWxpemVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbXBvcnRLZXkoZm9ybWF0LCBrZXksIGlzUHVibGljKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcInJhd1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2ltcG9ydFJhd0tleShrZXksIGlzUHVibGljKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGp3a1xuICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBqd2sga2V5IGZvcm1hdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9pbXBvcnRKV0soa2V5LCBpc1B1YmxpYyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXNlcmlhbGl6ZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlS2V5UGFpcigpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXAoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkuZ2VuZXJhdGVLZXkodGhpcy5fYWxnLCB0cnVlLCBLRU1fVVNBR0VTKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlcml2ZUtleVBhaXIoaWttKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NldHVwKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBka3BQcmsgPSBhd2FpdCB0aGlzLl9oa2RmLmxhYmVsZWRFeHRyYWN0KEVNUFRZLCBMQUJFTF9ES1BfUFJLLCBuZXcgVWludDhBcnJheShpa20pKTtcbiAgICAgICAgICAgIGNvbnN0IGJuID0gbmV3IEJpZ251bSh0aGlzLl9uU2spO1xuICAgICAgICAgICAgZm9yIChsZXQgY291bnRlciA9IDA7IGJuLmlzWmVybygpIHx8ICFibi5sZXNzVGhhbih0aGlzLl9vcmRlcik7IGNvdW50ZXIrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyID4gMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxkIHRvIGRlcml2ZSBhIGtleSBwYWlyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGF3YWl0IHRoaXMuX2hrZGYubGFiZWxlZEV4cGFuZChka3BQcmssIExBQkVMX0NBTkRJREFURSwgaTJPc3AoY291bnRlciwgMSksIHRoaXMuX25TaykpO1xuICAgICAgICAgICAgICAgIGJ5dGVzWzBdID0gYnl0ZXNbMF0gJiB0aGlzLl9iaXRtYXNrO1xuICAgICAgICAgICAgICAgIGJuLnNldChieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzayA9IGF3YWl0IHRoaXMuX2Rlc2VyaWFsaXplUGtjczhLZXkoYm4udmFsKCkpO1xuICAgICAgICAgICAgYm4ucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogc2ssXG4gICAgICAgICAgICAgICAgcHVibGljS2V5OiBhd2FpdCB0aGlzLmRlcml2ZVB1YmxpY0tleShzayksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRGVyaXZlS2V5UGFpckVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlcml2ZVB1YmxpY0tleShrZXkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXAoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGp3ayA9IGF3YWl0IHRoaXMuX2FwaS5leHBvcnRLZXkoXCJqd2tcIiwga2V5KTtcbiAgICAgICAgICAgIGRlbGV0ZSBqd2tbXCJkXCJdO1xuICAgICAgICAgICAgZGVsZXRlIGp3a1tcImtleV9vcHNcIl07XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYXBpLmltcG9ydEtleShcImp3a1wiLCBqd2ssIHRoaXMuX2FsZywgdHJ1ZSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRGVzZXJpYWxpemVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkaChzaywgcGspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwKCk7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gYXdhaXQgdGhpcy5fYXBpLmRlcml2ZUJpdHMoe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiRUNESFwiLFxuICAgICAgICAgICAgICAgIHB1YmxpYzogcGssXG4gICAgICAgICAgICB9LCBzaywgdGhpcy5fbkRoICogOCk7XG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcmlhbGl6ZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9pbXBvcnRSYXdLZXkoa2V5LCBpc1B1YmxpYykge1xuICAgICAgICBpZiAoaXNQdWJsaWMgJiYga2V5LmJ5dGVMZW5ndGggIT09IHRoaXMuX25Qaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY2lwaGVyc3VpdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1B1YmxpYyAmJiBrZXkuYnl0ZUxlbmd0aCAhPT0gdGhpcy5fblNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByaXZhdGUga2V5IGZvciB0aGUgY2lwaGVyc3VpdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHVibGljKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYXBpLmltcG9ydEtleShcInJhd1wiLCBrZXksIHRoaXMuX2FsZywgdHJ1ZSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9kZXNlcmlhbGl6ZVBrY3M4S2V5KG5ldyBVaW50OEFycmF5KGtleSkpO1xuICAgIH1cbiAgICBhc3luYyBfaW1wb3J0SldLKGtleSwgaXNQdWJsaWMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkuY3J2ID09PSBcInVuZGVmaW5lZFwiIHx8IGtleS5jcnYgIT09IHRoaXMuX2FsZy5uYW1lZEN1cnZlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY3J2OiAke2tleS5jcnZ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHVibGljKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleS5kICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXk6IGBkYCBzaG91bGQgbm90IGJlIHNldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hcGkuaW1wb3J0S2V5KFwiandrXCIsIGtleSwgdGhpcy5fYWxnLCB0cnVlLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkuZCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXk6IGBkYCBub3QgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS5pbXBvcnRLZXkoXCJqd2tcIiwga2V5LCB0aGlzLl9hbGcsIHRydWUsIEtFTV9VU0FHRVMpO1xuICAgIH1cbiAgICBhc3luYyBfZGVzZXJpYWxpemVQa2NzOEtleShrKSB7XG4gICAgICAgIGNvbnN0IHBrY3M4S2V5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fcGtjczhBbGdJZC5sZW5ndGggKyBrLmxlbmd0aCk7XG4gICAgICAgIHBrY3M4S2V5LnNldCh0aGlzLl9wa2NzOEFsZ0lkLCAwKTtcbiAgICAgICAgcGtjczhLZXkuc2V0KGssIHRoaXMuX3BrY3M4QWxnSWQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FwaS5pbXBvcnRLZXkoXCJwa2NzOFwiLCBwa2NzOEtleSwgdGhpcy5fYWxnLCB0cnVlLCBLRU1fVVNBR0VTKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBFTVBUWSB9IGZyb20gXCIuL2NvbnN0cy5qc1wiO1xuaW1wb3J0IHsgT3BlbkVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBFbmNyeXB0aW9uQ29udGV4dEltcGwgfSBmcm9tIFwiLi9lbmNyeXB0aW9uQ29udGV4dC5qc1wiO1xuZXhwb3J0IGNsYXNzIFJlY2lwaWVudENvbnRleHRJbXBsIGV4dGVuZHMgRW5jcnlwdGlvbkNvbnRleHRJbXBsIHtcbiAgICBhc3luYyBvcGVuKGRhdGEsIGFhZCA9IEVNUFRZKSB7XG4gICAgICAgIGxldCBwdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHB0ID0gYXdhaXQgdGhpcy5fY3R4LmtleS5vcGVuKHRoaXMuY29tcHV0ZU5vbmNlKHRoaXMuX2N0eCksIGRhdGEsIGFhZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVuRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmNyZW1lbnRTZXEodGhpcy5fY3R4KTtcbiAgICAgICAgcmV0dXJuIHB0O1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEVNUFRZIH0gZnJvbSBcIi4vY29uc3RzLmpzXCI7XG5pbXBvcnQgeyBTZWFsRXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IEVuY3J5cHRpb25Db250ZXh0SW1wbCB9IGZyb20gXCIuL2VuY3J5cHRpb25Db250ZXh0LmpzXCI7XG5leHBvcnQgY2xhc3MgU2VuZGVyQ29udGV4dEltcGwgZXh0ZW5kcyBFbmNyeXB0aW9uQ29udGV4dEltcGwge1xuICAgIGNvbnN0cnVjdG9yKGFwaSwga2RmLCBwYXJhbXMsIGVuYykge1xuICAgICAgICBzdXBlcihhcGksIGtkZiwgcGFyYW1zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5jXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW5jID0gZW5jO1xuICAgIH1cbiAgICBhc3luYyBzZWFsKGRhdGEsIGFhZCA9IEVNUFRZKSB7XG4gICAgICAgIGxldCBjdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGN0ID0gYXdhaXQgdGhpcy5fY3R4LmtleS5zZWFsKHRoaXMuY29tcHV0ZU5vbmNlKHRoaXMuX2N0eCksIGRhdGEsIGFhZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZWFsRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmNyZW1lbnRTZXEodGhpcy5fY3R4KTtcbiAgICAgICAgcmV0dXJuIGN0O1xuICAgIH1cbn1cbiIsIi8qKlxuICogVGhlIG1pbmltdW0gaW5wbGVtZW50YXRpb24gb2YgYmlnbnVtIHRvIGRlcml2ZSBhbiBFQyBrZXkgcGFpci5cbiAqL1xuZXhwb3J0IGNsYXNzIEJpZ251bSB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbnVtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX251bSA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIH1cbiAgICB2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9udW07XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9udW0uZmlsbCgwKTtcbiAgICB9XG4gICAgc2V0KHNyYykge1xuICAgICAgICBpZiAoc3JjLmxlbmd0aCAhPT0gdGhpcy5fbnVtLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmlnbnVtLnNldDogaW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9udW0uc2V0KHNyYyk7XG4gICAgfVxuICAgIGlzWmVybygpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9udW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9udW1baV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxlc3NUaGFuKHYpIHtcbiAgICAgICAgaWYgKHYubGVuZ3RoICE9PSB0aGlzLl9udW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCaWdudW0ubGVzc1RoYW46IGludmFsaWQgYXJndW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9udW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9udW1baV0gPCB2W2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbnVtW2ldID4gdltpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTm90U3VwcG9ydGVkRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZW1pdE5vdFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBOb3RTdXBwb3J0ZWRFcnJvcihcIk5vdCBzdXBwb3J0ZWRcIikpO1xuICAgIH0pO1xufVxuIiwiLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZXhlY3V0aW9uIGVudiBpcyBEZW5vIG9yIG5vdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzRGVubyA9ICgpID0+IHR5cGVvZiBEZW5vICE9PSBcInVuZGVmaW5lZFwiO1xuLyoqXG4gKiBDaGVja3Mgd2hldGVociB0aGUgdHlwZSBvZiBpbnB1dCBpcyBDcnlwdG9LZXlQYWlyIG9yIG5vdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzQ3J5cHRvS2V5UGFpciA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJlxuICAgIHggIT09IG51bGwgJiZcbiAgICB0eXBlb2YgeC5wcml2YXRlS2V5ID09PSBcIm9iamVjdFwiICYmXG4gICAgdHlwZW9mIHgucHVibGljS2V5ID09PSBcIm9iamVjdFwiO1xuLyoqXG4gKiBDb252ZXJ0cyBpbnRlZ2VyIHRvIG9jdGV0IHN0cmluZy4gSTJPU1AgaW1wbGVtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpMk9zcChuLCB3KSB7XG4gICAgaWYgKHcgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpMk9zcDogdG9vIHNtYWxsIHNpemVcIik7XG4gICAgfVxuICAgIGlmIChuID49IDI1NiAqKiB3KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImkyT3NwOiB0b28gbGFyZ2UgaW50ZWdlclwiKTtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkodyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ICYmIG47IGkrKykge1xuICAgICAgICByZXRbdyAtIChpICsgMSldID0gbiAlIDI1NjtcbiAgICAgICAgbiA9IG4gPj4gODtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8qKlxuICogQ29uY2F0ZW5hdGVzIHR3byBVaW50OEFycmF5cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGggKyBiLmxlbmd0aCk7XG4gICAgcmV0LnNldChhLCAwKTtcbiAgICByZXQuc2V0KGIsIGEubGVuZ3RoKTtcbiAgICByZXR1cm4gcmV0O1xufVxuLyoqXG4gKiBEZWNvZGVzIEJhc2U2NFVybC1lbmNvZGVkIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRVcmxUb0J5dGVzKHYpIHtcbiAgICBjb25zdCBiYXNlNjQgPSB2LnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIGNvbnN0IGJ5dGVTdHJpbmcgPSBhdG9iKGJhc2U2NCk7XG4gICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXRbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4iXSwibmFt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QkFBbUIsNkRBQWdCO0FBQ25DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQWdCO0FBQ25DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQWdCO0FBQ25DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZOeUQ7QUFDZ0I7QUFDTDtBQUNGO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0RUFBbUI7QUFDMUQs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